<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>What a Life</title>
    <description>这是一个Java程序员的博客 | Java Blog</description>
    <link>http://localhost:4000/blog/</link>
    <atom:link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 17 Dec 2021 18:18:10 +0800</pubDate>
    <lastBuildDate>Fri, 17 Dec 2021 18:18:10 +0800</lastBuildDate>
    <generator>Jekyll v4.2.1</generator>
    
      <item>
        <title>MySQL学习笔记(十一)：order by</title>
        <description>&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order by&lt;/code&gt;  的内部实现有两种： &lt;strong&gt;全字段排序&lt;/strong&gt; 和 &lt;strong&gt;rowid排序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;按是否需要 &lt;u&gt;磁盘临时文件&lt;/u&gt; 辅助排序可分为：&lt;strong&gt;内存排序&lt;/strong&gt; 和 &lt;strong&gt;外部排序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;按是否需要 &lt;u&gt;临时表&lt;/u&gt; 辅助排序可分为：&lt;strong&gt;内存临时表&lt;/strong&gt; 和 &lt;strong&gt;磁盘临时表&lt;/strong&gt;。&lt;/p&gt;

&lt;h1 id=&quot;查看是否需要排序&quot;&gt;查看是否需要排序&lt;/h1&gt;

&lt;p&gt;当 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;explain&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Extra&lt;/code&gt; 字段显示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Using filesort&lt;/code&gt;，表示该查询需要排序。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注：只是表示需要排序，这里不区分是在内存还是磁盘，别被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filesort&lt;/code&gt; 误导&lt;/strong&gt;。根据数据量和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer&lt;/code&gt; 大小，可能是内存排序，也可能是外部排序(需要借助磁盘临时文件辅助排序)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MySQL 会为每个线程分配一块内存用于排序，称为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer&lt;/code&gt;&lt;/strong&gt;。对应的参数为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer_size&lt;/code&gt; ，顾名思义为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer&lt;/code&gt; 的大小。默认值为256k，最小可设为32k。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;排序实现&quot;&gt;排序实现&lt;/h1&gt;

&lt;p&gt;可通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;optimizer_trace&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filesort_summary&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_mode&lt;/code&gt; 来确定排序采用了哪种实现逻辑。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;只对当前&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;session&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;生效&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optimizer_trace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;enabled=on&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;这两句必须一起执行才能看到&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`OPTIMIZER_TRACE`&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;输出，而且只能在命令行中使用，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datagrip&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;中看不到输出&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;执行&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`information_schema`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`OPTIMIZER_TRACE`&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;G&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;截取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;optimizer_trace&lt;/code&gt; 部分输出(在末尾部分)如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为了演示外部排序，将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer_size&lt;/code&gt; 设为了最小值 32768(32k)，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nl&quot;&gt;&quot;filesort_summary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;memory_available&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32768&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key_size&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;row_size&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;39&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;max_rows_per_buffer&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;840&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;num_rows_estimate&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18446744073709551615&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;num_rows_found&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20211&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;num_initial_chunks_spilled_to_disk&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;peak_memory_used&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;35384&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;sort_algorithm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;std::sort&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;sort_mode&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;fixed_sort_key, packed_additional_fields&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memory_available&lt;/code&gt; 即为排序可使用的内存大小，和上面设置的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer_size&lt;/code&gt;一致。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;peak_memory_used&lt;/code&gt; 表示排序过程中的峰值内存使用大小，可见大于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer_size&lt;/code&gt;，内存装不下了，只能使用外部排序，借助磁盘临时文件来辅助排序。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;num_initial_chunks_spilled_to_disk&lt;/code&gt; 即为排序过程中使用的临时文件数，可见此次排序使用了21个临时文件，使用&lt;strong&gt;归并排序算法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;num_rows_found&lt;/code&gt; 表示有 20211 行数据参与了排序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_mode&lt;/code&gt;&lt;/strong&gt; 总共有3种情况，说明了在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer&lt;/code&gt; 中包含了哪些内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;sort_key, rowid&amp;gt;&lt;/code&gt;: This indicates that sort buffer tuples are pairs that contain the sort key value and row ID of the original table row. Tuples are sorted by sort key value and the row ID is used to read the row from the table.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;即 &lt;strong&gt;rowid排序&lt;/strong&gt;，意思是排序时只使用了排序字段和rowid，目的是为了装入更多数据，尽量使用内存排序。自然，为了获取其他字段内容，还需要根据rowid回表查询。&lt;/p&gt;

      &lt;p&gt;对于有主键的Innodb表，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rowid&lt;/code&gt; 就是主键；对于没有主键的Innodb表，系统会生成一个6字节的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rowid&lt;/code&gt; 作为主键。&lt;/p&gt;

      &lt;p&gt;在 8.0.20 之前，还有一个参数：&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max_length_for_sort_data&lt;/code&gt;&lt;/strong&gt;，默认值为4096，用于控制排序的行数据长度。如果单行数据长度超过这个值，MySQL就会由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;全字段排序&lt;/code&gt; 转为使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rowid排序&lt;/code&gt;。&lt;/p&gt;

      &lt;p&gt;从 8.0.20 开始，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max_length_for_sort_data&lt;/code&gt; 由于优化器的调整已经过时了，设置这个参数将不会有任何作用。&lt;/p&gt;

      &lt;p&gt;MySQL的一个设计思想是能用内存就用内存，对于Innodb表来说，会优先选择全字段排序，因为不需要回表(当数据页不在内存中时，回表还是需要读磁盘)，结果集直接就从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer&lt;/code&gt; 返回了。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rowid排序&lt;/code&gt;是第二选择。如果转成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rowid&lt;/code&gt; 排序内存还放不下的话，最后会转成外部排序。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;sort_key, packed_additional_fields&amp;gt;&lt;/code&gt;: Like the previous variant, but the additional columns are packed tightly together instead of using a fixed-length encoding.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;即&lt;strong&gt;全字段排序&lt;/strong&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer&lt;/code&gt; 中包含了排序的字段和查询引用到的全部字段(因此叫做全字段排序)，结果集会直接从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer&lt;/code&gt; 中返回。&lt;/p&gt;

      &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;packed&lt;/code&gt; 表示排序过程由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer&lt;/code&gt; 紧张(见上图)，对字符串做了“紧凑”处理，在排序过程中是按照字段实际长度来分配空间的。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;sort_key, additional_fields&amp;gt;&lt;/code&gt;: This indicates that sort buffer tuples contain the sort key value and columns referenced by the query. Tuples are sorted by sort key value and column values are read directly from the tuple.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;同上，只是没有了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;packed&lt;/code&gt;。&lt;/p&gt;

      &lt;p&gt;示例：&lt;/p&gt;

      &lt;p&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer_size&lt;/code&gt; 恢复为默认值：262144(256k)，再看看有什么变化：&lt;/p&gt;

      &lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nl&quot;&gt;&quot;filesort_summary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;memory_available&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;262144&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key_size&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;row_size&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;max_rows_per_buffer&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;num_rows_estimate&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18446744073709551615&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;num_rows_found&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20211&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;num_initial_chunks_spilled_to_disk&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;peak_memory_used&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;43043&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;sort_algorithm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;std::stable_sort&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;unpacked_addon_fields&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;using_priority_queue&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
              &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;sort_mode&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;fixed_sort_key, additional_fields&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/div&gt;

      &lt;p&gt;可看到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;peak_memory_used&lt;/code&gt; &amp;lt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memory_available&lt;/code&gt;，说明 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer&lt;/code&gt; 完全够用了，直接在内存排序即可，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;num_initial_chunks_spilled_to_disk&lt;/code&gt; 为0，表示不需要借助磁盘临时文件来辅助排序。&lt;/p&gt;

      &lt;p&gt;而且 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_mode&lt;/code&gt; 中也没有了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;packed&lt;/code&gt;，因为内存空间已经完全够用了，不再需要做“紧凑”处理了。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;排序提速&quot;&gt;排序提速&lt;/h1&gt;

&lt;p&gt;从上面分析可以看出，排序是个代价比较高的操作，尤其是当转成外部排序时，会涉及到多次磁盘IO。&lt;/p&gt;

&lt;p&gt;所以尽量使用内存排序是最优解，对应可调整的参数是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer_size&lt;/code&gt;。那还有没有更进一步的优化？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;很明显，借助索引，可以完全避免排序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比如这样一句sql：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;city&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;xxx&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;便可以建立一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(city,name)&lt;/code&gt;  的联合索引，那么在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(city,name)&lt;/code&gt; 这棵索引树上便是先按 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;city&lt;/code&gt; 排序，再按&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 排序(即 city 相同时 name 局部有序)。&lt;/p&gt;

&lt;p&gt;这样的话只需先快速定位到 city，然后依次往后遍历取出 id，再回表取出整行数据，作为结果集的一部分直接就返回了，完全避免了排序。&lt;u&gt;而且，由于是有序的，对于 limit 来说更友好，不再需要遍历所有 city=xxx 的数据了，遍历到第1000条便可直接结束了&lt;/u&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;explain&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rows&lt;/code&gt; 不准)。&lt;/p&gt;

&lt;p&gt;更进一步，如果查询没必要获取全部字段，则可利用到&lt;strong&gt;覆盖索引&lt;/strong&gt;，直接从索引树获取到全部字段，连回表查询都不用了。&lt;/p&gt;

&lt;p&gt;如上面的 sql 可改为：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;city&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;city&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;xxx&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时建一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(city,name,age)&lt;/code&gt; 的联合索引，即可满足排序需求，又不需要回表查询，此时是最优解。&lt;/p&gt;

&lt;p&gt;当然，还是那句老话，维护索引有代价，需综合考虑。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;实例&quot;&gt;实例&lt;/h1&gt;

&lt;p&gt;假设维护一个人员信息表，现已有索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(city,name)&lt;/code&gt; ，问以下查询是否需要排序？&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;city&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虽然已有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(city,name)&lt;/code&gt; 索引，但只能保证同一 city 内 name 有序，不同 city 之间 name 仍然是无序的。所以该查询在数据库内部仍然需要排序。&lt;/p&gt;

&lt;p&gt;如果出于种种原因想要避免在数据库内部排序，有什么办法？&lt;/p&gt;

&lt;p&gt;那就在应用端排序，把一条sql拆为两句：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;city&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;city&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;拆开的查询可以利用到索引，不需要排序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在应用端便可得到两个有序数组，使用归并排序合并为一个有序数组后，取前100即为结果集。&lt;/p&gt;

&lt;p&gt;如果是分页查询呢，比如：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;city&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还是和上面的思路一样，拆分为2个查询：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;city&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;city&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样使用归并算法得到一个有序数组，取第 10000 ~ 10100 的值即为结果集。&lt;/p&gt;

&lt;p&gt;这时的问题是数据量太大，如果应用端内存紧张的话，可考虑只查询 id 和 name：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;city&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;city&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该查询不需排序，且会用到覆盖索引，也不用回表。合并得到有序数组后，取出第 10000 ~ 10100 的 id，再拿这100个 id 去数据库查出所有记录即可。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;随机排序&quot;&gt;随机排序&lt;/h1&gt;

&lt;h3 id=&quot;order-by-rand&quot;&gt;order by rand()&lt;/h3&gt;

&lt;p&gt;随机排序在现实中的应用场景还是比较多的，可能会首先想到使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order by rand()&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;表示从单词表中随机抽取3个单词。&lt;/p&gt;

&lt;p&gt;虽然用法简单明了，但它的执行效率怎样(&lt;u&gt;对于数据量不是特别大的表，其实也完全够用了&lt;/u&gt;)，做个实验。&lt;/p&gt;

&lt;p&gt;先构造一张 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;words&lt;/code&gt; 表和实验数据：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`words`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`word`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;delimiter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;97&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;97&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;97&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;97&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;delimiter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;explain&lt;/code&gt; 下看看：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211206121345480.png&quot; alt=&quot;image-20211206121345480&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Extra&lt;/code&gt; 显示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Using temporary; Using filesort&lt;/code&gt; ，表示需要临时表，需要排序。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：需要和上面讲到的临时文件区分开来，临时表和临时文件是两个东西。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为什么需要临时表?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order by rand()&lt;/code&gt; 的实现逻辑是为每一行数据生成一个随机数，然后按这个随机数来排序，以达到随机排序的目的。所以需要一张临时表来存放这个新生成的随机数字段。&lt;/p&gt;

&lt;p&gt;再次强调，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Using filesort&lt;/code&gt; 只是表示需要排序，有可能是内存排序，也有可能是外部排序。不要看它的名字是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filesort&lt;/code&gt;，就认为一定是外部排序。&lt;/p&gt;

&lt;p&gt;它的整个流程是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;生成一张内存临时表。扫描 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;words&lt;/code&gt; 表，将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;word&lt;/code&gt; 字段和生成的随机数存入临时表；&lt;/li&gt;
  &lt;li&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;word&lt;/code&gt; 字段和随机数放入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer&lt;/code&gt; 排序；&lt;/li&gt;
  &lt;li&gt;从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer&lt;/code&gt; 中取出前3个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;word&lt;/code&gt;，作为结果集返回。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;optimizer_trace&lt;/code&gt; 验证一下：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optimizer_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;enabled=on&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;information_schema&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPTIMIZER_TRACE&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;G&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211206130948945.png&quot; alt=&quot;image-20211206130948945&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可看到该排序使用了全字段排序，且没有使用到磁盘临时文件。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort_buffer&lt;/code&gt; 中同时最多有4行数据存在，每一行长度为 $8+279=287$。为什么只有4行？难道不应该是对10000行数据排序吗？&lt;/p&gt;

&lt;p&gt;答案是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filesort_priority_queue_optimization&lt;/code&gt;中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chosen&lt;/code&gt; 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;，表示使用了优先级队列排序(即堆排序)。因为只需要 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;limit 3&lt;/code&gt;，相当于求 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;top3&lt;/code&gt;，剩下9997条数据并不需要排序，堆排序完美适合解决这个问题。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;大顶堆求 top k 小，小顶堆求 top k 大&lt;/strong&gt;。而且最后堆顶元素就是第k大(小)元素。&lt;/p&gt;

  &lt;p&gt;比如数据集为[0.9,0.4,0.5,0.7,0.3,0.8]，利用大顶堆求top3小：&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;建立初始堆：[0.9,0.4,0.5]，0.9为堆顶元素；&lt;/li&gt;
    &lt;li&gt;插入0.7，比0.9小，交换，0.7为最大元素，堆无需调整，此时堆为 [0.7,0.4,0.5]；&lt;/li&gt;
    &lt;li&gt;插入0.3，比0.7小，交换，0.3下沉堆化，此时堆为 [0.5,0.4,0.3]；&lt;/li&gt;
    &lt;li&gt;插入0.8，比0.5大，无需交换，堆不变，此时堆为 [0.5,0.4,0.3]；&lt;/li&gt;
    &lt;li&gt;遍历结束，top3小即为 [0.5,0.4,0.3]，且0.5为第3小的元素。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;自己实现随机排序&quot;&gt;自己实现随机排序&lt;/h3&gt;

&lt;h4 id=&quot;方法一&quot;&gt;方法一&lt;/h4&gt;

&lt;p&gt;随机取一行的算法如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;取得主键 id 的最大值M和最小值N&lt;/li&gt;
  &lt;li&gt;用随机函数生成一个介于M和N之间的数 $X=(M-N)*rand()+N$&lt;/li&gt;
  &lt;li&gt;取 $≥X$ 的第一个 id 的行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用sql表示如下：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max(id)&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;min(id)&lt;/code&gt; 都不需要扫描索引，第三步的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select&lt;/code&gt; 也可以用索引快速定位，速度很快。&lt;/p&gt;

&lt;p&gt;但是有个致命缺陷，它&lt;strong&gt;不是真正的随机。如果 id 是连续的没问题，但如果 id 之间有空洞，则选择不同行的概率不一样&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如 [1,2,4,5]，按这个算法，4 被选中的概率是其他的两倍。&lt;strong&gt;但是它速度最快&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;方法二&quot;&gt;方法二&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;取得整个表的行数，记做 C&lt;/li&gt;
  &lt;li&gt;$Y = floor(C*rand())$&lt;/li&gt;
  &lt;li&gt;limit Y,1&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;limit Y,1&lt;/code&gt; 的处理逻辑是按顺序一行行读出来，丢掉前Y个，取下一个作为结果返回(可通过慢查询日志的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rows_examined&lt;/code&gt; 验证)。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里可能会有点疑问，为什么不走主键索引树，直接快速定位到 Y不就行了。&lt;/p&gt;

  &lt;p&gt;这是想当然了，因为并不知道第 Y 行的主键id是多少呀，除非只有当主键id从1开始连续递增才行(第Y行的主键id就是Y)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以该算法总共扫描的行数为：$C+Y+1$ ，执行代价比方法一要高一些，但跟 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order by rand()&lt;/code&gt; 比起来还是快得多，而且严格随机。&lt;/p&gt;

&lt;p&gt;那么用该算法解决随机获取3个单词的步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;取得整个表的行数，记做 C&lt;/li&gt;
  &lt;li&gt;$Y1 = floor(C&lt;em&gt;rand()), Y2 = floor(C&lt;/em&gt;rand()), Y3 = floor(C*rand())$&lt;/li&gt;
  &lt;li&gt;limit Y1,1；limit Y2,1；limit Y3,1&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总共需扫描  $【C+(Y1+Y2+Y3)+3】$ 行 。&lt;/p&gt;

&lt;p&gt;其实还有进一步优化的空间，因为Y1、Y2、Y3 重复扫描了：&lt;/p&gt;

&lt;p&gt;取得 Y1、Y2、Y3后，设最大值为M，最小值为N，执行&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从结果集中取第一条、最后一条、(Y2-Y1)条即可。&lt;/p&gt;

&lt;p&gt;改进后扫描行数为 $C+M+1$，大大减少了扫描行数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不可一味盲目追求极致解，够用就好！！！&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;官方优化指南&quot;&gt;官方优化指南&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html&quot;&gt;ORDER BY Optimization&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/10/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)-order-by/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/10/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)-order-by/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(十)：count</title>
        <description>&lt;h1 id=&quot;count-的实现方式&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt; 的实现方式&lt;/h1&gt;

&lt;p&gt;不同引擎实现方式不同：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;MyISAM：将总行数直接存在磁盘上，查询的时候返回，因此速度很快&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Innodb：因为需要支持事务，而事务是由 MVCC 实现的，一行记录需要先判断对查询事务的可见性，所以&lt;strong&gt;“应该返回多少行” 是不确定的&lt;/strong&gt;。因此Innodb的实现方式是把数据一行一行的从引擎中读出来，可见的行才会被累计进来。&lt;/p&gt;

    &lt;p&gt;举个例子，假设表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 有 10000 条数据：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionC&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select count(*) from t;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;insert into t(插入一行);&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;insert into t(插入一行);&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select count(*) from t; &lt;strong&gt;(返回10000)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select count(*) from t; &lt;strong&gt;(返回10002)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select count(*) from t; &lt;strong&gt;(返回10001)&lt;/strong&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;可见同一时刻的并发查询，返回的结果是不一致的。&lt;/p&gt;

    &lt;p&gt;由于需要遍历全表，因此对于大表，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt; 会变得很慢。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;为-count-提速&quot;&gt;为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt; 提速&lt;/h1&gt;

&lt;h3 id=&quot;用缓存保存计数&quot;&gt;用缓存保存计数&lt;/h3&gt;

&lt;p&gt;这是第一时间会想到的方式，比如使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt;。更新数据时顺便更新 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt;中的计数值，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt; 的时候直接查询 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 即可，速度很快。&lt;/p&gt;

&lt;p&gt;但是这会有2个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;缓存异常宕机会丢失更新&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;redis持久化有RDB和AOF两种方式；RDB按照备份策略，比如60秒1000个k-v被修改，备份过程中宕机，那么这个阶段的所有更新都会丢失；AOF按照备份策略，比如 appendfsync always 策略，同步记录所执行的指令到日志文件，但是它的日志和mysql的WAL(先写日志)不同，它是后写日志，可能指令执行后写日之前宕机，那这个数据就丢失了，虽然丢失数据较少且概率较低，但依然存在这个可能。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;可以在重启后到数据库中执行一次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt;获取行数后填到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 中，毕竟异常宕机重启不会经常发生，偶尔一次全表扫描的成本还是可以接受的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结果可能不准&lt;/p&gt;

    &lt;p&gt;由于更新数据和更新 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 统计计数不是一个原子操作，可能会出现统计计数和数据不一致的问题。&lt;/p&gt;

    &lt;p&gt;比如以下场景：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 计数+1&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;读 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 计数&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;查询近100条记录&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;插入一行数据&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;sessionB 在查询计数时已经加了1，但是查不到新插入的数据(将sessionA的两个操作调换顺序也是类似的)。究其原因， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 和数据库可以看做两个不同的数据源，不能保证两个操作的原子性(不可分割)。这类问题属于分布式一致性问题，虽可通过引入其他手段解决，但会使一个简单的计数查询需求变得很复杂，没有必要。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;在数据库保存计数&quot;&gt;在数据库保存计数&lt;/h3&gt;

&lt;p&gt;那不存到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt;  中，存到数据库计数表中，会出现上面的问题吗？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先，Innodb 支持崩溃恢复，所以不存在更新丢失的问题。&lt;/li&gt;
  &lt;li&gt;将上图中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt;  的操作换成对数据库计数表的操作，不会出现数据不一致的问题。很明显，Innodb的事务保证了操作的原子性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，&lt;strong&gt;对于大表，推荐使用数据库计数表来提速 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt;&lt;/strong&gt; 。&lt;/p&gt;

&lt;h4 id=&quot;进一步优化&quot;&gt;进一步优化&lt;/h4&gt;

&lt;p&gt;根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;两阶段锁&lt;/code&gt; 协议，可以通过调整事务内更新语句的顺序：&lt;strong&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 计数表放到最后&lt;/strong&gt;，来减少计数表行锁等待的时间，提高并发度。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;不同-count-用法的区别&quot;&gt;不同 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt; 用法的区别&lt;/h1&gt;

&lt;p&gt;首先，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt; 是一个聚合函数，它的逻辑是，&lt;strong&gt;对于返回的结果集，一行一行的判断，不为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 就+1&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;count(主键id)&lt;/p&gt;

    &lt;p&gt;遍历整张表，把每一行的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 取出来返回给 server 层，server 层判断 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 不可能为空，+1。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这里可能会觉得奇怪，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 根本不可能为空，为什么还要多此一举去判断一下。&lt;/p&gt;

      &lt;p&gt;的确是没什么必要，但类似需要优化的地方太多了，MySQL专门对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt; 优化过了，直接使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt;  就好了。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;count(1)&lt;/p&gt;

    &lt;p&gt;遍历整张表，但不取值。Server 层对于返回的每一行，放一个 “1“ 进去，判断不可能为空，+1。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;很明显，相较于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(主键id)&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(1)&lt;/code&gt; 效率更高，因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(id)&lt;/code&gt;  还需要解析数据行、拷贝字段值等操作。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;count(字段)&lt;/p&gt;

    &lt;p&gt;遍历整张表，把每一行对应的字段值取出来返回给 server 层，server 层判断是否为空，不为空+1。所以效率 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(字段)&lt;/code&gt; ≤ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;count(*)&lt;/p&gt;

    &lt;p&gt;做了专门的优化，并不会把全部字段取出来，而是直接不取值，认定&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt; 肯定不为空，直接按行累加。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;按效率排序：count(字段) &amp;lt; count(主键id) &amp;lt; count(1) ≈ count(*)。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐直接使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/10/22/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81)-count/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/10/22/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81)-count/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(九)：如何收缩表空间?</title>
        <description>&lt;h3 id=&quot;使用-delete-删除数据不会使表空间变小&quot;&gt;&lt;strong&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 删除数据不会使表空间变小&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;前文有提过，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 只是将记录标记为删除，并没有真正删除。只有当其对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update undo logs&lt;/code&gt; 被清除时才会由后台 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;purge&lt;/code&gt; 任务物理删除，&lt;u&gt;即没有事务再需要这些版本的记录时&lt;/u&gt;会执行物理删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;即便是物理删除，也不会把磁盘空间返还给操作系统。&lt;/strong&gt;究其原因，出于性能考虑，物理删除后的空间会被&lt;strong&gt;复用&lt;/strong&gt;。删除记录后，当插入符合范围条件的数据时，原空间会被复用。删除一整个数据页上的所有记录后，当需要使用新页的时候，原数据页会被复用。&lt;/p&gt;

&lt;p&gt;可通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show table status like &apos;t&apos;&lt;/code&gt; 来查看表碎片大小，如果过大，可通过重建表来释放表空间。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;几个字段的含义，都是针对 Innodb，MyISAM略有不同：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data_length&lt;/code&gt;：聚簇索引大小近似值，单位是字节。&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;index_length&lt;/code&gt;：非聚簇索引大小近似值，单位是字节。&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data_free&lt;/code&gt;：已分配但未使用的空间大小近似值，单位是字节。表碎片大小即是查看这个字段。&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;这三个值之和近似接近 ibd 文件大小。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;重建表&quot;&gt;重建表&lt;/h3&gt;

&lt;p&gt;不光删除数据会造成&lt;strong&gt;空洞&lt;/strong&gt;(可被复用但没被使用的空间)，插入和更新也会。&lt;/p&gt;

&lt;p&gt;因为插入数据往往都是随机的，即&lt;strong&gt;基本不可能按索引递增顺序插入&lt;/strong&gt;，就很有可能造成数据页的分裂。比如当一个数据页满了，此时再插入一行数据到此节点就会造成数据页分裂，原数据页末尾就会产生空洞。&lt;/p&gt;

&lt;p&gt;更新可理解为先删除后插入，同理。&lt;/p&gt;

&lt;p&gt;重建表就是通过&lt;strong&gt;去掉这些空洞，来达到收缩表空间的目的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;命令如下：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;56版本之前&quot;&gt;5.6版本之前&lt;/h4&gt;

&lt;p&gt;内部流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新建一张与原表结构相同的临时表&lt;/li&gt;
  &lt;li&gt;按主键ID递增的顺序，将数据一行一行的从原表读出来再插入到临时表中。&lt;strong&gt;这一步就可以去掉原表主键索引上的空洞。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;用临时表替换掉原表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个流程有个问题，在第2步中，原表不能有更新操作。也就是说，这个ddl不是online的。&lt;/p&gt;

&lt;h4 id=&quot;从56版本开始&quot;&gt;从5.6版本开始&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;建立一个临时文件，扫描原表的所有数据页&lt;/li&gt;
  &lt;li&gt;用数据页中原表的记录生成B+树，存储到临时文件中&lt;/li&gt;
  &lt;li&gt;在生成临时文件的过程中，将对原表的操作记录在一个日志文件(row log)中&lt;/li&gt;
  &lt;li&gt;临时文件生成后，将日志文件中的操作应用到临时文件&lt;/li&gt;
  &lt;li&gt;用临时文件替换掉原表的数据文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;很明显，在该过程执行中是允许对原表做增删改操作的，&lt;strong&gt;这也是 Online DDL 名字的由来&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;u&gt;注意&lt;/u&gt;&lt;/strong&gt;：对于大表来说，因为需要扫描原表数据和构建临时文件，这个步骤是很消耗IO和CPU资源的。尤其对于线上业务，要很小心的&lt;strong&gt;控制操作时间&lt;/strong&gt;。如果想要安全操作的话，推荐使用 github 的 &lt;a href=&quot;https://github.com/github/gh-ost&quot;&gt;gh-ost&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;online-和-inplace&quot;&gt;online 和 inplace&lt;/h3&gt;

&lt;p&gt;online ddl 构建的临时文件位于 Innodb 内部，整个过程也都是在 Innodb 内部完成。&lt;strong&gt;对于 Server 层来说&lt;/strong&gt;，没有把数据挪动到临时表(5.6版本之前的操作流程)，相当于是一个 “原地” 操作，因此叫做 &lt;strong&gt;inplace&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;其实隐含的意思是&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ALGORITHM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inplace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相对的，就有&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ALGORITHM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对应的就是5.6版本之前的操作流程。&lt;/p&gt;

&lt;p&gt;所以，如果现在有一个1TB的表，磁盘空间为1.2TB，能不能做一个inplace的ddl呢？&lt;/p&gt;

&lt;p&gt;答案是不能，因为临时文件也是要占用空间的。&lt;/p&gt;

&lt;p&gt;总结来说，online 是指在操作过程会不会阻塞对原表的增删改操作。inplace 指的是在 Serve 层建临时表还是直接在存储引擎内建临时文件。&lt;/p&gt;

&lt;h3 id=&quot;两种重建表的方式及区别&quot;&gt;两种重建表的方式及区别&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alter table A engine=InnoDB&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;如上文所述&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;optimize table A&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;等同于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alter table A engine=InnoDB&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;analyze table A&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;analyze&lt;/code&gt;：重新统计索引信息)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;什么情况下重建表空间反而变大了&quot;&gt;什么情况下重建表空间反而变大了？&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;表本身已经没有空洞了，比如刚刚重建过一次，这时候再重建，如果恰好在重建期间有外部的 DML 在执行，就有可能会引入新的空洞。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;而且重建表的时候并不是把每个数据页都占满，而是会留下 $1/16$ 的&lt;strong&gt;预留空间&lt;/strong&gt;给后续的更新用，也就是说重建后的表并不是百分百紧凑的。&lt;/p&gt;

    &lt;p&gt;以下过程就可能会出现这种情况：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;重建一次&lt;/li&gt;
      &lt;li&gt;插入一部分数据，但是这部分数据使用的是预留空间&lt;/li&gt;
      &lt;li&gt;再重建一次。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;这时由于预留空间被使用了，再次重建时就需要再额外留出 $1/16$ 的预留空间，所以空间反而变大了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 20 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/10/20/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B9%9D)-%E5%A6%82%E4%BD%95%E6%94%B6%E7%BC%A9%E8%A1%A8%E7%A9%BA%E9%97%B4/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/10/20/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B9%9D)-%E5%A6%82%E4%BD%95%E6%94%B6%E7%BC%A9%E8%A1%A8%E7%A9%BA%E9%97%B4/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(八)：MySQL锁</title>
        <description>&lt;p&gt;&lt;strong&gt;MySQL中的锁有三类：全局锁、表级锁、行级锁&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;全局锁&quot;&gt;全局锁&lt;/h1&gt;

&lt;p&gt;即给整个数据库实例上锁，让整个库都处于只读状态，除查询以外的操作都会被阻塞。server层实现。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果加上全局锁后，客户端由于异常断开，MySQL会自动释放这个锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;加锁：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;或&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;解锁：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tables&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用场景：做全库逻辑备份&lt;/p&gt;

&lt;p&gt;隐患：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;由于只能查询，所以在此期间业务基本停摆&lt;/li&gt;
  &lt;li&gt;如果在主库上备份，业务停摆；如果在备库上备份，在此期间备库不能执行从主库同步过来的 binlog，会导致主从延迟&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那如果备份的时候不加全局锁会发生什么情况呢？&lt;/p&gt;

&lt;p&gt;不加锁，&lt;strong&gt;会导致备份出来的库不是同一个逻辑时间点的&lt;/strong&gt;，数据从业务逻辑上看是不一致的。&lt;/p&gt;

&lt;p&gt;比如在备份过程中先备份了A表，然后执行了一个业务操作，这个业务操作会同时更新A表和B表，再备份B表。那么这个时候备份出来的数据A表还是老版本，而B表已经被更新了，这个备份就是有问题的，是逻辑不一致的。&lt;/p&gt;

&lt;p&gt;&lt;u&gt;为了既不影响业务，也要保证备份视图的逻辑一致性&lt;/u&gt;，&lt;strong&gt;推荐采用另一种全库备份的方法&lt;/strong&gt;：&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysqldump -single-transaction&lt;/code&gt;&lt;/strong&gt;。导数据之前会启动一个事务，来确保拿到一致性视图。而且由于 MVCC 的支持，在此期间是可以正常更新的。&lt;/p&gt;

&lt;p&gt;当然显而易见，这种方法只适用于支持事务的存储引擎，所以这也是为什么推荐使用 Innodb 而不是 MyISAM 的一个原因。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;表级锁&quot;&gt;表级锁&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;server层实现，分两种：元数据锁(MDL)和表锁。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;表锁&quot;&gt;表锁&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;与全局锁一样，也会在客户端断开时自动释放&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;加锁：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tables&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;解锁：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tables&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上述加锁语句为例，t1加了读锁，t2加了写锁：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任何线程都不能写 t1 ，包括本线程&lt;/li&gt;
  &lt;li&gt;只有本线程能读写 t2&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本线程甚至不能访问除 t1、t2 之外的任何表&lt;/strong&gt;，这点很奇怪，不懂为什么这么设计，访问其他表时会报错 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Table &apos;xxx&apos; was not locked with LOCK TABLES&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;元数据锁&quot;&gt;元数据锁&lt;/h3&gt;

&lt;p&gt;Meta data lock，MDL&lt;/p&gt;

&lt;p&gt;不需要显示使用，访问表的时候会自动加上。&lt;/p&gt;

&lt;p&gt;从MySQL5.5开始引入，&lt;strong&gt;当做增删查改时，会加MDL读锁；当变更表结构时，会加MDL写锁&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;读锁不互斥，因此可以有多个线程同时对一张表增删改查&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读写互斥，即不能有多个线程同时更改表结构，或一个线程在增删改查而另一个线程在更改表结构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MDL锁在事务提交时才会释放，在变更表结构时要特别小心，以免锁住线上的查询和更新，导致整张表不能读写。下面是一个示例：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;session A&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;session B&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;session C&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;session D&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select * from t limit 1;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select * from t limit 1;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;alter table t add f int;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select * from t limit 1;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;session A 先开启了一个事务，执行了一次查询，并且没有马上提交，这时会对表 t 加一个 MDL 读锁。&lt;/p&gt;

    &lt;p&gt;session B 也需要一个 MDL 读锁，读锁之间不互斥，可以正常执行查询。&lt;/p&gt;

    &lt;p&gt;session C 要加一个字段，需要一个 MDL 写锁，读锁和写锁互斥，所以必须等待表 t 释放读锁之后才能继续。&lt;/p&gt;

    &lt;p&gt;session D 需要一个读锁，这里需要注意的是，&lt;strong&gt;表 t 上会有一个等待获取锁的锁队列，而获取MDL写锁的优先级要比获取读锁的优先级高&lt;/strong&gt;，所以导致session D 也被阻塞。&lt;/p&gt;

    &lt;p&gt;最后的结果就是表 t 完全被锁住，完全不可读写了。如果客户端还有重试机制，一直在发起重试请求，MySQL的线程很快就会爆满，最后导致整个实例挂掉。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​		解决办法：&lt;/p&gt;

&lt;p&gt;​		1、监控长事务(information_schema.innodb_trx)，要么先暂停DDL，要么kill掉这个长事务&lt;/p&gt;

&lt;p&gt;​		2、但是对于一些热点表，kill未必管用，可能刚kill掉一个长事务，新的请求立马又来了。这种情况下，理想的办法是为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alter table&lt;/code&gt; 语句设定等待时间，如果在此期间能拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后再重试这个命令来重试这个过程。MariaDB 和 AliSQL 已经提供了这个功能，MySQL暂时没有。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOWAIT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WAIT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;MySQL可以通过调整 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock_wait_timeout&lt;/code&gt;&lt;/strong&gt; 值来控制这个超时时间，默认值是 31536000s，即1年，显然这个时间太长了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;获取元数据锁的超时时间，注意与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_lock_wait_timeout&lt;/code&gt; 区分开来&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;案例一&quot;&gt;案例一&lt;/h1&gt;

&lt;p&gt;假如正在备库执行一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-single-transaction&lt;/code&gt; 的逻辑备份，此时在主库上对表 t 执行了一个 DDL，备库会出现什么情况？&lt;/p&gt;

&lt;p&gt;备库会根据 DDL 的 binlog 到达的时间点不同而出现不同的情况。&lt;/p&gt;

&lt;p&gt;先拆解一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysqldump -single-transaction&lt;/code&gt; 在内部的执行逻辑：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;set session transaction isolation level repeatable read;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;start transaction with consistent snapshot;&lt;/p&gt;

    &lt;p&gt;(其他表的备份逻辑)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SAVEPOINT sp;&lt;/p&gt;

    &lt;p&gt;(时刻1)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;show create table &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;;&lt;/p&gt;

    &lt;p&gt;(时刻2)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;select * from t;&lt;/p&gt;

    &lt;p&gt;(时刻3)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;rollback to savepoint sp;&lt;/p&gt;

    &lt;p&gt;(时刻4)&lt;/p&gt;

    &lt;p&gt;(其他表的备份逻辑)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在时刻1到达：没有任何影响，此时表 t 上没有任何 MDL 锁，所以可正常执行，备份得到的是新的表结构；&lt;/p&gt;

&lt;p&gt;在时刻2到达：此时已经先备份完了 t 的表结构，DDL才到达，在执行第5步的时候会报错：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Table definition has changed,please retry transaction&lt;/code&gt; ，mysqldump 终止；&lt;/p&gt;

&lt;p&gt;在时刻3到达：此时表结构和数据都已备份完成，但是 MDL 读锁还没释放(会在第6步后才释放)，所以 DDL 操作会阻塞，备份得到的是旧的表结构；&lt;/p&gt;

&lt;p&gt;在时刻4到达：MDL 读锁已被释放，DDL 可正常执行，备份得到的是旧的表结构。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;行锁&quot;&gt;行锁&lt;/h1&gt;

&lt;p&gt;由存储引擎实现，Innodb 支持，MyISAM 不支持。如果不支持行锁，就只能使用表级锁，也就意味着锁的粒度太大并发度就会降低。这也是为什么推荐使用 Innodb 的重要原因之一。&lt;/p&gt;

&lt;h3 id=&quot;两阶段锁&quot;&gt;两阶段锁&lt;/h3&gt;

&lt;p&gt;之前提到过一个两阶段提交，行锁有一个&lt;strong&gt;两阶段锁&lt;/strong&gt;协议，也被称为 2PL。&lt;/p&gt;

&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;

&lt;p&gt;两阶段指的是分为加锁阶段和解锁阶段，在加锁阶段只能加锁不能解锁，在解锁阶段只能解锁不能加锁。&lt;/p&gt;

&lt;p&gt;单看定义很难理解，换成大白话说就是&lt;strong&gt;行锁在需要的时候才加上，但并不是不需要了就立即释放，而是要事务结束后才会释放。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;为什么需要两阶段锁&quot;&gt;为什么需要两阶段锁？&lt;/h4&gt;

&lt;p&gt;重点就是在事务结束后才会释放所有行锁，而不是用完立即释放。&lt;strong&gt;任何锁的本质就是保证并发操作的正确性，将并行改为串行&lt;/strong&gt;。二阶段锁用来保证并发更新操作的正确性，两个并发的更新操作，必须等其中一个提交后另一个才能继续，否则就&lt;strong&gt;会发生更新被覆盖的情况&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;假设不存在两阶段锁协议，会发生如下情况：&lt;/p&gt;

&lt;p&gt;同时发起2个操作，向同一个账户打200块，账户原余额有100块。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;sessionA 发起打款操作，获取到写锁，用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 更新账户余额为 300&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 完毕，假设不存在两阶段锁，用完立即释放，释放写锁，&lt;strong&gt;此时事务尚未提交&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;sessionB 发起打款操作，获取到写锁，根据一致性视图可见性规则：事务未提交，更新不可见。得到的账户余额仍为100，用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 更新账户余额为 300&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 完毕，立即释放写锁&lt;/li&gt;
  &lt;li&gt;sessionA 提交，账户余额为 300&lt;/li&gt;
  &lt;li&gt;sessionB 提交，账户余额为 300&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以，因为存在两阶段锁协议，在第2步结束后，由于事务尚未提交，写锁仍未释放，则第3步的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 操作必须等待 sessionA 提交后才能继续，此时 sessionA 读到的余额为300，再执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 后更新余额为500，这才是符合逻辑的结果。&lt;/p&gt;

&lt;h4 id=&quot;如何优化&quot;&gt;如何优化？&lt;/h4&gt;

&lt;p&gt;锁虽然保证了并发操作的正确性，但是由并行改为串行降低了并发度。所以另一个问题就是如何最大限度的提高并发度？&lt;/p&gt;

&lt;p&gt;由于行锁是在需要的时候才加上，在事务结束后统一释放。所以针对包含多个更新的事务，可以&lt;strong&gt;调整事务内更新语句的顺序，将会产生行锁竞争的语句尽量往后放，从而让等待行锁的时间最小化&lt;/strong&gt;，以达到提高并发度的目的。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;假如有一个在线订票业务，订票逻辑可以简化为下列步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从账户余额扣掉票钱&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;给系统余额加上票钱&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;记录一条日志&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;假设同时发起2个订票请求，可以看到，在这个事务中，会产生行锁竞争的是第2步(直白说就是会 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 同一行)。按这个顺序的话，系统余额表上的行锁会从第2步开始加上，第3步完成后事务提交时释放。&lt;/p&gt;

&lt;p&gt;调整下顺序，改为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;记录一条日志&lt;/li&gt;
  &lt;li&gt;从账户余额扣掉票钱&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;给系统余额加上票钱&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这时候系统余额表上的行锁持续时间就缩短为1步了，从第3步开始加上，到第3步完成后事务提交时释放。&lt;/p&gt;

&lt;p&gt;虽然在这里看就是少了一小步(一条语句的执行时间)，但如果这个业务请求并发量很大的话，这个优化的效果就会非常明显。&lt;/p&gt;

&lt;h3 id=&quot;死锁&quot;&gt;死锁&lt;/h3&gt;

&lt;h4 id=&quot;为什么会出现死锁&quot;&gt;为什么会出现死锁？&lt;/h4&gt;

&lt;p&gt;简单说就是出现&lt;strong&gt;锁的循环等待&lt;/strong&gt;。示例如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k = k+1 where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k = k+1 where id=2;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k = k+1 where id=2;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k = k+1 where id=1;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;由于事务都尚未提交，行锁还未释放。第4步要获取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=2&lt;/code&gt; 的行锁，需要等待sessionB提交；第5步要获取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=1&lt;/code&gt; 行锁，需要等待sessionA提交，死锁产生了。&lt;/p&gt;

&lt;h4 id=&quot;解决办法&quot;&gt;解决办法&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;等待直到超时，然后退出&lt;/p&gt;

    &lt;p&gt;Innodb中有个参数用于设置这个超时时间：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_lock_wait_timeout&lt;/code&gt;，默认值为 50s。这个默认值对于业务来说是不能接受的，相当于卡顿50s。但是如果设成较小的值，又很有可能造成误伤：如果不是死锁，而就是普通的锁等待，此时并没有循环等待的情况，但是由于超过了阈值而被当成了死锁而提前退出了。所以这种方法一般不采用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主动死锁检测&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_deadlock_detect&lt;/code&gt; 用于控制是否打开主动死锁检测，默认是 ON。&lt;/p&gt;

    &lt;p&gt;这是一种相对较好的方式，但&lt;strong&gt;需要注意的是它的资源消耗有可能会很大&lt;/strong&gt;。对于每个新加入进来的线程，都要先判断会不会由于自己的加入而导致死锁，这是一个时间复杂度为 O($n^2$) 的操作。假设有1000个并发线程同时更新同一行，这个死锁检测就是100万量级的。&lt;/p&gt;

    &lt;p&gt;虽然最终检测的结果是没有死锁，但此期间需要消耗大量的CPU资源。所以当出现CPU消耗接近100%，TPS却很低的话，很有可能就是死锁检测导致的。&lt;/p&gt;

    &lt;p&gt;那如何优化这种&lt;strong&gt;热点行更新问题&lt;/strong&gt;？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;简单粗暴的方法就是如果确认不会出现死锁，直接关闭死锁检测。但这个方法明显危险系数很高，万一还是出现了死锁的话只能依靠超时机制，而如上面所述，超时机制的阈值很难设置。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;拆分热点行&lt;/strong&gt;。将一行拆分为多行，比如一条账户记录可以拆分为10条子账户记录，账户总额就等于10条子账户余额之和，在需要更新账户余额时，随机选择其中一条进行更新。这样就将一行上的死锁检测成本、锁等待个数、冲突概率都降为了原来的1/10。这种方案属于设计层面上的优化，需要结合业务逻辑做详细的设计和测试。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;案例二删除大量数据&quot;&gt;案例二：删除大量数据&lt;/h1&gt;

&lt;p&gt;现需要删除前10000行数据，有以下三种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete from t limit 10000;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在一个连接中循环执行20次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete from t limit 500;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在20个连接中同时执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete from t limit 500;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;哪种方式好一些？&lt;/p&gt;

&lt;p&gt;第一种：执行时间较长，意味着占用锁(MDL读锁、X锁)的时间会比较长；而且大事务在从库上回放的时间也较长，在此期间会导致主从延迟；&lt;/p&gt;

&lt;p&gt;第三种：人为的制造了行锁冲突，而且大概率会重复删除，达不到删除前10000行数据的目的；&lt;/p&gt;

&lt;p&gt;第二种方式较好。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;案例三查询长时间不返回&quot;&gt;案例三：查询长时间不返回&lt;/h1&gt;

&lt;p&gt;主要思路：通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show processlist&lt;/code&gt; 查看当前语句处于什么状态，一般是被锁住了。&lt;/p&gt;

&lt;h3 id=&quot;等mdl锁&quot;&gt;等MDL锁&lt;/h3&gt;

&lt;p&gt;当有其他线程持有MDL写锁时，就会把查询堵住。&lt;/p&gt;

&lt;p&gt;比如以下场景：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;lock table write;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;select * from t where id=1;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show processlist&lt;/code&gt; 表现如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211209033333763.png&quot; alt=&quot;image-20211209033333763&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可看到状态为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Waiting for table metadata lock&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;解决办法很简单，谁持有MDL写锁，就把它 kill 掉。&lt;/p&gt;

&lt;p&gt;但有时候从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show processlist&lt;/code&gt; 中不容易看出，可查询 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys.schema_table_lock_waits&lt;/code&gt;表，前提是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;performance_schema=on&lt;/code&gt;，这个选项在MySQL8中默认开启，相对于不开启大约有 10% 的性能损失。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211209033730549.png&quot; alt=&quot;image-20211209033730549&quot; /&gt;&lt;/p&gt;

&lt;p&gt;或者也可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys.innodb_lock_waits&lt;/code&gt; 查询：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211209100307555.png&quot; alt=&quot;image-20211209100307555&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kill query 4&lt;/code&gt;  和  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kill 4&lt;/code&gt; 的区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kill query 4&lt;/code&gt;  ：表示停止4号线程当前正在执行的语句。有时候这个命令可能没用，因为语句可能已经执行完了，但事务没提交导致锁不能释放。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kill 4&lt;/code&gt; ：直接断开连接，连接断开时会自动释放锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;等行锁&quot;&gt;等行锁&lt;/h3&gt;

&lt;p&gt;这比较普遍：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set c=c+1 where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;select * from t where id=1 lock in share mode;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;由于 sessionA 事务未提交，导致 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=1&lt;/code&gt; 的写锁不能释放，而 sessionB 的查询需要读锁，所以会被堵住。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;next-key-lock&quot;&gt;next-key lock&lt;/h1&gt;

&lt;p&gt;目的：解决幻读问题&lt;/p&gt;

&lt;p&gt;什么是幻读？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/select.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt;&lt;/a&gt; is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;幻读专指新插入的行。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个幻读示例：&lt;/p&gt;

&lt;p&gt;假设存在 person(id,name) 表，含2条数据：(1,”foo”)、(2,”bar”)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;select count(1) from person 查到2条数据&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;insert into person(id,name) values(3,”zoo”) 插入一条数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;commit 提交&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;insert into person(id,name) values(3,”zoo”) 插入一条数据，&lt;strong&gt;报错提示主键重复&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;select * from person where id = 3，又查不到数据，但是又不能insert，就很奇怪&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;解决办法：使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for update&lt;/code&gt; 加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next-key lock&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next-key lock&lt;/code&gt; 定义：行锁 +  间隙锁 ，前开后闭区间&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;To prevent phantoms, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InnoDB&lt;/code&gt; uses an algorithm called next-key locking that combines index-row locking with gap locking. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InnoDB&lt;/code&gt; performs row-level locking in such a way that &lt;strong&gt;when it searches or scans a table index&lt;/strong&gt;, it sets shared or exclusive locks on the index records it encounters. Thus, the row-level locks are actually index-record locks. &lt;strong&gt;In addition, a next-key lock on an index record also affects the “gap” before the index record. That is, a next-key lock is an index-record lock plus a gap lock on the gap &lt;u&gt;preceding the index record&lt;/u&gt;.&lt;/strong&gt; If one session has a shared or exclusive lock on record &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; in an index, another session cannot insert a new index record in the gap immediately before &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; in the index order&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;间隙锁&quot;&gt;间隙锁&lt;/h3&gt;

&lt;p&gt;间隙锁即用来锁住行之间的间隙，换句话说，可以锁住 “&lt;strong&gt;不存在&lt;/strong&gt;” 的行，也就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert&lt;/code&gt; 操作。&lt;/p&gt;

&lt;p&gt;间隙锁之间并不冲突，与间隙锁冲突的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert&lt;/code&gt; 这个操作。两个会话可以同时执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select * from t where c=7 for update&lt;/code&gt;，说明两个会话都获取到了同一个间隙锁，但如果此时有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert&lt;/code&gt; 操作就会被阻塞。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert&lt;/code&gt; 操作并不单指 sql 中的 insert，而是广义上的索引树上的所有插入行为。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;rc-和-rr-在锁问题上的区别&quot;&gt;RC 和 RR 在锁问题上的区别&lt;/h1&gt;

&lt;p&gt;RC可以禁用间隙锁，&lt;strong&gt;RC下只有行锁&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而且RC级别下在语句执行完毕后，就会把“不满足条件”的行锁释放，不需要等到事务提交。RR级别下所有的加锁资源都是在事务提交或回滚时统一释放。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比如表 t(id,c)，id是主键，c 是普通字段。&lt;/p&gt;

&lt;p&gt;将隔离级别设为RC，执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select * from t where c = 5 for update&lt;/code&gt;，由于需要扫描主键索引树，会给所有扫描到的行都加上行锁。但是在这句语句执行完毕后，无需事务提交便会把所有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c!=5&lt;/code&gt; 的行锁都释放，此时其他事务便可对所有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c!=5&lt;/code&gt; 的行进行更新操作。&lt;/p&gt;

&lt;p&gt;同样的实验如果将隔离级别设为RR便会发生阻塞，因为RR级别下所有的锁都是在事务提交时才会释放。&lt;/p&gt;

&lt;p&gt;所以 RC 级别下，锁的范围更小，锁的时间更短，在&lt;strong&gt;业务允许的情况下&lt;/strong&gt;隔离级别设为RC可以提高并发度。&lt;/p&gt;

&lt;p&gt;当设为RC后，Innodb 会强制要求将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_format&lt;/code&gt; 设为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROW&lt;/code&gt;，这是为了保证数据和binlog日志的一致。以&lt;u&gt;下文综合案例中&lt;/u&gt;的表和数据举例：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;br /&gt;select * from t where d=5 for update;&lt;br /&gt;update t set d=100 where d=5;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set d=5 where id=0;&lt;br /&gt;update t set c=5 where id=0;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;commit;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在RC级别下，语句执行完就会释放所有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d!=5&lt;/code&gt; 的行锁，而且没有间隙锁，因此 sessionB 不会阻塞。&lt;/p&gt;

&lt;p&gt;执行完毕后数据变为：(id=0, c=5, d=5)、(id=5, c=5, d=100)。&lt;/p&gt;

&lt;p&gt;如果 binlog_format 为 statement，那么在 binlog 中会产生类似如下日志：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;update t set d=5 where id=0;&lt;/li&gt;
  &lt;li&gt;update t set c=5 where id=0;&lt;/li&gt;
  &lt;li&gt;update t set d=100 where d=5;  #&lt;strong&gt;事务提交时才会写入日志，所以它出现在了最后&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用该日志恢复出来的数据变成了：(id=0, c=5, d=100)、(id=5, c=5, d=100)。可以发现，恢复出来的数据和数据库里的数据不一致，这肯定是不行的。&lt;/p&gt;

&lt;p&gt;改为 row 以后，binlog中的日志类似如下，可使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysqlbinlog --base64-output=decode-rows -vv&lt;/code&gt; 查看：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`test`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`t`&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`test`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`t`&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`test`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`t`&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;###&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可看到日志恢复出来的数据和数据库里的数据是一致的。&lt;/p&gt;

&lt;p&gt;事实上，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;statement 的 binlog&lt;/code&gt; 由于是基于 sql 语句的日志，在保持数据和日志一致性上会有很多问题，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;now()&lt;/code&gt; 函数。因此推荐使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROW 的binlog&lt;/code&gt;，这也是 MySQL8 的默认配置。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;综合案例加锁规则&quot;&gt;综合案例：加锁规则&lt;/h1&gt;

&lt;p&gt;以下规则适用于 5.x 系列 ≤ 5.7.24， 8.x系列 ≤ 8.0.13。其他版本需实践验证，可能会有微调。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;且都是在可重复读默认级别下&lt;/strong&gt;，这个前提非常重要，其他级别如读提交有不同的处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2个原则，2个优化，1个bug&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;原则一：加锁的基本单位是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next-key lock&lt;/code&gt;，前开后闭区间&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;原则二：查找过程中访问到的才会加锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;优化一：&lt;strong&gt;唯一&lt;/strong&gt;索引&lt;strong&gt;等值&lt;/strong&gt;查询， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next-key lock&lt;/code&gt; 会退化成行锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;优化二：&lt;strong&gt;索引等值&lt;/strong&gt;查询，向右遍历且最后一个值不满足等值条件时， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next-key lock&lt;/code&gt; 退化成间隙锁&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在 8.0.26 版本中，唯一索引的范围查询，向右遍历且最后一个值不满足条件时， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next-key lock&lt;/code&gt; 也会退化成间隙锁。&lt;/p&gt;

      &lt;p&gt;具体从哪个版本开始修复的，尚未确定。见示例三。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个bug：&lt;strong&gt;唯一&lt;/strong&gt;索引上的范围查询会访问到第一个不满足条件的值为止&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在 8.0.26 版本中已修复，具体从哪个版本开始修复的，尚未确定。见示例五。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下示例基于：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`t`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`c`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`d`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`c`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`c`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;示例一等值查询间隙锁&quot;&gt;示例一：等值查询间隙锁&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionC&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;br /&gt;update t set d=d+1 where id=7;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;insert into t values(8,8,8)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set d=d+1 where id=10;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;根据原则二：访问到的都加锁。id 是主键索引，能快速定位到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=5&lt;/code&gt; 这条记录，向右遍历下一条记录发现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=10≠7&lt;/code&gt;，遍历结束；&lt;/li&gt;
  &lt;li&gt;根据原则一：加锁的基本单位是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next-key lock&lt;/code&gt;。所以 sessionA 的加锁范围是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=8&lt;/code&gt; 位于加锁范围内，所以 sessionB 会阻塞；&lt;/li&gt;
  &lt;li&gt;根据优化二：索引等值查询，向右遍历且最后一个值不满足等值条件时(这里就是10)， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next-key lock&lt;/code&gt; 退化成间隙锁。所以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt; 会退化成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10)&lt;/code&gt;，因此 sessionC 不会被阻塞。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里优化一不适用，因为不存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=7&lt;/code&gt; 这行记录，因此没有办法退化成行锁。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;示例二非唯一索引等值锁&quot;&gt;示例二：非唯一索引等值锁&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionC&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;br /&gt;select id from t where c=5 lock in share mode;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set d=d+1 where id=5;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;insert into t values(7,7,7)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;根据原则一得出 sessionA 的加锁范围是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0,5]&lt;/code&gt; (行锁 + 行之前的间隙锁);&lt;/li&gt;
  &lt;li&gt;根据优化二向右遍历直到 c=10停止，先是 next-key lock &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt;，然后退化成间隙锁 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10)&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;所以 sessionA 的加锁范围是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0,5]&lt;/code&gt;  加上  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10)&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;因此 sessionC 会阻塞；&lt;/li&gt;
  &lt;li&gt;那为什么 sessionB 不会阻塞？按理说 sessionB 需要 id=5 这一行的行锁，同样应该被阻塞才对。 原因在于 sessionA 的查询用的是&lt;strong&gt;覆盖索引&lt;/strong&gt;，不需要回表。而根据原则二：访问到的才加锁。所以&lt;strong&gt;锁只会加在 c 索引树上&lt;/strong&gt;，而 sessionB 的条件是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=5&lt;/code&gt;，走的是主键索引，因此不会被阻塞。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但如果 sessionA 换成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for update&lt;/code&gt;  就不一样了， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for update&lt;/code&gt;  会同时给主键索引上满足条件的行上锁，而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock in share mode&lt;/code&gt; 如果有覆盖索引的情况下只会给覆盖索引上锁。&lt;/p&gt;

&lt;p&gt;所以，如果使用的是  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock in share mode&lt;/code&gt; 加锁的话，为了避免数据被更新，需要绕过覆盖索引的优化：在查询字段中加入索引中不存在的字段，让查询回表，如改成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select d from t where c=5 lock in share mode;&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;示例三主键索引范围锁&quot;&gt;示例三：主键索引范围锁&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionC&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;br /&gt;select * from t where id&amp;gt;=10 and id&amp;lt;11 for update;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;insert into t values(8,8,8);&lt;br /&gt;insert into t values(13,13,13);&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set d=d+1 where id=15;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;sessionA 的查询在逻辑上和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select * from t where id=10&lt;/code&gt; 是一致的，但是加锁范围却有很大区别。&lt;/p&gt;

&lt;p&gt;分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;初步分析，sessionA 的加锁范围是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt; +  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(10,15]&lt;/code&gt;;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&amp;gt;=10&lt;/code&gt; 是等值查询，会先定位到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=10&lt;/code&gt; 这行记录，会先加一个 next-key lock  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt; ；&lt;/p&gt;

      &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&amp;lt;11&lt;/code&gt; 是范围查询，会向右遍历到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=15&lt;/code&gt; 停止，发现不满足条件，于是再加一个 next-key lock (10,15]。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据优化一：唯一索引等值查询会退化成行锁。所以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt; 会退化成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=10 的行锁&lt;/code&gt;；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;综上，sessionA 的加锁范围是  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=10 的行锁&lt;/code&gt; +   &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(10,15]&lt;/code&gt;；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;因此，sessionB 的第一条语句可正常执行，第二条语句会被阻塞；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sessionC 的语句也会被阻塞。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;以上示例是在8.x系列 ≤ 8.0.13中验证的。&lt;/p&gt;

      &lt;p&gt;&lt;strong&gt;在 8.0.26 中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(10,15]&lt;/code&gt; 退化成了间隙锁 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(10,15)&lt;/code&gt;，这条语句不会被阻塞。&lt;/strong&gt;&lt;/p&gt;

      &lt;p&gt;&lt;strong&gt;估计是调整了优化二：不光是普通索引的等值查询，&lt;u&gt;唯一索引的范围查询&lt;/u&gt;也是一样，向右遍历到不满足条件的第一个值时， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next-key lock&lt;/code&gt; 也会退化成间隙锁。具体是哪个版本调整的，尚未确定。见示例四。&lt;/strong&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;示例四非唯一索引范围锁&quot;&gt;示例四：非唯一索引范围锁&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionC&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;br /&gt;select * from t where c&amp;gt;=10 and c&amp;lt;11 for update;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;insert into t values(8,8,8);&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set d=d+1 where c=15;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;将示例三中 where 字段由 id 改为 c，分析如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;同示例三，初步分析，sessionA 加锁范围是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(10,15]&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;区别在于优化一不适用了，因为不是唯一索引，所以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt; 不能退化成行锁；&lt;/li&gt;
  &lt;li&gt;所以 sessionB 会被阻塞；&lt;/li&gt;
  &lt;li&gt;由于 c 是普通索引，所以 c 上的范围查询不满足优化二，不会退化成间隙锁。sessionC 会被锁住。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;示例五唯一索引范围锁bug&quot;&gt;示例五：唯一索引范围锁bug&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionC&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;br /&gt;select * from t where id&amp;gt;10 and id&amp;lt;=15 for update;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set d=d+1 where id=20;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;insert into t values(16,16,16);&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;基于8.x系列 ≤ 8.0.13。在 8.0.26 版本中已修复，具体从哪个版本开始修复的，尚未确定。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;初步分析，sessionA 加锁范围是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(10,15]&lt;/code&gt;(直接就定位到了 id=15 这一行)；&lt;/li&gt;
  &lt;li&gt;id 是主键索引，按理说扫描到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=15&lt;/code&gt; 时就可以结束了，因为 id 是唯一的且在主键索引中是递增的，再往后遍历都是 &amp;gt;15 的，不可能满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&amp;lt;=15&lt;/code&gt;。但事实上还会继续往后扫描到第一个不满足条件的值为止，即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=20&lt;/code&gt;，所以加锁范围还会加上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(15,20]&lt;/code&gt;。结果就是导致 sessionB 和 sessionC 都会被锁住。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;示例六非唯一索引上存在等值&quot;&gt;示例六：非唯一索引上存在“等值”&lt;/h3&gt;

&lt;p&gt;先插入一条记录：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后执行以下序列：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionC&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;br /&gt;delete from t where c=10;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;insert into t values(12,12,12);&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set d=d+1 where c=15;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;delete 和 for update 加锁的逻辑是类似的。sessionA 的加锁范围是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(10,15)&lt;/code&gt;；&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;，现在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c=10&lt;/code&gt; 的记录在 c 索引树上有两条：(c=10,id=10) 和 (c=10,id=30) ，&lt;strong&gt;在这两条记录中间还有一个间隙锁&lt;/strong&gt;。这个间隙锁只存在于 c 索引树上，主键索引上只有行锁，见第3点。&lt;/p&gt;

      &lt;p&gt;由于这个间隙锁只在 c 索引树上，所以它实际上没有任何作用，因为在两个10之间不存在任何int值，知道这个间隙锁的存在就行。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sessionB 会阻塞，sessionC 正常执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;上面讲过 &lt;strong&gt;for update 会同时给主键索引上满足条件的行上锁，这里也是一样&lt;/strong&gt;，因此在主键索引树还有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=10&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=30&lt;/code&gt; 两个行锁。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;示例七limit加锁&quot;&gt;示例七：limit加锁&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;br /&gt;delete from t where c=10 limit 2;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;insert into t values(12,12,12);&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;示例六的对照示例，按照示例六的分析加锁范围为  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(10,15)&lt;/code&gt; ，但是由于加了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;limit 2&lt;/code&gt;，因此在扫描到两行记录，(c=10,id=10) 和 (c=10,id=30) 后便结束了，因此加锁范围变为了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt;，所以 sessionB 不会被阻塞。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个示例也说明了删除数据时尽量使用limit，不仅可以控制删除的条数更安全，而且还可以减小锁的范围。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;示例八降序排序加锁&quot;&gt;示例八：降序排序加锁&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;br /&gt;select * from t where c&amp;gt;=15 and c&amp;lt;=20 order by c desc lock in share mode;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;insert into t values(6,6,6);&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set d=d+1 where id=10;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set c=c+1 where id=10;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;降序排序，整体从右往左扫描。首先定位到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c=20&lt;/code&gt;，加上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(15,20]&lt;/code&gt; 的 next-key lock；由于是普通索引，继续向右扫描到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c=25&lt;/code&gt;，不满足条件 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&amp;lt;=20&lt;/code&gt; 停止，于是再加上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(20,25]&lt;/code&gt; 的 next-key lock，然后退化成间隙锁 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(20,26)&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;向左扫描，直到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c=10&lt;/code&gt; 不满足条件 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&amp;gt;=15&lt;/code&gt; 停止，于是加上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt; 的 next-key lock;&lt;/li&gt;
  &lt;li&gt;综上，sessionA &lt;strong&gt;在 c 索引树上&lt;/strong&gt;的加锁范围是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,25)&lt;/code&gt;；因此&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert into t values(6,6,6)&lt;/code&gt; 阻塞；&lt;/li&gt;
  &lt;li&gt;由于是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select *&lt;/code&gt;，需要回表。虽然在索引c上的扫描范围是 (5,25)，但是满足条件的行是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c=15、c=20&lt;/code&gt;，回表的也是这两行。因此，会在主键索引上加上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=15、id=20&lt;/code&gt; 两个行锁；&lt;/li&gt;
  &lt;li&gt;因此 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update t set d=d+1 where id=10&lt;/code&gt; 不会阻塞；但如果把条件换成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c=10&lt;/code&gt; 就会阻塞，由此可见，&lt;strong&gt;锁是加在索引上的&lt;/strong&gt;，c索引上有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c=10&lt;/code&gt; 的行锁， 主键索引上没有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=10&lt;/code&gt; 的行锁；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update t set c=c+1 where id=10&lt;/code&gt; 与上一句不同的是：上一句只需更新主键索引树，这一句需要同时更新主键索引和索引c两棵索引树。 更新主键索引不会被锁住，锁住是因为需要更新 c 索引树(需要更新 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c=10&lt;/code&gt; 的行)。&lt;/li&gt;
  &lt;li&gt;如果去掉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;desc&lt;/code&gt;，那么加锁范围就变成了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(10,25]&lt;/code&gt;，可以实验验证一下。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;示例九死锁&quot;&gt;示例九：死锁&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;br /&gt;select * from t where c=10 lock in share mode;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set d=d+1 where c=10;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;insert into t values(8,8,8);&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Error 40001 1213  Deadlock found when trying to get lock; try restarting transaction&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sessionA 的第一条语句的加锁范围是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(10,15)&lt;/code&gt;；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;毫无疑问sessionB 会被阻塞，但按理说 sessionB 此时应该还没有获取到任何锁，那么 sessionA 的第二条语句应该能执行才对，但是立马报了一个死锁错误？&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;实际上，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next-key lock&lt;/code&gt; 的加锁分为两个阶段：先加间隙锁，再加行锁。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;sessionB 需要申请 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10]&lt;/code&gt;  的next-key lock，&lt;strong&gt;会先加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10)&lt;/code&gt; 的间隙锁，&lt;u&gt;加锁成功&lt;/u&gt;；然后再加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c=10&lt;/code&gt; 的行锁，&lt;u&gt;这时候才进入了锁等待&lt;/u&gt;。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;然后 sessionA 第二条语句被 sessionB &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5,10)&lt;/code&gt;  的间隙锁锁住()，而 sessionB 又在等待 sessionA 释放 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c=10&lt;/code&gt; 的行锁，于是出现了死锁。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;所以，在分析加锁规则的时候可以用 next-key lock 来分析，但是要知道具体执行的时候是先加间隙锁，再加行锁。&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 18 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/10/18/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)-MySQL%E9%94%81/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/10/18/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)-MySQL%E9%94%81/</guid>
        
        <category>mysql</category>
        
        <category>锁</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(七)：MySQL索引</title>
        <description>&lt;h1 id=&quot;索引的常见实现方式有哪些&quot;&gt;索引的常见实现方式有哪些？&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;哈希表：O(1) 的时间复杂度，速度最快，但&lt;strong&gt;缺点是只适用于等值查询&lt;/strong&gt;。因为key是无序的，所以区间查询时只能全部遍历一遍。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有序数组：O(logn)的时间复杂度，利用二分法。可用于等值查询和区间查询，&lt;strong&gt;但插入删除时间复杂度较高&lt;/strong&gt;，因为需要移动插入点后面的所有元素。所以有序数组&lt;strong&gt;比较适合静态存储引擎，即基本不会变的数据&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;搜索树：常用实现是B+树。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;为什么采用b树而不是常见的二叉树&quot;&gt;为什么采用B+树而不是常见的二叉树?&lt;/h1&gt;

&lt;p&gt;二叉树即每个节点只有左右2个子节点，所以显而易见的问题就是当节点变多时树的高度会很高。比如需要存储100万条数据，就需要20层（n层二叉树的节点数为 $2^n-1$，20层二叉树的节点总数为1048576）。因为一个节点就是一个数据页，那么一次查询很可能就需要进行20次随机IO（大概率会触发随机IO），在传统机械硬盘时代，一次随机IO大约10ms，那么单一次查询可能就需要200ms，这个查询是很慢的。&lt;/p&gt;

&lt;p&gt;所以解决办法就是增加树的子节点数，由二叉变为N叉。&lt;/p&gt;

&lt;p&gt;B+树就是一颗N叉树。一个节点就是一页，页是Innodb磁盘IO的基本单位，一页在Innodb中默认是16k，&lt;strong&gt;假如索引字段为整数类型占4个字节，每个key还有一个指向下一层节点的指针固定占6字节，再加上一些辅助字节总共差不多占13字节左右（非叶子节点）。16k/13=1260，那么一个节点就可以差不多有1200个分叉，一颗树高为4的B+树，就可以存 $1200^3≈17亿$ 个值&lt;/strong&gt;。因为根节点总是在内存中，第二层大概率也在内存中，这时17亿数据量的单次查询理论上只需要进行2-3次磁盘IO，速度大大提高了。&lt;/p&gt;

&lt;p&gt;顺便说一下 Innodb 中B+树 (不是严格定义下的 B+树，做了一些优化)的特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;N叉树，即每个节点可以有多个key，每个key对应一个分叉&lt;/li&gt;
  &lt;li&gt;内部节点不存储数据，只有指针，只在叶子节点存储数据&lt;/li&gt;
  &lt;li&gt;每一层页与页之间构成一个双向链表&lt;/li&gt;
  &lt;li&gt;页内 records 之间构成一个单向链表&lt;/li&gt;
  &lt;li&gt;叶子节点为第0层，从下往上递增，root为最大层数&lt;/li&gt;
  &lt;li&gt;一个节点就是一个page&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;innodb中的页是什么&quot;&gt;Innodb中的页是什么？&lt;/h1&gt;

&lt;p&gt;先从表空间说起。&lt;/p&gt;

&lt;h3 id=&quot;innodb表空间&quot;&gt;Innodb表空间&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考：&lt;a href=&quot;https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/&quot;&gt;The basics of InnoDB space file layout&lt;/a&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;Innodb的数据存储模型被称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;space&lt;/code&gt;，即“表空间”。表空间是一个逻辑概念，有一个32位的space ID，实际上可能由多个物理文件组成（如ibdata1、ibdata2）。表空间分为系统表空间（system space：ibdata1、ibdata2，space ID 为0）和表对应的表空间(per-table space：ibd文件)。ibd文件实际上是一个功能齐全的space，可以包含多张表，但在MySQL实现中一个ibd只对应一张表。&lt;/p&gt;

&lt;p&gt;每个space会被划分为多个page，一个page默认16k。page也有一个32位的page number（页号），表示在space内的偏移量（offset），比如page 0 对应 offset 为0，page 1 对应 offset 为16384。注意一个space可能包含多个文件，所以这个offset不一定是文件内的，而是整个space中的。Innodb单表空间最大为64TB，是因为 $2^{32} * 16k$。&lt;/p&gt;

&lt;h3 id=&quot;表空间space-file文件结构&quot;&gt;表空间(space file)文件结构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211112125701387.png&quot; alt=&quot;image-20211112125701387&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;系统表空间system-space文件结构&quot;&gt;系统表空间(system space)文件结构&lt;/h3&gt;

&lt;p&gt;系统表空间(system space)的 space ID 为 0 。它采用了一些固定页号的页来存储一些关键信息。结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211112130023998.png&quot; alt=&quot;image-20211112130023998&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;单表空间per-table-space-file文件结构&quot;&gt;单表空间(per-table space file)文件结构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211112130153515.png&quot; alt=&quot;image-20211112130153515&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Page3为聚簇索引(主键索引)的root page，Page4为第一个二级索引的root page，如果有多级索引的话以此类推。&lt;/p&gt;

&lt;h3 id=&quot;页的基本结构&quot;&gt;页的基本结构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211112105252435.png&quot; alt=&quot;image-20211112105252435&quot; /&gt;&lt;/p&gt;

&lt;p&gt;页包含一个38字节的头部（FIL为File的缩写）和一个8字节的尾部，中间的内容取决于不同的page type，可用大小为 16k-38-8=16338。&lt;/p&gt;

&lt;p&gt;FIL Header 和 Trailer 结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211112105757234.png&quot; alt=&quot;image-20211112105757234&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，头部包含了&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Offset(Page Number)&lt;/li&gt;
  &lt;li&gt;Page Type&lt;/li&gt;
  &lt;li&gt;Space ID&lt;/li&gt;
  &lt;li&gt;指向前一页和后一页的指针，构成一个双向链表（树的同一层中）&lt;/li&gt;
  &lt;li&gt;最后一次改动页的LSN(Log Sequence Number，日志逻辑序列号)&lt;/li&gt;
  &lt;li&gt;当前系统中（所有space）最大的LSN&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;innodb索引&quot;&gt;Innodb索引&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;详见 &lt;a href=&quot;https://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/&quot;&gt;The physical structure of InnoDB index pages&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;一切皆索引&quot;&gt;一切皆索引&lt;/h3&gt;

&lt;p&gt;在Innodb中一切皆索引，意思是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每张表都有一个主键。如果没有手动指定，会使用第一个 not null 的 unique key。如果仍然没有，会自动分配一个6字节的隐藏 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Row ID&lt;/code&gt;作为主键。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主键索引树(聚簇索引)叶子节点key是主键值，value是是整行数据。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二级索引key是索引列的值，value是对应的主键值。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一张表有几个索引，就有几棵B+树。且至少有一棵主键B+树，数据存储在主键索引树上。查询不走索引其实是遍历主键索引树。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B+树中一个节点为一页。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;索引结构&quot;&gt;索引结构&lt;/h3&gt;

&lt;p&gt;因为一个索引就是一棵B+树，B+树中一个节点对应一页，所以索引页的基本结构和上面讲到的页的基本结构相同，都包含一个FIL Header和FIL Trailer，不同的是主体部分，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211112140640173.png&quot; alt=&quot;image-20211112140640173&quot; /&gt;&lt;/p&gt;

&lt;p&gt;重点关注其中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User Records&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Page Directory&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;User Records 是实际存储数据的地方：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非叶子节点：除key外，还存储指向下一层子节点的指针&lt;/li&gt;
  &lt;li&gt;叶子节点：假设为主键索引树，存储的就是整行数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个page中的所有 User Records 组成了一个单链表，头是一个叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;infimum&lt;/code&gt; 的 system record(存储了当前页中最小的key)，尾是一个叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supremum&lt;/code&gt; 的 system record(存储了当前页中最大的key)。&lt;/p&gt;

&lt;p&gt;Index Header 结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211112142023840.png&quot; alt=&quot;image-20211112142023840&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Number of Records&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Page Level(叶子节点所在层为第0层，从下往上递增，root节点所在层为最大层)&lt;/code&gt; 等等。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;联合主键&quot;&gt;联合主键&lt;/h3&gt;

&lt;p&gt;假设存在以下表记录&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;a&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;b&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;c&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;d&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;存在一个联合主键 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt;，三个索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c(c)&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ca(c,a)&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cb(c,b)&lt;/code&gt;，分析这三个索引是否有冗余？&lt;/p&gt;

&lt;p&gt;索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ca&lt;/code&gt; 即先对 c 排序，再对 a 排序，因为key已经包含了a，所以value只需要存储 b，ca相同时，b升序。记录如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;c(key的部分)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;a(key的部分)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;b(value存的值)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;再看索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;。key先对 c 排序，value 存的是联合主键 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt;，即先对 a 排序，再对 b 排序，结果和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ca&lt;/code&gt; 是一样的。所以索引&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ca&lt;/code&gt; 是多余的。&lt;/p&gt;

&lt;p&gt;索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cb&lt;/code&gt; 先对 c 排序，再对 b 排序，再对 a 排序，可用于基于c、b 的查询，需要保留。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;实践一下&quot;&gt;实践一下&lt;/h3&gt;

&lt;p&gt;可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_space&lt;/code&gt; 命令直接分析 ibd 文件，获取文件中存储的page、records等信息。(目前还不支持MySQL8.0)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;详见：&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://github.com/jeremycole/innodb_ruby&quot;&gt;innodb_ruby&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/&quot;&gt;B+Tree index structures in InnoDB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;基于主键索引和普通索引的查询有什么区别&quot;&gt;基于主键索引和普通索引的查询有什么区别&lt;/h1&gt;

&lt;p&gt;主键索引树叶子节点直接存储行数据，所以主键索引查询只需要扫描主键索引树即可。&lt;/p&gt;

&lt;p&gt;而普通索引树叶子节点存储的是主键值，所以需要先扫描普通索引树拿到主键值，再回到主键索引树获取行数据，相较于主键索引查询多扫描了一棵索引树，这个过程称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;回表&lt;/code&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;一些索引设计原则&quot;&gt;一些索引设计原则&lt;/h1&gt;

&lt;p&gt;假设存在表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u(id,id_card,name,age,gender)&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 是主键，另有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_card&lt;/code&gt; 索引&lt;/p&gt;

&lt;h3 id=&quot;覆盖索引&quot;&gt;覆盖索引&lt;/h3&gt;

&lt;p&gt;即索引key中包含了要查找的字段。&lt;/p&gt;

&lt;p&gt;假如现需要根据身份证查询数据，可直接走 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_card&lt;/code&gt; 索引。&lt;/p&gt;

&lt;p&gt;现又有另一个&lt;strong&gt;高频&lt;/strong&gt;需求，根据身份证查询姓名。目前走的仍然是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_card&lt;/code&gt; 索引，需要先在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_card&lt;/code&gt; 索引树上找到对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_card&lt;/code&gt;，然后再回到主索引树上根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;获取到姓名，也就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;回表&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那有没有什么办法可以优化呢？&lt;/p&gt;

&lt;p&gt;方法就是建立一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(id_card,name)&lt;/code&gt; 的联合索引。这棵索引树节点的key包含了两个字段：id_card 和 name，这样的话直接在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(id_card,name)&lt;/code&gt; 索引上搜索便可直接得到 name，而不需要回表查整行记录，减少了语句的执行时间。与此同时，根据最左匹配原则，原先根据身份证查询数据的请求也可以用到这个索引，所以现在可以删除&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_card&lt;/code&gt; 这个索引了。&lt;/p&gt;

&lt;p&gt;这就是覆盖索引，即索引key中包含了要查找的字段。可使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;explain&lt;/code&gt; 查看是否使用了覆盖索引，&lt;strong&gt;如果在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;explain&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extra&lt;/code&gt; 列中出现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Using index&lt;/code&gt;，说明当前查询使用了覆盖索引&lt;/strong&gt;，即不需要回表查询。&lt;/p&gt;

&lt;p&gt;当然，索引是有代价的。因为每新建一个索引就相当于新建一棵索引树，虽然可以提高查询速度，但增删改就需要多维护一棵索引树。所以需要权衡使用，任何索引都是这样，数据量小的话就没有什么必要，没有太大区别。&lt;/p&gt;

&lt;h3 id=&quot;最左匹配原则&quot;&gt;最左匹配原则&lt;/h3&gt;

&lt;p&gt;假设现在又有一个&lt;strong&gt;低频&lt;/strong&gt;需求：根据身份证查询地址，那么有必要再建立一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(id_card,address)&lt;/code&gt;的联合索引吗？&lt;/p&gt;

&lt;p&gt;答案是不需要。因为这是一个低频请求，意味着请求的次数不会太多，上一节的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(id_card,name)&lt;/code&gt;索引就够用了。可先通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(id_card,name)&lt;/code&gt; 这个索引定位到相应的 id_card，获取到主键后再回表查询。原理很简单，因为联合索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt;是先根据 a 排序再根据  b 排序，所以对于 a 的检索可以用到这个B+树。&lt;/p&gt;

&lt;p&gt;所以最左匹配原则的定义就是只要索引满足最左前缀，便可利用该索引来加速检索。&lt;strong&gt;这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左N个字符。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果既有a,b的联合查询，又有基于a、b各自的查询呢？&lt;/p&gt;

&lt;p&gt;这时考虑的原则就是&lt;strong&gt;空间&lt;/strong&gt;了。如果b字段比a字段大，那么就应该建立一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(b,a)&lt;/code&gt;的联合索引和一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 的单独索引。这两个索引可以同时满足 a,b的联合查询和基于a、b各自的查询。&lt;/p&gt;

&lt;p&gt;除此之外，&lt;strong&gt;最左匹配原则当遇到范围匹配时就会失效&lt;/strong&gt;。比如有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt;的联合索引， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a=1 and b=2&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b=1 and a=2&lt;/code&gt; 都可以用到索引，顺序无所谓，优化器会调整 where 条件 and 的顺序。但是当遇到类似 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a &amp;gt;1 and b=2&lt;/code&gt; 时，就只有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 能用到该索引，会先快速定位到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&amp;gt;1&lt;/code&gt; 的记录，此时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 是无序的 (在 a&amp;gt;1 的整个范围中 b 是无序的)，只能遍历判断 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 是否满足。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;也有些特例，当满足最左匹配原则可以使用联合索引&lt;strong&gt;却需要回表&lt;/strong&gt;时，优化器可能会认为扫描联合索引再加上回表的代价高于直接扫描主键索引树，这时&lt;strong&gt;可能&lt;/strong&gt;(不一定)会选择不走联合索引，而是直接全表扫描。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果 sql 为&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;该怎么建立索引？&lt;/p&gt;

    &lt;p&gt;答：第一反应是直接建立 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b,c)&lt;/code&gt; 的联合索引，但是这里要注意&lt;strong&gt;区分度&lt;/strong&gt;，区分度高的字段放在联合索引前面 (可从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show index from a&lt;/code&gt; 中观察  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cardinality&lt;/code&gt; 得知)。区分度越高，检索效率越高，因为能过滤掉的记录越多。像性别、状态这种区分度很低的字段，放到后面。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果 sql 为&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;该怎么建立索引？&lt;/p&gt;

    &lt;p&gt;答：因为是范围查询，如果建立 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt; 的索引，就只有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 能用上索引。&lt;/p&gt;

    &lt;p&gt;​	    所以应该建立 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(b,a)&lt;/code&gt; 的索引，优化器会调整条件的顺序，然后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 就能用上索引，在此基础上，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&amp;gt;1&lt;/code&gt; 也能用上。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果 sql 为&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`table`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;该怎么建立索引？&lt;/p&gt;

    &lt;p&gt;答：首先肯定要以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 开头，所以有两种选择：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(b,a,c)&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(b,c,a)&lt;/code&gt;，至于具体选择哪个，就看&lt;strong&gt;区分度&lt;/strong&gt;和&lt;strong&gt;字段长度&lt;/strong&gt;了。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果 sql 为&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`table`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;该怎么建立索引？&lt;/p&gt;

    &lt;p&gt;答：建立 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt; 联合索引，当 a=1 时，b 相对有序，可以避免再次排序。&lt;/p&gt;

    &lt;p&gt;​		那如果是&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`table`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;​		因为此时是范围查询， a&amp;gt;1 时 b 是无序的，可以建立一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt; 的联合索引，但只有 a 能用上这个索引。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果 sql 为&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-sq&quot;&gt;SELECT * FROM `table` WHERE a IN (1,2,3) and b &amp;gt; 1; 
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;该怎么建立索引？&lt;/p&gt;

    &lt;p&gt;答：还是建立  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt; 的联合索引，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN 查询&lt;/code&gt; 可视为等值查询，相当于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a=1 or a=2 or a=3&lt;/code&gt;，所以还是一样的思路。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;索引下推&quot;&gt;索引下推&lt;/h3&gt;

&lt;p&gt;严格说索引下推并不是一个索引设计原则，它是一个索引查找的内部优化。&lt;/p&gt;

&lt;p&gt;前提：因为范围查询不能使用联合索引，只能使用最左前缀。&lt;/p&gt;

&lt;p&gt;以下面的 sql 举例：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tuser&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;张%&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_male&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;假设以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;张&lt;/code&gt; 开头的记录有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(张三，10)，(张三，10)，(张三，20)，(张六，30)&lt;/code&gt;，有一个联合索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(name,age)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在 MySQL5.6 之前，存储引擎提供的接口对于这种情况只允许传入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;最左前缀&lt;/code&gt;一个参数，即只能传入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name &lt;/code&gt; 这个字段，所以需要回表4次用于判断 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;age&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_male&lt;/code&gt; 是否满足条件。&lt;/p&gt;

&lt;p&gt;在 MySQL5.6之后，接口可以传入包含最左前缀的整个联合索引，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name,age&lt;/code&gt;字段。这样的话可直接在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(name,age)&lt;/code&gt; 索引树上就对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;age&lt;/code&gt; 进行判断，提前过滤掉不满足条件的记录，最后只需要回表2次。&lt;/p&gt;

&lt;p&gt;当 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;explain 的 extra&lt;/code&gt; 字段中显示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Using index condition&lt;/code&gt; 时则表示本次查询使用到了索引下推。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;一些不能走索引的反面示例&quot;&gt;一些不能走索引的反面示例&lt;/h3&gt;

&lt;p&gt;以下示例用到的表结构如下：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`tradelog`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`tradeid`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`operator`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`t_modified`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;datetime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`tradeid`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`tradeid`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`t_modified`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`t_modified`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CHARSET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8mb4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`trade_detail`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`tradeid`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`trade_step`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*操作步骤*/&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`step_info`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*步骤信息*/&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`tradeid`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`tradeid`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CHARSET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaaa&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaab&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaac&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaaa&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;add&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaaa&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;update&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaaa&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;commit&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaab&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;add&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaab&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;update&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaab&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;update again&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaab&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;commit&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaac&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;add&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaac&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;update&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaac&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;update again&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;aaaaaaac&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;commit&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;索引字段上用了函数&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;会破坏索引的有序性，因此优化器会决定放弃&lt;strong&gt;走树搜索功能&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;month&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t_modified&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t_modified&lt;/code&gt; 上虽然有索引，但由于用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;month函数&lt;/code&gt;，破坏了索引的有序性，导致没办法快速定位。&lt;/p&gt;

    &lt;p&gt;注意，&lt;strong&gt;只是不使用树搜索功能，并不是放弃使用这个索引。&lt;/strong&gt;比如这个例子，虽然放弃了树搜索快速定位，但是对比主键索引树和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t_modified索引树&lt;/code&gt;后，发现后者更小，优化器最终还是会选择遍历 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t_modified索引树&lt;/code&gt;，也即是全索引扫描。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;explain&lt;/code&gt;如下：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/img/image-20211208221822466.png&quot; alt=&quot;image-20211208221822466&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt; 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t_modified&lt;/code&gt;，说明用到了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t_modified&lt;/code&gt; 索引。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rows&lt;/code&gt; 为 100335(测试数据有十万条)，说明是全索引扫描。&lt;/p&gt;

    &lt;p&gt;这个例子要使用快速定位的话，就得把索引上的函数去了:&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t_modified&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;2016-7-1&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t_modified&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;2016-8-1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;or&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t_modified&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;2017-7-1&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t_modified&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;2017-8-1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;or&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t_modified&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;2018-7-1&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t_modified&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;2018-8-1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;还有一些例子，我们可能会理所应当的以为优化器会优化，但是并没有，它还是一视同仁：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;虽然 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id+1&lt;/code&gt; 并不会改变索引的有序性，但优化器并不会重写这类语句，一视同仁，必须得改成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where id = 10000-1&lt;/code&gt; 才行。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;隐式类型转换&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;比如这条sql：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;110717&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;explain&lt;/code&gt; 显示走的是全表扫描。原因是因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tradeid&lt;/code&gt; 是 varchar 类型，值是 int 类型，明显会需要一个类型转换。&lt;/p&gt;

    &lt;p&gt;在MySQL中，&lt;strong&gt;当字符串和数字做比较的时候，是由字符串转为数字&lt;/strong&gt;。如果记不住这个规则，可用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select &apos;10&apos; &amp;gt; 9&lt;/code&gt; 验证一下：结果为1，表示字符串转为了数字。&lt;/p&gt;

    &lt;p&gt;所以，上面的sql其实相当于：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;CAST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tradid&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;110717&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;那原因就很明显了，同样是因为索引列上用到了函数，导致不能快速定位。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;隐式字符编码转换&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;比如这句sql：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/img/image-20211208224214325.png&quot; alt=&quot;image-20211208224214325&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt; 只扫描了一行，表示用了主键索引快速定位，快速定位到了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=2&lt;/code&gt; 这一行。&lt;/p&gt;

    &lt;p&gt;表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 走了全表扫描，且没用上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tradeid&lt;/code&gt; 索引。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key=NUll&lt;/code&gt; 是表示走的主键索引遍历。&lt;/p&gt;

    &lt;p&gt;简单拆解一下这句sql的执行步骤：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;从表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt; 中找到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=2&lt;/code&gt; 这一行数据，从中取出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tradeid&lt;/code&gt;；&lt;/li&gt;
      &lt;li&gt;从表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 中找到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tradeid=上一步查询到的值&lt;/code&gt;的数据。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;所以第2步就是：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;上一步查询到的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;那为什么用不上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tradeid&lt;/code&gt; 索引呢？&lt;/p&gt;

    &lt;p&gt;细心点可发现两个表的字符编码不同，表&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt;，表&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utf8&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utf8&lt;/code&gt; 的超集，类型转换的时候都是子集转超集，所以上面的sql相当于：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CONVERT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;traideid&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;USING&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf8mb4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;上一步查询到的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;所以，原因还是一样，索引字段上加了函数操作导致不能快速定位。&lt;/p&gt;

    &lt;p&gt;作为对比验证，下面这句sql就能都用到索引快速定位：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;还是和上面一样的分析步骤，只不过这次的连接顺序倒了过来。先找到表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=4&lt;/code&gt; 这一行，从中取出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tradeid&lt;/code&gt;，再到表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt; 中去匹配，第2步的sql就相当于：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;traideid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;上一步查询到的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;由于需要做字符编码转换，记住转换是子集转超集，所以又相当于：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;traideid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CONVERT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;上一步查询到的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;区别就在于函数操作是加在值上面，所以可以先计算出来，然后索引就能快速定位到。&lt;/p&gt;

    &lt;p&gt;这类问题解决办法有两个：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;最简单直接的就是把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utf8&lt;/code&gt; 编码的字段改为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt;，这样从根上避免了字符编码转换：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;modify&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf8mb4&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果不能更改字符编码，那只能手动改下sql，手动来做这个编码转换，如上面的sql可改为：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tradelog&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trade_detail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CONVERT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tradeid&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;USING&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;这里手动把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l.tradeid&lt;/code&gt; 转为了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utf8&lt;/code&gt;，保证了编码一致，避免了编码转换。&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：手动转换要确保不会丢失精度才行。&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串截断&lt;/p&gt;

    &lt;p&gt;比如有这么一张表：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`t`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`b`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`b`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`b`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;假设现在表里面，有 100 万行数据，其中有 10 万行数据的 b 的值是 ‘1234567890’，然后查询是这样写的：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;1234567890abcd&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;细心一点会发现，传进去的值超过了字段 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 定义的长度，理想情况下根本就不用去查询，直接返回空就行了。事实上这句sql执行了很长时间才会返回空，它的步骤是这样的：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;由于超过了字段 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 定义的长度，会首先做字符串截断，最终传到引擎层的值变成了 ‘1234567890’；&lt;/li&gt;
      &lt;li&gt;匹配到10万条数据，然后由于是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select *&lt;/code&gt;，还需要回表10万次；&lt;/li&gt;
      &lt;li&gt;每次回表后查出整行，到 Server 层一判断，不等于 ‘1234567890abcd’，最后返回空。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;对于这种情况，最好就是先在应用层判断过滤一下，MySQL并不总是那么智能。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;选择自增主键还是业务主键&quot;&gt;选择自增主键还是业务主键&lt;/h1&gt;

&lt;p&gt;可从存储空间大小和性能两个方面来考虑：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;存储空间：业务主键相较于自增主键都较长，由于二级索引树叶子节点存储的是主键值，所以采用业务主键的二级索引相较于自增主键会占用更多的空间。&lt;/li&gt;
  &lt;li&gt;性能：由于自增主键是有序的，所以在维护索引树时直接追加即可(&lt;strong&gt;叶子节点所在层即第0层的最后一个节点中的最后一个record后&lt;/strong&gt;)，当一页写满会自动开辟一个新的页。而业务主键很难保证有序性，维护索引时很可能会在&lt;strong&gt;中间插入&lt;/strong&gt;，就很有可能引起节点分裂(甚至是父索引节点的分裂)，自然性能会受到影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，在大多数情况下，都应优先使用自增主键。&lt;/p&gt;

&lt;p&gt;当然事无绝对，如果只有一个索引，且该业务字段是唯一的，可以将该字段设为主键。因为不存在其他索引，就不用考虑其他索引的叶子节点大小问题。当然，性能上相较于自增主键还是会有一点影响。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;选择唯一索引还是普通索引&quot;&gt;选择唯一索引还是普通索引？&lt;/h1&gt;

&lt;p&gt;从读和写两方面来分析。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;读：二者区别就在于是否唯一。唯一索引找到记录后即可返回，普通索引还需继续向后遍历检查是否满足条件。但此时数据页已在内存中，而且很大概率都是页内遍历(通过二分法)，这点差异对于现在的CPU来说可以忽略不计。所以可认为二者在查询方面差异不大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写：需要考虑目标数据页是否在内存中，下面以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert&lt;/code&gt; 举例说明&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;目标数据页在内存中：对于唯一索引来说，找到插入位置，判断到没有冲突，插入，语句执行结束；对于普通索引来说，找到插入位置，插入，语句执行结束。这种情况下直接更新内存即可，性能也没有多大差异。&lt;/li&gt;
      &lt;li&gt;目标数据页不在内存中：
        &lt;ul&gt;
          &lt;li&gt;由于唯一索引需要判断唯一性，所以必须要将数据页从磁盘读到内存。&lt;/li&gt;
          &lt;li&gt;而普通索引没有这个要求，所以可直接在内存中记录下一条 “insert” 操作，语句就执行结束了。记录这个操作的区域叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt;， 由于只需要写内存，避免了磁盘的随机读(磁盘的随机IO是数据库中成本最高的操作之一)，这种情况下普通索引性能就远远优于唯一索引，尤其如果是机械硬盘的话。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;综上所述，如果业务可以接受的话，从性能角度出发，应该选择普通索引。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;change-buffer&quot;&gt;change buffer&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer pool&lt;/code&gt; 的一部分，默认值是 25(%)，最大值可设为 50(%)。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;innodb_change_buffer_max_size&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在MySQL5.5之前的版本，只支持缓存&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert&lt;/code&gt;操作，所以最初叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert buffer&lt;/code&gt;(很多地方见到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ibuf&lt;/code&gt; 指的就是它，后来也一直延用了下来)。后来也加入了对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 的支持，便改名为了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;作用&quot;&gt;作用&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;当目标数据页不在内存(buffer pool)中时，普通索引更新类操作的提速器。注意：只能作用于普通索引，不能作用于唯一索引&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;怎么保证数据被正确更新&quot;&gt;怎么保证数据被正确更新？&lt;/h4&gt;

&lt;p&gt;上面说到，普通索引的更新写到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 中就结束了，那后续的查询是怎样的？&lt;/p&gt;

&lt;p&gt;还是对应到上面的2种情况：目标数据页在不在内存中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果目标数据页在内存中，意味着更新操作是直接更新的内存。那此时内存中的数据页一定是更新后的数据，虽然磁盘上还是老的数据，所以直接从内存返回即可；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果目标数据页不在内存中，需要先把数据页从磁盘读入内存，然后应用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 中的操作日志，生成一个正确的版本后返回，这个过程称为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt; 的时机：&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;查询时。这时会把目标数据页从磁盘读到内存中；&lt;/li&gt;
        &lt;li&gt;作为后台任务定期运行。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity_max&lt;/code&gt; 用于设置 Innodb 后台任务(刷脏页、merge)的 IOPS，可调整该数值来控制 merge 的频率；&lt;/li&gt;
        &lt;li&gt;在崩溃恢复期间，会从系统表空间(ibdata1)中读取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt;，然后当把数据页从磁盘读到内存中时，会进行 merge；&lt;/li&gt;
        &lt;li&gt;重启后；&lt;/li&gt;
        &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slow shutdown&lt;/code&gt; 时。可通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--innodb-fast-shutdown=0&lt;/code&gt; 开启 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slow shutdown&lt;/code&gt;。&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;怎么保证更新不丢失&quot;&gt;怎么保证更新不丢失？&lt;/h4&gt;

&lt;p&gt;如果写完 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 后断电了或意外宕机了，重启后 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 和数据会丢失吗？&lt;/p&gt;

&lt;p&gt;不会。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 也会被记到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redo log&lt;/code&gt; 中(&lt;strong&gt;redo log 中包含了数据页的变更和change buffer的变更&lt;/strong&gt;)，回想之前讲过的两阶段提交协议，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redo log&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binglog&lt;/code&gt;  落盘才代表事务成功提交。所以，如果一个事务已提交，则代表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 已经写到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redo log&lt;/code&gt; 中，且 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redo log&lt;/code&gt; 已落盘，崩溃恢复时会根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redo log&lt;/code&gt; 来恢复 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;适用场景&quot;&gt;适用场景&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 简单来说就是把对普通索引的更新缓存了下来，然后在适当的时候进行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;。所以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt; 之前， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 中记录的变更越多，收益就越大。&lt;/p&gt;

&lt;p&gt;所以对于&lt;strong&gt;&lt;u&gt;写多读少&lt;/u&gt;&lt;/strong&gt;类业务，数据页在写完之后马上被访问到的概率很小，也就是说不会马上进行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;，这种情况下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 的效果最好。比如账单类、日志类等。&lt;/p&gt;

&lt;p&gt;相反，如果是写后马上进行查询的业务，由于马上要访问数据页，会立即触发 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;。这种情况不仅不会减少随机IO的次数，反而会增加维护 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 的代价，起到了副作用，这种情况下可以关闭 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;innodb_change_buffering&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;默认值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;all&lt;/code&gt; ，设为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;none&lt;/code&gt; 即可关闭 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;官方文档&quot;&gt;官方文档&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/faqs-innodb-change-buffer.html#faq-innodb-change-buffer-merging&quot;&gt;InnoDB Change Buffer&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;给长字符串字段创建索引的几种方法&quot;&gt;给长字符串字段创建索引的几种方法&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;出发点是尽量减小索引长度。&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;直接创建完整索引，占空间最多&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建前缀索引&lt;/p&gt;

    &lt;p&gt;即可以只定义字符串的一部分作为索引&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index_email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;优点是：节省空间&lt;/p&gt;

    &lt;p&gt;缺点是：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;可能会增加额外的扫描次数&lt;/p&gt;

        &lt;p&gt;​	比如执行这样一句查询：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;zhangssxyz@xxx.com&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;​	对于完整索引，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 索引树上定位到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zhangssxyz@xxx.com&lt;/code&gt;，然后回表取出对于记录即可，只需扫描一行；&lt;/p&gt;

        &lt;p&gt;​	对于前缀索引，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 前缀索引树上定位到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zhangs&lt;/code&gt;，回表判断 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 是否等于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zhangssxyz@xxx.com&lt;/code&gt;，是的话将记录加入结果集，继续在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 前缀索引树上遍历下一条记录，再回表判断，重复此过程，直到遍历的下一条记录不等于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zhangs&lt;/code&gt;。所以前缀索引可能会增加记录的扫描行数。&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;如何优化？&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;关键在于&lt;strong&gt;增加前缀的区分度&lt;/strong&gt;。区分度越高，过滤掉的记录就越多，需要回表的次数就越少。&lt;/p&gt;

        &lt;p&gt;先统计索引上有多少个不同的值：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;再依次选取不同长度的前缀来对比区分度：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;数值越大表示对应长度的前缀区分度越高，效果越好。&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;不能使用覆盖索引&lt;/p&gt;

        &lt;p&gt;比如执行这样一句查询：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;zhangssxyz@xxx.com&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;因为只需要查询 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id,email&lt;/code&gt;，对于完整索引来说，使用覆盖索引即可，不需要再回表；&lt;/p&gt;

        &lt;p&gt;而对于前缀索引，则必须要回表判断 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 的值，即便前缀索引包含了全部字段(email(18)，假设&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 有18个字符)也是如此。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;倒序存储&lt;/p&gt;

    &lt;p&gt;对于前缀区分度不够好的情况，可以考虑使用倒序存储。&lt;/p&gt;

    &lt;p&gt;比如身份证，同一个区域内的身份证前面几位都是相同的，如果按照上面的方法建立前缀索引，这个前缀的长度可能会比较长。&lt;/p&gt;

    &lt;p&gt;这时可把身份证倒过来存，因为身份证的尾部都是不同的，区分度足够高，查的时候转换一下：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field_list&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id_card&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;input_id_card_string&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这时为身份证建立前缀索引需要的长度就会短很多，具体多长可通过上面的方法来确定。&lt;/p&gt;

    &lt;p&gt;缺点：&lt;strong&gt;不支持范围查询&lt;/strong&gt;，因为不是有序的，没办法按顺序遍历。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新增一个 hash 字段&lt;/p&gt;

    &lt;p&gt;专门新增一个 hash 字段用来做索引。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;相较于倒序存储查询性能相对稳定一些，因为倒序存储毕竟还是前缀索引，或多或少还是会增加扫描行数。而crc32(或其他哈希算法)冲突的概率总体还是非常小的，可认为每次查询的平均扫描行数接近1。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id_card_crc&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id_card_crc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;每次插入新纪录的时候，都用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crc32()&lt;/code&gt; 计算出一个哈希值填到这个新字段中。&lt;/p&gt;

    &lt;p&gt;查询的时候计算一下，&lt;strong&gt;同时因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crc32&lt;/code&gt; 会有冲突(虽然概率也非常小)，所以还需要在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where&lt;/code&gt; 中校验一下原值&lt;/strong&gt;：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field_list&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id_card_crc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;crc32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;input_id_card_string&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id_card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;input_id_card_string&apos;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这时索引的长度就只有4个字节(crc32的长度)，相较于身份证长度大大减少了。&lt;/p&gt;

    &lt;p&gt;缺点：和倒序存储一样，&lt;strong&gt;不支持范围查询&lt;/strong&gt;，因为哈希字段对应的原值完全是无序的，没办法在哈希索引上按顺序遍历。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 11 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/10/11/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)-MySQL%E7%B4%A2%E5%BC%95/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/10/11/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)-MySQL%E7%B4%A2%E5%BC%95/</guid>
        
        <category>mysql</category>
        
        <category>索引</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(六)：MySQL事务</title>
        <description>&lt;h1 id=&quot;解决的问题&quot;&gt;解决的问题&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;脏读：读到还没有提交事务的数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不可重复读：前后读取的记录&lt;strong&gt;内容&lt;/strong&gt;不一致&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;幻读：同一事务前后两次查询同一范围数据时，后一次查询看到了前一次查询没有看到的行&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;主要针对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert&lt;/code&gt; 操作， 使用间隙锁解决，详见 &lt;a href=&quot;/blog/2021/10/18/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)-MySQL%E9%94%81/#next-key-lock&quot;&gt;MySQL学习笔记(八)-MySQL锁之 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next-key lock&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;隔离级别&quot;&gt;隔离级别&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;读未提交&lt;/li&gt;
  &lt;li&gt;读提交：可解决脏读问题&lt;/li&gt;
  &lt;li&gt;可重复读：可解决不可重复读问题&lt;/li&gt;
  &lt;li&gt;串行化：事务都是串行执行，安全度最高，并发度最低&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何查询隔离级别&quot;&gt;如何查询隔离级别？&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;%isolation%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211031200530501.png&quot; alt=&quot;image-20211031200530501&quot; /&gt;&lt;/p&gt;

&lt;p&gt;默认级别为&lt;strong&gt;可重复读&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;如何更改隔离级别&quot;&gt;如何更改隔离级别？&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;isolation&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;READ&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UNCOMMITTED&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;如何实现&quot;&gt;如何实现？&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVCC（Multiple Version Concurrency Control）多版本并发控制&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;简而言之，就是一行记录在数据库中存在多个版本，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/image-20211103102036454.png&quot; alt=&quot;image-20211103102036454&quot; /&gt;&lt;/p&gt;

&lt;p&gt;V1、V2、V3 并不是物理真实存在的，真实存在的是U1、U2、U3，也就是undo日志。当需要上一个版本的数据时，会通过当前记录和undo日志推算出来。其实每行记录都会有一个我们看不到的隐藏字段trx_id。&lt;/p&gt;

&lt;h4 id=&quot;一致性视图一致性读&quot;&gt;一致性视图（一致性读）&lt;/h4&gt;

&lt;p&gt;有两种开启事务的方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;begin/start transaction：并不是一个事务的真正起点，到执行第一个语句的时候才会创建一致性视图&lt;/li&gt;
  &lt;li&gt;start transaction with consistent snapshot：马上开启事务并创建一致性视图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;事务开启时，会创建一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一致性视图&lt;/code&gt;。不必纠结于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;视图&lt;/code&gt;两个字(其实就是个数组)，可简单理解为这样一个操作：记录下真正开启事务的那一刻(创建一致性视图的那一刻)，&lt;strong&gt;后面会以这个时刻为准来判断数据的哪个版本对于当前事务可见&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;具体实现上，会在开启事务的那一刻生成一个数组，保存了当前系统正在活跃（启动了还没提交）的事务ID，定义一个低水位：数组里的最小事务ID，高水位：当前系统已经创建过的最大的事务ID+1，这个数组和高低水位即构成了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一致性视图&lt;/code&gt;。后续的操作应该可以猜到，就是拿记录的事务ID和这个高低水位比较来判断是否可见。这是具体的代码逻辑，不方便记忆，可简化为下面的可见性规则(RR级别下)：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;本事务的更新总是可见&lt;/li&gt;
  &lt;li&gt;版本未提交，不可见&lt;/li&gt;
  &lt;li&gt;版本已提交，但是在一致性视图创建之后提交的，不可见&lt;/li&gt;
  &lt;li&gt;版本已提交，而且是在一致性视图创建之前提交的，可见&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上就是事务具体是如何实现的&lt;/p&gt;

&lt;h4 id=&quot;不同隔离级别下的一致性视图生成时机&quot;&gt;不同隔离级别下的一致性视图生成时机&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;读未提交：直接读取记录的最新版本，没有视图的概念&lt;/li&gt;
  &lt;li&gt;读提交：每个语句会生成新的一致性视图&lt;/li&gt;
  &lt;li&gt;可重复读：在事务开启的时候生成一致性视图，在后续的整个事务期间都使用该视图&lt;/li&gt;
  &lt;li&gt;串行化：直接用加锁的方式来避免并行访问&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;当前读&quot;&gt;当前读&lt;/h4&gt;

&lt;p&gt;事务使用的是一致性读，这里针对的是查询类操作，&lt;strong&gt;&lt;u&gt;而更新类操作使用的是当前读，即读取记录的最新版本，这个区别这很重要&lt;/u&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;示例一&quot;&gt;示例一&lt;/h4&gt;

&lt;p&gt;千言万语，不如动手验证一下&lt;/p&gt;

&lt;p&gt;假设存在表 t ( id, k)  values (1,1) ( 2, 2)，事务级别为默认级别，即可重复读。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k=k+1 where id=1;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k=k+1 where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;select k from t where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;select k from t where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;commit;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;commit;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事务C没有显示开启事务，所以更新完成以后自动提交了，此时k的值是2。&lt;/p&gt;

&lt;p&gt;先分析事务A，事务A最先开启，根据可重复读的一致性视图生成时机，在开启的那一刻创建了一致性视图，在此后的整个事务期间都使用该视图。又根据事务可见性规则，事务C的版本虽已提交，但是在视图创建之后提交的，不可见。事务B先不管值是多少，版本尚未提交，仍不可见。所以事务A的查询结果仍是1。&lt;/p&gt;

&lt;p&gt;事务B首先执行了一次更新操作，这里的重点就是：此时读取的是哪个版本？&lt;strong&gt;结论是最新版本，即当前读&lt;/strong&gt;。因为要保证更新不能丢失。所以读到的值是2，再+1=3。然后再进行一次查询操作，根据事务的可见性规则，本事务的更新总是可见。所以，事务B的查询结果是3。&lt;/p&gt;

&lt;p&gt;如果换成读提交隔离级别，结果是怎样的？&lt;/p&gt;

&lt;p&gt;根据读提交的一致性视图生成时机：在每一次执行语句的时候都生成新的视图，所以事务A的视图是在执行到 select 的时候生成。再根据事务的可见性规则，事务C的更新已提交，且是在视图生成之前提交，可见。事务B的更新尚未提交，不可见。所以事务A的查询结果是2。&lt;/p&gt;

&lt;p&gt;事务B的查询结果还是3，分析过程和可重复读隔离级别下一样。&lt;/p&gt;

&lt;p&gt;将上面的操作步骤稍微改一下，事务C稍后再提交，隔离级别仍是可重复读，看下结果会怎样&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k=k+1 where id=1;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k=k+1 where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;select k from t where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;select k from t where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;commit;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;commit;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;commit;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事务A查询结果：事务B和事务C的更新都尚未提交，不可见，结果是1。&lt;/p&gt;

&lt;p&gt;事务B查询结果：重点来了，由于事务C更新后没有马上提交，所以id=1的写锁一直未释放。而事务B是当前读，必须要读最新版本，若读到的记录最终被回滚了，就产生了脏读，这是不可接受的，&lt;strong&gt;所以必须确保当前读读到的数据是最终会被提交的数据。具体实现就是加锁，来确保当前读的数据是最新的且已提交的&lt;/strong&gt;(从事务的角度来解释行锁)。所以事务B的更新，要等待事务C提交后才能继续。&lt;/p&gt;

&lt;h4 id=&quot;示例二&quot;&gt;示例二&lt;/h4&gt;

&lt;p&gt;用事务的可见性来验证一个行为：更新的值与原来的值相同的情况下，MySQL还会执行更新吗？还是看到值相同直接返回了？&lt;/p&gt;

&lt;p&gt;假设存在表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t(id,a)&lt;/code&gt;，插入一条数据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1,2)&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;先验证是否还会加写锁(因为行锁是Innodb特有的，如果加写锁，说明还是会调用Innodb引擎的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update接口&lt;/code&gt;)&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;update t set a=2 where id = 1;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;update t set a=2 where id = 1; (&lt;strong&gt;blocked&lt;/strong&gt;)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;sessionB的更新被阻塞，说明还是会加写锁。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;再验证Innodb引擎是否会执行更新&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;注：此时&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_format&lt;/code&gt; 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;statment&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_format&lt;/code&gt; 会影响结果，后面会详细分析&lt;/strong&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select * from t where id=1; &lt;br /&gt;&lt;strong&gt;返回(1,2)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;update t set a=3 where id=1;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;update t set a=3 where id=1;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select * from t where id=1; &lt;br /&gt;&lt;strong&gt;返回(1,3)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;sessionA 的 update 是当前读，它肯定读到了 sessionB 更新后的最新版本，现在的问题是 sessionA 的这个 update 会不会执行更新？&lt;/p&gt;

    &lt;p&gt;根据事务的可见性规则，sessionA的第二个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select&lt;/code&gt; 是看不到 sessionB 的更新的，但是它读取到的值却是(1,3)，所以这个版本只能是本事务自己更新的，也就证明了sessionA中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 是执行了更新操作的。&lt;/p&gt;

    &lt;p&gt;到这里可能会觉得这不是多此一举吗？判断一下值是否相等，相等的话就不用更新了。&lt;/p&gt;

    &lt;p&gt;事实上，是执行了判断的，&lt;strong&gt;只是这个判断没有办法判断出是否要执行更新&lt;/strong&gt;。因为和具体的 sql 有关，在这句sql里：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set a=3&lt;/code&gt;，这个赋值操作和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 原本的值没有任何关系，所以虽然 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 是当前读，但因为和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 没有关系，就不会读出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 的值。既然没有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 的值，就没有办法判断是否和原值相等，所以只能老老实实执行一遍更新操作。&lt;/p&gt;

    &lt;p&gt;可将sessionA的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update where&lt;/code&gt; 条件加上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a=3&lt;/code&gt;，&lt;strong&gt;此时因为读出了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;的值，Innodb判断到值是相同的，就不会执行更新操作&lt;/strong&gt;。因此第二个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select&lt;/code&gt; 还是读取的一致性视图，返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1,2)&lt;/code&gt;：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select * from t where id=1; &lt;br /&gt;&lt;strong&gt;返回(1,2)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;update t set a=3 where id=1;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;update t set a=3 where id=1 and a=3;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select * from t where id=1; &lt;br /&gt;&lt;strong&gt;返回(1,2)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;这个实验也可以得出一个结论：&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt;  虽然都是当前读，但不一定都会执行更新操作&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;上面说过，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_format&lt;/code&gt; 会影响结果，将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_format&lt;/code&gt; 改为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;row&lt;/code&gt; 后，会发现 sessionA 的第二个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select &lt;/code&gt; 读取到的都是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1,2)&lt;/code&gt;。这是因为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;row&lt;/code&gt; 格式的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog&lt;/code&gt; 记录的是行数据的变更，需要拿到所有字段，拿到所有字段后就可以进行判断，发现值相同便不执行更新操作&lt;/strong&gt;，所以 sessionA 的第二个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select &lt;/code&gt; 读取到的还是一致性视图中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1,2)&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;长事务&quot;&gt;长事务&lt;/h1&gt;

&lt;p&gt;尽量避免长事务，长事务有以下风险：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;会产生大量undo日志，会占用大量存储空间。在MySQL 5.5 及以前版本中，回滚日志是和数据字典一起放在ibdata文件中的，即使长事务最终被提交，回滚日志被清理，文件也不会变小。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;还会占用锁，可能拖垮整个库。在 RR 级别下，所有锁资源要在事务提交后才释放。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于undo日志太多，导致需要快照读的查询变得很慢&lt;/p&gt;

    &lt;p&gt;如这个例子：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;share&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;按理说，第二句还需要加锁，应该是第一句更快点，而结果却是(慢查询日志)：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/img/image-20211209102019414.png&quot; alt=&quot;image-20211209102019414&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/img/image-20211209102038330.png&quot; alt=&quot;image-20211209102038330&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;第一句查询需要800ms，第二句只需要0.2ms，为什么有这么大的差距？&lt;/p&gt;

    &lt;p&gt;其实它们的执行序列是这样的：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;#执行100万次&lt;br /&gt;update t set c=c+1 where id=1;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select * from id=1;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select * from id=1 lock in share mode;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;所以很明显，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sessionB&lt;/code&gt;  产生了大量的回滚日志，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select * from id=1 lock in share mode&lt;/code&gt; 是当前读 ，读取的是最新版本，所以很快。而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select * from id=1&lt;/code&gt; 是快照读，需要从当前版本应用100万次回滚日志得到最初的版本，因此自然慢多了。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;甚至可能会导致优化器选错索引。&lt;/p&gt;

    &lt;p&gt;案例重现：&lt;/p&gt;

    &lt;p&gt;表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 定义如下：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`t`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`a`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`b`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`a`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`a`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`b`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`b`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;存储过程，插入100000条数据：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;delimiter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;delimiter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;插入数据后执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select * from t where a between 10000 and 20000&lt;/code&gt;，查询走的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 索引，没有问题&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;between&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20000&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/img/image-20211124051211671.png&quot; alt=&quot;image-20211124051211671&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sessionA&lt;/code&gt; 模拟一个长事务，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sessionB&lt;/code&gt; 先清空表，再调用存储过程插入数据&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;delete from t;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;call idata();&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;explain select * from t where a between 10000 and 20000;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;commit&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;再查看执行计划，会发现没有选择使用索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;，走的是全表扫描&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/img/image-20211124051702688.png&quot; alt=&quot;image-20211124051702688&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;为什么？&lt;/p&gt;

    &lt;p&gt;选择索引是优化器的工作，它会综合考虑&lt;strong&gt;扫描行数、索引基数、是否使用了临时文件、是否排序等因素&lt;/strong&gt;来选择它认为速度最快的索引。&lt;/p&gt;

    &lt;p&gt;可通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show index from t&lt;/code&gt; 来查看索引基数 cardinality (近似值，并不精确)，结果如下：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/img/image-20211124160802373.png&quot; alt=&quot;image-20211124160802373&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;索引基数越大，说明区分度越高，选择它的概率就越大。图中可以看出主键和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 的差距并不大，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 反而是最高的，不选择索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 肯定还有其他的原因。&lt;/p&gt;

    &lt;p&gt;再来看一下扫描行数。查询计划显示走的是全表扫描，rows为105033行。强制使用索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 看下扫描行数是多少：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;force&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;between&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/img/image-20211124161809601.png&quot; alt=&quot;image-20211124161809601&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;rows为39940行。这个差距挺大的，那为什么优化器放着 39940行的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 索引不用而要选择 105033行的全表扫描？&lt;/p&gt;

    &lt;p&gt;因为使用索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 需要回表，而走全表扫描是直接扫描主键索引树，不需要回表，优化器”&lt;u&gt;认为&lt;/u&gt;“全表扫描更快。&lt;strong&gt;从结果上看，优化器明显选错了，所以优化器也不是百分百可靠的&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;到这里又有一个疑问，为什么开启了一个长事务后，删除再插入数据就会导致扫描行数发生变化？&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;很明显，肯定和这个长事务有关。&lt;/p&gt;

    &lt;p&gt;先简单说一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undo log&lt;/code&gt;，分为两种：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert undo logs&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update undo logs&lt;/code&gt;，对应 insert操作和update、delete操作(delete本质上也是update操作，delete时并不是直接物理删除，而是先做一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deleted&lt;/code&gt; 标记)。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert undo logs&lt;/code&gt; 只用于回滚操作，&lt;strong&gt;并且在事务提交后便可清除&lt;/strong&gt;(事务提交即意味着插入已永久持久化了，不会再有回滚操作，也就不再需要 insert undo logs 了)。而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update undo logs&lt;/code&gt; &lt;strong&gt;除了用于回滚操作之外，还用于MVCC，且当没有在该事务开启之前开启的其他事务在运行时，方可删除&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;上面讲到 delete 时并不是直接物理删除，而是先标记。&lt;strong&gt;只有在对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update undo logs&lt;/code&gt; 被清除时才会进行真正的物理删除，这个过程也称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;purge&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;所以在这个案例中，因为先开启了一个长事务 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sessionA&lt;/code&gt;，&lt;strong&gt;为了保证事务的可重复读，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sessionB&lt;/code&gt; 中进行的 delete 和 insert 操作所产生的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;upodate undo logs&lt;/code&gt; 会一直保留直到长事务提交&lt;/strong&gt;。也就意味着原先的10万行数据并没有被真正删除，而是保留在了索引树上。因此每一行都会有两个版本，即总共会有20万数据，从 ibd 文件大小也能看出，大小变为了原来的两倍。而优化器统计扫描行数时会将标记为删除的版本也统计在内，导致扫描行数增加。&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;那为什么只有索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 的扫描行数增加了，主键的扫描行数还是10万行？因为主键的扫描行数是直接按照表的行数来估算的，而表的行数优化器取的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show table status like &apos;t&apos;&lt;/code&gt; 中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rows&lt;/code&gt; 的值。索引的统计则是通过对数据页采样统计估算出来的，所以会算上老版本的数据。&lt;/p&gt;

    &lt;p&gt;原因找到了，如何解决？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;既然是由长事务引起的，提交或kill掉长事务后便可重新让查询走索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;简单粗暴，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;force index(a)&lt;/code&gt;  强制使用索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;`&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;analyze table t&lt;/code&gt; 重新统计索引信息，优化器会更正扫描行数，然后选择使用索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 。&lt;strong&gt;当发现 explain 预估的 rows 和实际情况差距较大时，都可以采用这个方法来处理&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何监控长事务&quot;&gt;如何监控长事务？&lt;/h2&gt;

&lt;p&gt;下述语句用于监测持续时间超过60s的长事务&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;information_schema&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;innodb_trx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIME_TO_SEC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timediff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trx_started&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;如何避免长事务&quot;&gt;如何避免长事务？&lt;/h2&gt;

&lt;h3 id=&quot;应用开发端&quot;&gt;应用开发端&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;确认是否使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set autocommit = 0 &lt;/code&gt;，代表手动提交事物。可先开启 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;general_log&lt;/code&gt;，通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show global variables like &apos;%general_log%&apos;&lt;/code&gt; 查看 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;general_log&lt;/code&gt; 相关设置。然后随便跑一个业务逻辑，在日志中检查是否有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set autocommit = 0 &lt;/code&gt;；&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;The general query log is a general record of what &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/mysqld.html&quot;&gt;&lt;strong&gt;mysqld&lt;/strong&gt;&lt;/a&gt; is doing. The server writes information to this log when clients connect or disconnect, and it logs each SQL statement received from clients. &lt;strong&gt;The general query log can be very useful when you suspect an error in a client and want to know exactly what the client sent to &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/mysqld.html&quot;&gt;mysqld&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;

      &lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/query-log.html&quot;&gt;mysql8 doc general_log&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确认是否有不必要的只读事务。有些框架会不管什么语句都用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;begin/commit&lt;/code&gt; 包起来。或者有些业务并没什么必要，也要把一堆 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select&lt;/code&gt; 放到事务中。上面提到过，对当前读事务会加锁。所以对于单纯的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select&lt;/code&gt; 没有必要放到事务中，事务中主要放 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update/insert/delete&lt;/code&gt;，除非是明确需要事务特性的查询，比如明确需要可重复读的查询，才需要放到事务中；&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据对业务的预估，通过 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set max_execution_time&lt;/code&gt;&lt;/strong&gt; 来设置单个语句的最长执行时间，来避免单个语句意外执行过长时间。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;毫秒，0 表示未启用。&lt;/p&gt;

      &lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_execution_time&quot;&gt;mysql 8 doc max_execution_time&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;数据库端&quot;&gt;数据库端&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;监控 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;information_schema.innodb_trx&lt;/code&gt;表，超过阈值就报警或者kill掉。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;推荐使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;percona 的 pt-kill&lt;/code&gt; 工具，作用描述如下：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;pt-kill&lt;/strong&gt; captures queries from SHOW PROCESSLIST, filters them, and then either kills or prints them. This is also known as a “slow query sniper” in some circles. The idea is to watch for queries that might be consuming too many resources, and kill them.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在测试阶段可要求输出所有的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;general_log&lt;/code&gt;，分析日志提前发现问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在MySQL5.6或更新版本，可将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_undo_tablespaces&lt;/code&gt; 设置为 2 或更大的值，如果真的出现大事务导致回滚段过大，清理起来更方便。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_undo_tablespaces&lt;/code&gt; ：&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;0：使用系统表空间，即 ibdata1&lt;/li&gt;
        &lt;li&gt;不为0：使用独立数量的undo表空间，默认为2，即存在两个独立的回滚表空间： undo_001、undo_002&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 19 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/09/19/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)-MySQL%E4%BA%8B%E5%8A%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/09/19/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)-MySQL%E4%BA%8B%E5%8A%A1/</guid>
        
        <category>mysql</category>
        
        <category>事务</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(五)：MySQL计算QPS和TPS</title>
        <description>&lt;h3 id=&quot;qps&quot;&gt;QPS&lt;/h3&gt;

&lt;p&gt;基于 Com_select&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;基于questions的会统计show命令，mysql设置环境变量的时候也会增加，不太准。&lt;/p&gt;

  &lt;p&gt;Com_select 用于统计 select 语句的执行次数，类似的还有 Com_delete、Com_update 等。&lt;/p&gt;

  &lt;p&gt;参考：&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/server-status-variables.html#statvar_Com_xxx&quot;&gt;Com_xxx&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;OLD_QPS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_select&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sleep&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;NEW_QPS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_select&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NEW_QPS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OLD_QPS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;) / &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; | bc
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$1&lt;/code&gt; 代表添加到shell的第一个参数值，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$2&lt;/code&gt; 代表第二个，以此类推。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$0&lt;/code&gt; 为shell文件名。&lt;/p&gt;

&lt;p&gt;获取当前时刻的 qps：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;./qps.sh 1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;tps&quot;&gt;TPS&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#/usr/bin/env bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;OLD_COM_INSERT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_insert&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;OLD_COM_UPDATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_update&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;OLD_COM_DELETE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_delete&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sleep&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;NEW_COM_INSERT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_insert&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;NEW_COM_UPDATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_update&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;NEW_COM_DELETE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_delete&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NEW_COM_INSERT&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; - &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OLD_COM_INSERT&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;) + (&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NEW_COM_UPDATE&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; - &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OLD_COM_UPDATE&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;) + (&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NEW_COM_DELETE&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; - &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OLD_COM_DELETE&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)) / &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; | bc
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 11 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/09/11/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)-MySQL%E8%AE%A1%E7%AE%97QPS%E5%92%8CTPS/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/09/11/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)-MySQL%E8%AE%A1%E7%AE%97QPS%E5%92%8CTPS/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(四)：MySQL定时备份和恢复</title>
        <description>&lt;p&gt;定时备份：使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysqldump&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crontab&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;mysqldump-用法&quot;&gt;mysqldump 用法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;备份全部数据库的数据和结构&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份全部数据库的结构（加 -d 参数）&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份全部数据库的数据(加 -t 参数)&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份单个数据库的数据和结构(数据库名mydb)&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份单个数据库的结构&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份单个数据库的数据&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份多个表的数据和结构（数据，结构的单独备份方法与上同）&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一次备份多个数据库&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--databases db1 db2 &amp;gt; /data/mysqlDump/mydb.sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;crontab-用法&quot;&gt;crontab 用法&lt;/h3&gt;

&lt;p&gt;crontab不同操作系统实现不同，语法是通用的&lt;/p&gt;

&lt;p&gt;crontab 表达式含义：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;表示分钟&lt;/li&gt;
  &lt;li&gt;表示小时&lt;/li&gt;
  &lt;li&gt;表示一个月中的第几天&lt;/li&gt;
  &lt;li&gt;表示月份&lt;/li&gt;
  &lt;li&gt;表示一个星期中的第几天&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; 表示分钟都要执行（以此类推）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a-b&lt;/code&gt; 表示从 a 到 b 这段时间内要执行（以此类推）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*/n&lt;/code&gt; 表示每 n 分钟执行一次（以此类推）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a,b,c&lt;/code&gt; 表示在第 a、b、c 分钟执行（以此类推）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;定时任务脚本&quot;&gt;定时任务脚本&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;31
&lt;span class=&quot;nv&quot;&gt;backup_dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lib/mysql
&lt;span class=&quot;nb&quot;&gt;dd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; +%Y-%m-%d_%H:%M:%S&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;tool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mysqldump
&lt;span class=&quot;nv&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;root
&lt;span class=&quot;nv&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxxx
&lt;span class=&quot;nv&quot;&gt;database_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;test

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backup_dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backup_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$tool&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$username&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$password&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$database_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backup_dir&lt;/span&gt;/&lt;span class=&quot;nv&quot;&gt;$database_name&lt;/span&gt;-&lt;span class=&quot;nv&quot;&gt;$dd&lt;/span&gt;.sql

&lt;span class=&quot;nv&quot;&gt;delfiles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-crt&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backup_dir&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.sql | &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;{print $9 }&apos;&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-crt&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backup_dir&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.sql | &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;{print $9 }&apos;&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-gt&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$delfiles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;利用全量备份和binlog恢复数据&quot;&gt;利用全量备份和binlog恢复数据&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用全量备份恢复临时库&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; database &amp;lt; dump.sql
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flush logs&lt;/code&gt; 重开一个binlog，一是避免操作当前binlog文件防止发生意外情况，二是缩小范围排除干扰，在之前的binlog中定位操作范围&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;flush logs
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;恢复&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqlbinlog&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--start-position &quot;6276&quot; --stop-position &quot;6481&quot;  binlog.000011 | mysql -uroot -p&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/letcafe/p/mysqlautodump.html&quot;&gt;MySQL 定时备份数据库（全库备份）&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/09/05/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)-MySQL%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/09/05/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)-MySQL%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(三)：redo log 和 binlog</title>
        <description>&lt;h1 id=&quot;binlog&quot;&gt;binlog&lt;/h1&gt;

&lt;p&gt;MySQL Server层的日志，与存储引擎无关，存储的是逻辑日志，可理解为sql语句。&lt;/p&gt;

&lt;h3 id=&quot;主要作用&quot;&gt;主要作用：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;如果是 Innodb 引擎，和 redo log 一起提供崩溃恢复的能力（crash-safe），保证了事务ACID中的持久性。&lt;/li&gt;
  &lt;li&gt;常被用于主备同步，或接入其他下游系统如 es 用于数据分析，即作为其他需要直接从数据库获取数据且有很高实时性要求的应用系统数据来源通道。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;如何查看&quot;&gt;如何查看？&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;​	查看binlog 格式&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;%binlog_format%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;​    查看当前使用的binlog文件&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;​    查看所有binlog文件&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;binary&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看binlong文件内容&lt;/p&gt;

    &lt;p&gt;方式一：show 命令&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binlog&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;binlog.000008&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;方式二： mysqlbinlog&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mysqlbinlog &lt;span class=&quot;nt&quot;&gt;--base64-output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;decode-rows&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--verbose&lt;/span&gt; binlog.000001
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;binlog 3种格式的区别&lt;/p&gt;

    &lt;p&gt;STATEMENT：记录具体执行语句，如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update t set name = &apos;newName&apos; where name = &apos;oldName&apos;&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;ROW：记录每一行记录的变更，一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 可能产生多条日志（每条记录都会产生一行日志）&lt;/p&gt;

    &lt;p&gt;MIXED：当满足某些条件时会自动从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STATEMENT&lt;/code&gt;切换到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROW&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择哪种格式？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STATEMENT&lt;/code&gt; ：直接记录sql，可能会在某些情况下导致通过日志恢复出来的数据不一致，比如 &lt;a href=&quot;https://luxinghong.github.io/blog/2021/10/18/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)-MySQL%E9%94%81/#rc-%E5%92%8C-rr-%E5%9C%A8%E9%94%81%E9%97%AE%E9%A2%98%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB&quot;&gt;RC 和 RR 在锁问题上的区别&lt;/a&gt;、&lt;a href=&quot;/blog/2021/09/19/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)-MySQL%E4%BA%8B%E5%8A%A1/#%E7%A4%BA%E4%BE%8B%E4%BA%8C&quot;&gt;更新的值与原来的值相同的情况下，MySQL还会执行更新吗？&lt;/a&gt;、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 时走的索引不同会导致删除的记录不同、一些函数结果不同等等&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROW&lt;/code&gt;： 直接记录每一行记录的变更，最安全，但是日志的量会很大，存储空间不紧张的话最好选择该格式。MySQL 8 默认格式就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROW&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIXED&lt;/code&gt;： 需要非常熟悉切换的条件，以确保用日志恢复数据不会有问题&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换当前连接 binlog 格式&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SESSION&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binlog_format&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;STATEMENT&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;刷新binlog&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;binlog的写入时机&quot;&gt;binlog的写入时机&lt;/h3&gt;

&lt;p&gt;binlog会首先写到cache里，cache满了就会暂存到磁盘上，这个参数大小由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_cache_size&lt;/code&gt; 控制，默认是32K。&lt;strong&gt;注意这个cache是单个线程拥有的，也就是说每个线程都有自己的binlog_cache，但是共用同一份binlog文件。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个事务的binlog是不能被拆开的，无论一个事务多大，也要确保一次性写入binlog文件。&lt;/p&gt;

&lt;p&gt;binlog会被首先&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt;到操作系统的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page cache&lt;/code&gt;中，然后才会被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsync&lt;/code&gt;到磁盘中。一般可认为只有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsync&lt;/code&gt;才占磁盘的IOPS。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt;  和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsync&lt;/code&gt; 的时机由参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync_binlog&lt;/code&gt;控制，默认值是1，总共有3种设置：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;0：每次事务提交时都只write，不fsync。由于只保存到操作系统缓存，依赖操作系统来时不时的fsync，如果主机掉电或崩溃会丢失binlog&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1：每次事务都 fsync&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;N(N&amp;gt;1)：每次事务提交都write，但只有累计了 N 个事务以后才会 fsync，如果主机掉电或崩溃会丢失最近N个事务的binlog&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_sync_binlog&quot;&gt;参考：mysql8 doc sync_binlog&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;redo-log&quot;&gt;redo log&lt;/h1&gt;

&lt;p&gt;Innodb 特有的日志，存储的是物理日志，即数据页上的改动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据页&lt;/strong&gt;：Innodb 从磁盘读取数据的基本单位，即使只取一行记录，也会将改行所在的整个数据页读入内存。数据页的大小可通过以下参数查看，默认为16k&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;innodb_page_size&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主要作用：提供事务能力，保证 crash-safe&lt;/p&gt;

&lt;h3 id=&quot;redo-log-格式&quot;&gt;redo log 格式&lt;/h3&gt;

&lt;p&gt;采用循环写的方式，有2个游标：checkpoint、writepos。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;writepos&lt;/code&gt; 表示当前写的位置，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkpoint&lt;/code&gt; 表示要擦除的位置，都是边写边往后推移。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/16a7950217b3f0f4ed02db5db59562a7.webp&quot; alt=&quot;16a7950217b3f0f4ed02db5db59562a7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个图画的不太好，一开始 checkpoint 和 writepos 都处于同一位置，边写边往后推移。上图可理解为：两者一开始都处于 checkpoint 现在的位置，writepos 写了一圈又转到 checkpoint 后面了。 所以绿色的部分表示空闲的空间，黄色的表示已写的空间。&lt;/p&gt;

&lt;h3 id=&quot;查看-redo-log-相关设置&quot;&gt;查看 redo log 相关设置&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;%innodb_log%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/Screenshot_20211028_111202.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_log_buffer_size&lt;/code&gt;：redo log 缓冲区大小，默认16M&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_log_file_size&lt;/code&gt;：redo log文件大小，默认48M&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_log_files_in_group&lt;/code&gt;：每组有多少个redo log 文件，默认2个：ib_logfile0、ib_logfile1&lt;/p&gt;

&lt;h3 id=&quot;redo-log-一般设多大&quot;&gt;redo log 一般设多大？&lt;/h3&gt;

&lt;p&gt;redo log 太小的话，会导致很快被写满，然后不得不强行刷 redo log，发挥不出 WAL 的作用。&lt;/p&gt;

&lt;p&gt;所以，磁盘空间不是很紧张的话，设大点吧，比如设置为4个文件，每个文件1G。&lt;/p&gt;

&lt;h3 id=&quot;redo-log-的写入时机&quot;&gt;redo log 的写入时机？&lt;/h3&gt;

&lt;p&gt;同样，redo log 也分为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsync&lt;/code&gt;，由参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;控制，默认值为1：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;0：只把 redo log 写到 redo log buffer 中，后台线程每隔1s会将 buffer 中的内容 write、fsync 到磁盘&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果 MySQL 崩溃，会丢失1s的事务数据&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1：每次事务提交都 fsync 到磁盘&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;最安全，严格保证了事务的持久性，只要事务提交成功，就说明对应的日志已落盘&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2：每次事务提交都只将redo log 写到 page cache 中，后台线程每隔1s会将 page cache 中的内容 fsync 到磁盘&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果主机掉电或异常重启，会丢失1s的事务数据&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;0 和 2 的区别在于，0是写到了 redo log buffer 中，属于 MySQL 管理的内存。2是写到了 page cache 中，属于操作系统的内存。&lt;/p&gt;

&lt;p&gt;可靠性 1 最高，性能 0和2 最好（2 可靠性要比 0 高，因为主机重启的概率一般比MySQL崩溃的概率低，二者选一的话，建议设置为2）。&lt;/p&gt;

&lt;p&gt;没提交的事务也会被 &lt;strong&gt;&lt;u&gt;被动的&lt;/u&gt;&lt;/strong&gt; 写入磁盘：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;redo log buffer 占用空间达到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_log_buffer_size&lt;/code&gt; 一半时，后台线程会主动写盘，注意由于没有提交事务，此时只是 write，没有 fsync&lt;/li&gt;
  &lt;li&gt;如果有并行事务，假如A执行了一半，已经写了一些redo log 到 buffer中，此时 B 提交，如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;=1，B要把buffer里日志全部fsync到磁盘，此时会带上A的内容一起fsync&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit&quot;&gt;参考：mysql8 doc innodb_flush_log_at_trx_commit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;最终数据落盘的过程是&quot;&gt;最终数据落盘的过程是？&lt;/h3&gt;

&lt;p&gt;1、正常运行过程中，MySQL更新完内存后便可返回响应。内存中的数据页被称为脏页，最终数据落盘就是把脏页写盘，这个过程和redo log 毫无关系。当然，此时 redo log 中已经记录了相关数据页的改动。写盘的时候还会向前推进redo log 中 checkpoint 的位置。&lt;/p&gt;

&lt;p&gt;2、在崩溃恢复时或启动时（MySQL启动时会自动执行该过程），会先将 redo log 中记录的变更应用到内存数据页中，此时该数据页就变成了脏页，接下来的步骤就和第1种情况一样了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;两阶段提交&quot;&gt;两阶段提交&lt;/h1&gt;

&lt;p&gt;一个事务当写完内存和redo log、binlog以后就算提交成功了，并不需要写真正的数据文件。为了保证2个日志文件都写入成功，采用了两阶段提交的方法，如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/两阶段提交.svg&quot; alt=&quot;两阶段提交&quot; /&gt;&lt;/p&gt;

&lt;p&gt;两阶段提交并不是MySQL特有的，它是一种通用的分布式处理策略。其本质说来也很直白，就是一个人的时候好办，人多的时候，为了保持大家步调一致，每个人准备好以后吼一声，都准备好了再继续下一步。&lt;/p&gt;

&lt;p&gt;这里有个细节，当  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_flush_log_at_trx_commit=1&lt;/code&gt; 时，在redo log的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepare&lt;/code&gt; 阶段就会fsync一次。然后再写binlog，再将redo log 的标识设为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commit&lt;/code&gt;（&lt;strong&gt;但是这个阶段只会write 到page cache 中，不再需要fsync了，因为有后台定时线程：每1秒会fsync一次；和崩溃恢复逻辑：prepare的redo log 加上完整的binlog即可保证事务的持久性和一致性&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;两阶段提交如何保证-crash-safe&quot;&gt;两阶段提交如何保证 crash-safe？&lt;/h3&gt;

&lt;h4 id=&quot;crash-safe具体提供了什么能力&quot;&gt;crash-safe具体提供了什么能力？&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;只要客户端收到事务成功的消息，事务就一定持久化了&lt;/li&gt;
  &lt;li&gt;只要客户端收到事务失败的消息，事务就一定失败了&lt;/li&gt;
  &lt;li&gt;如果客户端收到“执行异常”之类的消息，需要应用重连后查询当前状态来执行后续逻辑。数据库内部只要保证数据和日志、主库和备库之间一致就行了&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;具体如何实现&quot;&gt;具体如何实现？&lt;/h4&gt;

&lt;p&gt;在崩溃恢复时，检查 redo log 和 binlog 的状态，如果：&lt;/p&gt;

&lt;p&gt;1、redo log 状态为commit，直接提交事务&lt;/p&gt;

&lt;p&gt;2、redo log 状态为prepare，查看对于的binlog是否完整：&lt;/p&gt;

&lt;p&gt;​	  a.  不完整，回滚&lt;/p&gt;

&lt;p&gt;​      b.  完整，提交事务&lt;/p&gt;

&lt;h4 id=&quot;如何知道binlog是否完整&quot;&gt;如何知道binlog是否完整？&lt;/h4&gt;

&lt;p&gt;完整的binlog最后会有个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XID EVENT&lt;/code&gt; 和  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COMMIT&lt;/code&gt;&lt;img src=&quot;/blog/img/image-20211029160948653.png&quot; alt=&quot;image-20211029160948653&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外，还提供了一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog-checksum&lt;/code&gt; 参数用于校验binlog的完整性。&lt;/p&gt;

&lt;h4 id=&quot;redo-log-是怎么和-binlog-对应起来的&quot;&gt;redo log 是怎么和 binlog 对应起来的？&lt;/h4&gt;

&lt;p&gt;它们都有一个共同的字段 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XID&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;为什么要引入两个日志只用binlog-不就行了&quot;&gt;为什么要引入两个日志，只用binlog 不就行了？&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;很重要的一点：binlog不具备 crash-safe 的能力。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、binlog 中没有checkpoint，不能区分哪些是已经落盘到磁盘数据文件（即最终存储数据的文件），哪些是需要应用到内存中用于崩溃恢复的&lt;/p&gt;

&lt;p&gt;2、binlog中存储的是逻辑日志，即sql级别的语句。redo-log中存储的是物理日志，即数据页级别的改动。一个sql语句可能会更改到好几个数据页，如果单个数据页损坏，binlog是没有能力恢复单个数据页的，它只能应用整个sql语句。比如一个sql语句同时更改了ABC三个数据页，更新的时候发生了crash，B数据页没有正常更新，AC正常更新。如果使用binlog来恢复，它只能同时恢复ABC三个数据页，结果就是B恢复了，AC又不对了。简而言之，binlog粒度太大。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;为什么要写2个日志直接更新数据文件不是更快吗&quot;&gt;为什么要写2个日志，直接更新数据文件不是更快吗？&lt;/h1&gt;

&lt;p&gt;这种思路叫做 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write ahead log&lt;/code&gt;，简称 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WAL&lt;/code&gt;，是数据库的通用技术，主要基于以下两点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;顺序写快于随机写。写日志文件都是顺序写，而直接更新数据文件大多数都是随机写，在机械硬盘时代这个速度差异非常大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虽然是写2个日志，看似意味着一次事务提交要经历两次刷盘，实际上利用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;组提交&lt;/code&gt; 的策略，fsync 的次数会大大减少，而write 到 操作系统page cache 基本上可以认为和写到内存差不多，可认为只有 fsync 会占用磁盘的 IOPS。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;组提交&quot;&gt;组提交&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;写binlog在是实现上其实也分为两步：write 和 fsync&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这里 MySQL 做了一个优化：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;拖时间&lt;/code&gt;。即&lt;strong&gt;将redo log 的 fsync 放到了 binlog的 write 之后、fsync之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这样的话，由于redo log write 完之后没有立即 fsync，而是等了一步：等binlog write完，所以有机会可以积累更多的redo log 到 page cache中，然后再一并进行 fsync。如下图所示，在两阶段提交的图上进一步细化：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/img/5ae7d074c34bc5bd55c82781de670c28.webp&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与此同时，也给了binlog  组提交的机会，因为binlog fsync 之前要等待redo log fsync。但是由于通常情况下 redo log fsync会很快，所以binlog 组提交的效果不如 redo log 的明显。但是可以通过调整以下参数优化：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_group_commit_sync_delay&lt;/code&gt;：表示延迟多少微秒以后才调用 fsync&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_group_commit_no_delay_count&lt;/code&gt;：表示积累多少次以后才调用 fsync&lt;/p&gt;

&lt;p&gt;两者是或的关系，当第一个参数为0时，表示不延迟，直接fsync，状态为true，则不再考虑第二个参数的设置了。&lt;/p&gt;

&lt;p&gt;组提交与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync_binlog&lt;/code&gt; 不冲突，可一起使用。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_group_commit_sync_delay&quot;&gt;参考：mysql8 doc binlog_group_commit_sync_delay&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;如何提高mysql的io性能&quot;&gt;如何提高MySQL的IO性能？&lt;/h1&gt;

&lt;p&gt;从提高写redo log 和 binlog 的性能入手。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;redo log&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;增大redo log buffer 大小&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;尤其对于需要更新很多行的大事务，大的redo log buffer 意味着事务提交前不会由于buffer满了而需要先写到磁盘上&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增大redo log file 大小和个数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_flush_log_at_trx_commt&lt;/code&gt; 设为2，表示每次事务提交都只 write 到 page cache，由后台定时线程来fsync。这样做的风险是主机掉电重启后会丢失数据（正常关闭不影响，MySQL在正常关闭前会完成一系列收尾工作）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​		&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-logging.html&quot;&gt;参考：Optimizing InnoDB Redo Logging&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;binlog&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync_binlog&lt;/code&gt; 设为大于1的值（通常是100-1000），这样做的风险是主机掉电会丢失binlog日志&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调整 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_group_commit_sync_delay&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_group_commit_no_delay_count&lt;/code&gt;，提高binlog组提交效率，减少写盘次数。&lt;u&gt;这样做会增加语句的响应时间，但是不会有丢失数据的风险&lt;/u&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;增大 buffer pool 大小&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;buffer pool 是用来缓存表数据的内存，默认值是128M，增大这个值可以显著减少磁盘IO。&lt;/p&gt;

&lt;p&gt;如果是数据库专用服务器，可以把 buffer pool 设为物理内存的 80%。&lt;/p&gt;

&lt;p&gt;当 buffer pool 大小超过1G，建议同时把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_buffer_pool_instances&lt;/code&gt; 设为大于1的值。相当于把 buffer pool 划分为了多个区域，可提高并发度。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size&quot;&gt;参考：mysql8 doc innodb_buffer_pool_size&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;sql语句突然变慢了&quot;&gt;sql语句突然变慢了？&lt;/h1&gt;

&lt;p&gt;有时会遇到这种情况，一条sql平时执行都很快，但有时候不知道为什么突然就变得很慢，而且这个情况还是随机的、持续时间也很短，很难复现。&lt;/p&gt;

&lt;p&gt;突然变慢的这一瞬间很有可能是MySQL&lt;strong&gt;在刷脏页&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;以下4种情况会引发刷脏页：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当需要读入新的内存页时，如果系统内存不足，就需要淘汰旧的数据页。如果淘汰的是脏页，就需要把脏页刷到磁盘。当一次淘汰的脏页太多时，就会明显影响性能。&lt;/li&gt;
  &lt;li&gt;redo log 写满了。此时需要把 checkpoint 到 write pos 之间的redo log对应的脏页刷到磁盘，并把 checkpoint 往前推进。&lt;strong&gt;这种情况是很严重的，此时MySQL将不再接受更新，所有更新都会堵住。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;后台任务 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;purge&lt;/code&gt; 会在系统空闲时刷脏页。&lt;/li&gt;
  &lt;li&gt;MySQL正常关闭时。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;解决思路：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主要解决前两种情况，后两种情况不会影响到系统性能。&lt;/p&gt;

&lt;p&gt;对于情况二，调整 redo log 的大小即可，默认值明显太小，上文有讲过。&lt;/p&gt;

&lt;p&gt;对于情况一，除了上面提到过的 buffer pool，还需要先了解下Innodb刷脏页的控制策略和相关参数。&lt;/p&gt;

&lt;p&gt;这里主要的参数是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt;，从名字就可以看出是控制 IO 能力的，官方描述如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_io_capacity&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt;&lt;/a&gt; variable defines the number of I/O operations per second (IOPS) available to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InnoDB&lt;/code&gt; background tasks, such as &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_flush&quot;&gt;flushing&lt;/a&gt; pages from the &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_buffer_pool&quot;&gt;buffer pool&lt;/a&gt; and merging data from the &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_change_buffer&quot;&gt;change buffer&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单说就是设置 IOPS，&lt;strong&gt;它用来告诉 Innodb 所在主机的 IO 能力&lt;/strong&gt;，用于后台任务刷脏页和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;。默认值是&lt;strong&gt;200&lt;/strong&gt;，即 Innodb &lt;strong&gt;全力&lt;/strong&gt;刷脏页可以达到 200 IOPS。这个值明显太低了，即便是对于机械硬盘。&lt;/p&gt;

&lt;p&gt;当然，Innodb 不会完全按照这个值去刷脏页，因为系统还需要处理服务请求。&lt;strong&gt;Innodb的做法是会算出一个百分比，然后按 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt; 定义的能力乘以这个百分比来控制刷脏页的速度&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;百分比的大致算法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;根据当前脏页比例再结合 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_max_dirty_pages_pct(脏页比例上限，默认值是90)&lt;/code&gt; 算出一个 0到100 之间的数字&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;脏页比例可通过下面命令得到：&lt;/p&gt;

      &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLE_VALUE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;global_status&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLE_NAME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Innodb_buffer_pool_pages_dirty&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLE_VALUE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;global_status&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLE_NAME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Innodb_buffer_pool_pages_total&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/div&gt;

      &lt;p&gt;计算方法伪代码如下，M 为当前脏页比例：&lt;/p&gt;

      &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;F1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;innodb_max_dirty_pages_pct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;innodb_max_dirty_pages_pct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/div&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;InnoDB 每次写入的日志都有一个序号(LSN)，当前写入的序号跟 checkpoint 对应的序号之间的差值，假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，N 越大，算出来的值越大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;取2值较大者作为百分比&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从这个过程可以看出，可以介入的部分就是两个参数：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_max_dirty_pages_pct&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;建议设置为磁盘的IOPS，磁盘的IOPS可以通过下面的命令来测试，一般参考测试结果中 write 的能力来设置：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;fio &lt;span class=&quot;nt&quot;&gt;-filename&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$filename&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-direct&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 &lt;span class=&quot;nt&quot;&gt;-iodepth&lt;/span&gt; 1 &lt;span class=&quot;nt&quot;&gt;-thread&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-rw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;randrw &lt;span class=&quot;nt&quot;&gt;-ioengine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;psync &lt;span class=&quot;nt&quot;&gt;-bs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16k &lt;span class=&quot;nt&quot;&gt;-size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;500M &lt;span class=&quot;nt&quot;&gt;-numjobs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10 &lt;span class=&quot;nt&quot;&gt;-runtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10 &lt;span class=&quot;nt&quot;&gt;-group_reporting&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mytest 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;注意：一定要熟悉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fio&lt;/code&gt; 的使用方法，否则可能会把盘都刷了！！！注意，注意，注意，危险的事情说三遍！！！&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;参考：&lt;a href=&quot;https://blog.51cto.com/shaonian/2319175&quot;&gt;&lt;strong&gt;fio 命令入门到跑路&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_max_dirty_pages_pct&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;从上面的伪代码可以看出，当脏页比例≥该参数值时，第一个参数为100；否则取脏页比例/该参数值的百分比。MySQL8.0以后该值默认为90，也就是说当脏页比例≥90时，会百分百按 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt;  的能力&lt;strong&gt;全力&lt;/strong&gt;刷脏页。为了尽量避免因刷脏页引起的抖动，应经常关注脏页比例，不要让它经常接近90%。或者可以调高一点(其实该值已经调整过了，之前是75，8.0后调为了90。90已经接近100了，可认为该值是一个很合理的值，如果脏页累计过多，刷脏页就会很频繁)。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，还有一个参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_flush_neighors&lt;/code&gt;，从参数名字可以看出大概意思：刷脏页的时候是只刷自己还是连着附近的脏页也一起刷了，1表示启用，0表示只刷自己。&lt;/p&gt;

&lt;p&gt;这个机制对于传统机械硬盘很有用，机械硬盘的IOPS一般只有几百，每次多刷一些可以减少很多随机IO。而SSD的随机IO已不是瓶颈，只刷自己反而会更快些。在MySQL8.0中，该参数的默认值已为0，表示只刷自己。&lt;/p&gt;
</description>
        <pubDate>Sat, 28 Aug 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/08/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-redo-log-%E5%92%8C-binlog/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/08/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-redo-log-%E5%92%8C-binlog/</guid>
        
        <category>mysql</category>
        
        <category>redo</category>
        
        <category>binlog</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(二)：MySQL权限控制</title>
        <description>&lt;p&gt;MySQL权限可分为全局级、数据库级、表级、列级、子程序级（函数、存储过程）&lt;/p&gt;

&lt;h3 id=&quot;全局级&quot;&gt;全局级&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数据库级&quot;&gt;数据库级&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;表级&quot;&gt;表级&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tables_priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;列级&quot;&gt;列级&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;columns_priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;子程序级&quot;&gt;子程序级&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;procs_priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;查询用户拥有权限&quot;&gt;查询用户拥有权限&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grants&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localhost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;示例&quot;&gt;示例&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;创建用户&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;identified&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt;  &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;授予全局级查询权限&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;授予数据库级查询权限&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;授予表级查询权限&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;授予列级权限（只能查询&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;表的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;字段）&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;撤销权限&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;revoke&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;刷新权限&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;privileges&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 23 Aug 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/08/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-MySQL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/08/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-MySQL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
  </channel>
</rss>
