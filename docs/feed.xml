<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coding Life</title>
    <description>这是一个Java程序员的博客 | Java Blog</description>
    <link>http://localhost:4000/blog/</link>
    <atom:link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 02 Dec 2021 15:31:28 +0800</pubDate>
    <lastBuildDate>Thu, 02 Dec 2021 15:31:28 +0800</lastBuildDate>
    <generator>Jekyll v4.2.1</generator>
    
      <item>
        <title>MySQL学习笔记(十)：count</title>
        <description>&lt;h1 id=&quot;count-的实现方式&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt; 的实现方式&lt;/h1&gt;

&lt;p&gt;不同引擎实现方式不同：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;MyISAM：将总行数直接存在磁盘上，查询的时候返回，因此速度很快&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Innodb：因为需要支持事务，而事务是由 MVCC 实现的，一行记录需要先判断对查询事务的可见性，所以&lt;strong&gt;“应该返回多少行” 是不确定的&lt;/strong&gt;。因此Innodb的实现方式是把数据一行一行的从引擎中读出来，可见的行才会被累计进来。&lt;/p&gt;

    &lt;p&gt;举个例子，假设表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 有 10000 条数据：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionC&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select count(*) from t;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;insert into t(插入一行);&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;insert into t(插入一行);&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select count(*) from t; &lt;strong&gt;(返回10000)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select count(*) from t; &lt;strong&gt;(返回10002)&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select count(*) from t; &lt;strong&gt;(返回10001)&lt;/strong&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;可见同一时刻的并发查询，返回的结果是不一致的。&lt;/p&gt;

    &lt;p&gt;由于需要遍历全表，因此对于大表，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt; 会变得很慢。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;为-count-提速&quot;&gt;为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt; 提速&lt;/h1&gt;

&lt;h3 id=&quot;用缓存保存计数&quot;&gt;用缓存保存计数&lt;/h3&gt;

&lt;p&gt;这是第一时间会想到的方式，比如使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt;。更新数据时顺便更新 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt;中的计数值，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt; 的时候直接查询 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 即可，速度很快。&lt;/p&gt;

&lt;p&gt;但是这会有2个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;缓存异常宕机会丢失更新&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;redis持久化有RDB和AOF两种方式；RDB按照备份策略，比如60秒1000个k-v被修改，备份过程中宕机，那么这个阶段的所有更新都会丢失；AOF按照备份策略，比如 appendfsync always 策略，同步记录所执行的指令到日志文件，但是它的日志和mysql的WAL(先写日志)不同，它是后写日志，可能指令执行后写日之前宕机，那这个数据就丢失了，虽然丢失数据较少且概率较低，但依然存在这个可能。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;可以在重启后到数据库中执行一次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt;获取行数后填到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 中，毕竟异常宕机重启不会经常发生，偶尔一次全表扫描的成本还是可以接受的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结果可能不准&lt;/p&gt;

    &lt;p&gt;由于更新数据和更新 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 统计计数不是一个原子操作，可能会出现统计计数和数据不一致的问题。&lt;/p&gt;

    &lt;p&gt;比如以下场景：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 计数+1&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;读 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 计数&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;查询近100条记录&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;插入一行数据&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;sessionB 在查询计数时已经加了1，但是查不到新插入的数据(将sessionA的两个操作调换顺序也是类似的)。究其原因， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 和数据库可以看做两个不同的数据源，不能保证两个操作的原子性(不可分割)。这类问题属于分布式一致性问题，虽可通过引入其他手段解决，但会使一个简单的计数查询需求变得很复杂，没有必要。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;在数据库保存计数&quot;&gt;在数据库保存计数&lt;/h3&gt;

&lt;p&gt;那不存到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt;  中，存到数据库计数表中，会出现上面的问题吗？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先，Innodb 支持崩溃恢复，所以不存在更新丢失的问题。&lt;/li&gt;
  &lt;li&gt;将上图中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt;  的操作换成对数据库计数表的操作，不会出现数据不一致的问题。很明显，Innodb的事务保证了操作的原子性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，&lt;strong&gt;对于大表，推荐使用数据库计数表来提速 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt;&lt;/strong&gt; 。&lt;/p&gt;

&lt;h4 id=&quot;进一步优化&quot;&gt;进一步优化&lt;/h4&gt;

&lt;p&gt;根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;两阶段锁&lt;/code&gt; 协议，可以通过调整事务内更新语句的顺序：&lt;strong&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 计数表放到最后&lt;/strong&gt;，来减少计数表行锁等待的时间，提高并发度。&lt;/p&gt;

&lt;h1 id=&quot;不同-count-用法的区别&quot;&gt;不同 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt; 用法的区别&lt;/h1&gt;

&lt;p&gt;首先，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt; 是一个聚合函数，它的逻辑是，&lt;strong&gt;对于返回的结果集，一行一行的判断，不为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 就+1&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;count(主键id)&lt;/p&gt;

    &lt;p&gt;遍历整张表，把每一行的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 取出来返回给 server 层，server 层判断 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 不可能为空，+1。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这里可能会觉得奇怪，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 根本不可能为空，为什么还要多此一举去判断一下。&lt;/p&gt;

      &lt;p&gt;的确是没什么必要，但类似需要优化的地方太多了，MySQL专门对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt; 优化过了，直接使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt;  就好了。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;count(1)&lt;/p&gt;

    &lt;p&gt;遍历整张表，但不取值。Server 层对于返回的每一行，放一个 “1“ 进去，判断不可能为空，+1。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;很明显，相较于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(主键id)&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(1)&lt;/code&gt; 效率更高，因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(id)&lt;/code&gt;  还需要解析数据行、拷贝字段值等操作。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;count(字段)&lt;/p&gt;

    &lt;p&gt;遍历整张表，把每一行对应的字段值取出来返回给 server 层，server 层判断是否为空，不为空+1。所以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(字段)&lt;/code&gt; ≤ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;count(*)&lt;/p&gt;

    &lt;p&gt;做了专门的优化，并不会把全部字段取出来，而是直接不取值，认定&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt; 肯定不为空，直接按行累加。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;按效率排序：count(字段) &amp;lt; count(主键id) &amp;lt; count(1) ≈ count(*)。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐直接使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(*)&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/10/22/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81)-count/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/10/22/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81)-count/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(九)：如何收缩表空间?</title>
        <description>&lt;h3 id=&quot;使用-delete-删除数据不会使表空间变小&quot;&gt;&lt;strong&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 删除数据不会使表空间变小&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;前文有提过，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 只是将记录标记为删除，并没有真正删除。只有当其对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update undo logs&lt;/code&gt; 被清除时才会由后台 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;purge&lt;/code&gt; 任务物理删除，&lt;u&gt;即没有事务再需要这些版本的记录时&lt;/u&gt;会执行物理删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;即便是物理删除，也不会把磁盘空间返还给操作系统。&lt;/strong&gt;究其原因，出于性能考虑，物理删除后的空间会被&lt;strong&gt;复用&lt;/strong&gt;。删除记录后，当插入符合范围条件的数据时，原空间会被复用。删除一整个数据页上的所有记录后，当需要使用新页的时候，原数据页会被复用。&lt;/p&gt;

&lt;p&gt;可通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show table status like &apos;t&apos;&lt;/code&gt; 来查看表碎片大小，如果过大，可通过重建表来释放表空间。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;几个字段的含义，都是针对 Innodb，MyISAM略有不同：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data_length&lt;/code&gt;：聚簇索引大小近似值，单位是字节。&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;index_length&lt;/code&gt;：非聚簇索引大小近似值，单位是字节。&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data_free&lt;/code&gt;：已分配但未使用的空间大小近似值，单位是字节。表碎片大小即是查看这个字段。&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;这三个值之和近似接近 ibd 文件大小。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;重建表&quot;&gt;重建表&lt;/h3&gt;

&lt;p&gt;不光删除数据会造成&lt;strong&gt;空洞&lt;/strong&gt;(可被复用但没被使用的空间)，插入和更新也会。&lt;/p&gt;

&lt;p&gt;因为插入数据往往都是随机的，即&lt;strong&gt;基本不可能按索引递增顺序插入&lt;/strong&gt;，就很有可能造成数据页的分裂。比如当一个数据页满了，此时再插入一行数据到此节点就会造成数据页分裂，原数据页末尾就会产生空洞。&lt;/p&gt;

&lt;p&gt;更新可理解为先删除后插入，同理。&lt;/p&gt;

&lt;p&gt;重建表就是通过&lt;strong&gt;去掉这些空洞，来达到收缩表空间的目的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;命令如下：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;56版本之前&quot;&gt;5.6版本之前&lt;/h4&gt;

&lt;p&gt;内部流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新建一张与原表结构相同的临时表&lt;/li&gt;
  &lt;li&gt;按主键ID递增的顺序，将数据一行一行的从原表读出来再插入到临时表中。&lt;strong&gt;这一步就可以去掉原表主键索引上的空洞。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;用临时表替换掉原表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个流程有个问题，在第2步中，原表不能有更新操作。也就是说，这个ddl不是online的。&lt;/p&gt;

&lt;h4 id=&quot;从56版本开始&quot;&gt;从5.6版本开始&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;建立一个临时文件，扫描原表的所有数据页&lt;/li&gt;
  &lt;li&gt;用数据页中原表的记录生成B+树，存储到临时文件中&lt;/li&gt;
  &lt;li&gt;在生成临时文件的过程中，将对原表的操作记录在一个日志文件(row log)中&lt;/li&gt;
  &lt;li&gt;临时文件生成后，将日志文件中的操作应用到临时文件&lt;/li&gt;
  &lt;li&gt;用临时文件替换掉原表的数据文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;很明显，在该过程执行中是允许对原表做增删改操作的，&lt;strong&gt;这也是 Online DDL 名字的由来&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;u&gt;注意&lt;/u&gt;&lt;/strong&gt;：对于大表来说，因为需要扫描原表数据和构建临时文件，这个步骤是很消耗IO和CPU资源的。尤其对于线上业务，要很小心的&lt;strong&gt;控制操作时间&lt;/strong&gt;。如果想要安全操作的话，推荐使用 github 的 &lt;a href=&quot;https://github.com/github/gh-ost&quot;&gt;gh-ost&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;online-和-inplace&quot;&gt;online 和 inplace&lt;/h3&gt;

&lt;p&gt;online ddl 构建的临时文件位于 Innodb 内部，整个过程也都是在 Innodb 内部完成。&lt;strong&gt;对于 Server 层来说&lt;/strong&gt;，没有把数据挪动到临时表(5.6版本之前的操作流程)，相当于是一个 “原地” 操作，因此叫做 &lt;strong&gt;inplace&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;其实隐含的意思是&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ALGORITHM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inplace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相对的，就有&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ALGORITHM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对应的就是5.6版本之前的操作流程。&lt;/p&gt;

&lt;p&gt;所以，如果现在有一个1TB的表，磁盘空间为1.2TB，能不能做一个inplace的ddl呢？&lt;/p&gt;

&lt;p&gt;答案是不能，因为临时文件也是要占用空间的。&lt;/p&gt;

&lt;p&gt;总结来说，online 是指在操作过程会不会阻塞对原表的增删改操作。inplace 指的是在 Serve 层建临时表还是直接在存储引擎内建临时文件。&lt;/p&gt;

&lt;h3 id=&quot;两种重建表的方式及区别&quot;&gt;两种重建表的方式及区别&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alter table A engine=InnoDB&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;如上文所述&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;optimize table A&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;等同于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alter table A engine=InnoDB&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;analyze table A&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;analyze&lt;/code&gt;：重新统计索引信息)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;什么情况下重建表空间反而变大了&quot;&gt;什么情况下重建表空间反而变大了？&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;表本身已经没有空洞了，比如刚刚重建过一次，这时候再重建，如果恰好在重建期间有外部的 DML 在执行，就有可能会引入新的空洞。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;而且重建表的时候并不是把每个数据页都占满，而是会留下 $1/16$ 的&lt;strong&gt;预留空间&lt;/strong&gt;给后续的更新用，也就是说重建后的表并不是百分百紧凑的。&lt;/p&gt;

    &lt;p&gt;以下过程就可能会出现这种情况：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;重建一次&lt;/li&gt;
      &lt;li&gt;插入一部分数据，但是这部分数据使用的是预留空间&lt;/li&gt;
      &lt;li&gt;再重建一次。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;这时由于预留空间被使用了，再次重建时就需要再额外留出 $1/16$ 的预留空间，所以空间反而变大了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 20 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/10/20/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B9%9D)-%E5%A6%82%E4%BD%95%E6%94%B6%E7%BC%A9%E8%A1%A8%E7%A9%BA%E9%97%B4/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/10/20/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B9%9D)-%E5%A6%82%E4%BD%95%E6%94%B6%E7%BC%A9%E8%A1%A8%E7%A9%BA%E9%97%B4/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(八)：MySQL锁</title>
        <description>&lt;p&gt;&lt;strong&gt;MySQL中的锁有三类：全局锁、表级锁、行级锁&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;全局锁&quot;&gt;全局锁&lt;/h3&gt;

&lt;p&gt;即给整个数据库实例上锁，让整个库都处于只读状态，除查询以外的操作都会被阻塞。server层实现。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果加上全局锁后，客户端由于异常断开，MySQL会自动释放这个锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;加锁：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;解锁：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tables&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用场景：做全库逻辑备份&lt;/p&gt;

&lt;p&gt;隐患：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;由于只能查询，所以在此期间业务基本停摆&lt;/li&gt;
  &lt;li&gt;如果在主库上备份，业务停摆；如果在备库上备份，在此期间备库不能执行从主库同步过来的 binlog，会导致主从延迟&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那如果备份的时候不加全局锁会发生什么情况呢？&lt;/p&gt;

&lt;p&gt;不加锁，&lt;strong&gt;会导致备份出来的库不是同一个逻辑时间点的&lt;/strong&gt;，数据从业务逻辑上看是不一致的。&lt;/p&gt;

&lt;p&gt;比如在备份过程中先备份了A表，然后执行了一个业务操作，再备份B表，这个业务操作会同时更新A表和B表。那么这个时候备份出来的数据A表还是老版本，而B表已经被更新了，这个备份就是有问题的，是逻辑不一致的。&lt;/p&gt;

&lt;p&gt;&lt;u&gt;为了既不影响业务，也要保证备份视图的逻辑一致性&lt;/u&gt;，推荐采用另一种全库备份的方法：&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysqldump -single-transaction&lt;/code&gt;&lt;/strong&gt;。导数据之前会启动一个事务，来确保拿到一致性视图。而且由于 MVCC 的支持，在此期间是可以正常更新的。&lt;/p&gt;

&lt;p&gt;当然显而易见，这种方法只适用于支持事务的存储引擎，所以这也是为什么推荐使用 Innodb 而不是 MyISAM 的一个原因。&lt;/p&gt;

&lt;h3 id=&quot;表级锁&quot;&gt;表级锁&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;server层实现，分两种：表锁和元数据锁(MDL)。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;表锁&quot;&gt;表锁&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;与全局锁一样，也会在客户端断开时自动释放&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;加锁：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tables&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;解锁：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tables&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上述加锁语句为例，t1加了读锁，t2加了写锁：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任何线程都不能写 t1 ，包括本线程&lt;/li&gt;
  &lt;li&gt;只有本线程能读写 t2&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本线程甚至不能访问除 t1、t2 之外的任何表&lt;/strong&gt;，这点很奇怪，不懂为什么这么设计&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;元数据锁&quot;&gt;元数据锁&lt;/h4&gt;

&lt;p&gt;Meta data lock，MDL&lt;/p&gt;

&lt;p&gt;不需要显示使用，访问表的时候会自动加上。&lt;/p&gt;

&lt;p&gt;从MySQL5.5开始引入，&lt;strong&gt;当做增删查改时，会加MDL读锁；当变更表结构时，会加MDL写锁&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;读锁不互斥，因此可以有多个线程同时对一张表增删改查&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读写互斥，即不能有多个线程同时更改表结构，或一个线程在增删改查而另一个线程在更改表结构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MDL锁在事务提交时才会释放，在变更表结构时要特别小心，以免锁住线上的查询和更新，导致整张表不能读写。下面是一个示例：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;session A&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;session B&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;session C&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;session D&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select * from t limit 1;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select * from t limit 1;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;alter table t add f int;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;select * from t limit 1;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;session A 先开启了一个事务，执行了一次查询，并且没有马上提交，这时会对表 t 加一个 MDL 读锁。&lt;/p&gt;

    &lt;p&gt;session B 也需要一个 MDL 读锁，读锁之间不互斥，可以正常执行查询。&lt;/p&gt;

    &lt;p&gt;session C 要加一个字段，需要一个 MDL 写锁，读锁和写锁互斥，所以必须等待表 t 释放读锁之后才能继续。&lt;/p&gt;

    &lt;p&gt;session D 需要一个读锁，这里需要注意的是，&lt;strong&gt;表 t 上会有一个等待获取锁的锁队列，而获取MDL写锁的优先级要比获取读锁的优先级高&lt;/strong&gt;，所以导致session D 也被阻塞。&lt;/p&gt;

    &lt;p&gt;最后的结果就是表 t 完全被锁住，完全不可读写了。如果客户端还有重试机制，一直在发起重试请求，MySQL的线程很快就会爆满，最后导致整个实例挂掉。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​		解决办法：&lt;/p&gt;

&lt;p&gt;​		1、监控长事务(information_schema.innodb_trx)，要么先暂停DDL，要么kill掉这个长事务&lt;/p&gt;

&lt;p&gt;​		2、但是对于一些热点表，kill未必管用，可能刚kill掉一个长事务，新的请求立马又来了。这种情况下，理想的办法是为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alter table&lt;/code&gt; 语句设定等待时间，如果在此期间能拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后再重试这个命令来重试这个过程。MariaDB 和 AliSQL 已经提供了这个功能，MySQL暂时没有。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOWAIT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WAIT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;MySQL可以通过调整 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock_wait_timeout&lt;/code&gt;&lt;/strong&gt; 值来控制这个超时时间，默认值是 31536000s，即1年，显然这个时间太长了。&lt;/p&gt;

&lt;h3 id=&quot;案例一&quot;&gt;案例一&lt;/h3&gt;

&lt;p&gt;假如正在备库执行一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-single-transaction&lt;/code&gt; 的逻辑备份，此时在主库上对表 t 执行了一个 DDL，备库会出现什么情况？&lt;/p&gt;

&lt;p&gt;备库会根据 DDL 的 binlog 到达的时间点不同而出现不同的情况。&lt;/p&gt;

&lt;p&gt;先拆解一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysqldump -single-transaction&lt;/code&gt; 在内部的执行逻辑：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;set session transaction isolation level repeatable read;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;start transaction with consistent snapshot;&lt;/p&gt;

    &lt;p&gt;(其他表的备份逻辑)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SAVEPOINT sp;&lt;/p&gt;

    &lt;p&gt;(时刻1)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;show create table &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;;&lt;/p&gt;

    &lt;p&gt;(时刻2)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;select * from t;&lt;/p&gt;

    &lt;p&gt;(时刻3)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;rollback to savepoint sp;&lt;/p&gt;

    &lt;p&gt;(时刻4)&lt;/p&gt;

    &lt;p&gt;(其他表的备份逻辑)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在时刻1到达：没有任何影响，此时表 t 上没有任何 MDL 锁，所以可正常执行，备份得到的是新的表结构；&lt;/p&gt;

&lt;p&gt;在时刻2到达：此时已经先备份完了 t 的表结构，DDL才到达，在执行第5步的时候会报错：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Table definition has changed,please retry transaction&lt;/code&gt; ，mysqldump 终止；&lt;/p&gt;

&lt;p&gt;在时刻3到达：此时表结构和数据都已备份完成，但是 MDL 读锁还没释放(会在第6步后才释放)，所以 DDL 操作会阻塞，备份得到的是旧的表结构；&lt;/p&gt;

&lt;p&gt;在时刻4到达：MDL 读锁已被释放，DDL 可正常执行，备份得到的是旧的表结构。&lt;/p&gt;

&lt;h3 id=&quot;行锁&quot;&gt;行锁&lt;/h3&gt;

&lt;p&gt;由存储引擎实现，Innodb 支持，MyISAM 不支持。如果不支持行锁，就只能使用表级锁，也就意味着锁的粒度太大并发度就会降低。这也是为什么推荐使用 Innodb 的重要原因之一。&lt;/p&gt;

&lt;h4 id=&quot;两阶段锁&quot;&gt;两阶段锁&lt;/h4&gt;

&lt;p&gt;之前提到过一个两阶段提交，行锁有一个&lt;strong&gt;两阶段锁&lt;/strong&gt;协议，也被称为 2PL。&lt;/p&gt;

&lt;h5 id=&quot;定义&quot;&gt;定义&lt;/h5&gt;

&lt;p&gt;两阶段指的是分为加锁阶段和解锁阶段，在加锁阶段只能加锁不能解锁，在解锁阶段只能解锁不能加锁。&lt;/p&gt;

&lt;p&gt;单看定义很难理解，换成大白话说就是&lt;strong&gt;行锁在需要的时候才加上，但并不是不需要了就立即释放，而是要事务结束后才会释放。&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;为什么需要两阶段锁&quot;&gt;为什么需要两阶段锁？&lt;/h5&gt;

&lt;p&gt;重点就是在事务结束后才会释放所有行锁，而不是用完立即释放。&lt;strong&gt;任何锁的本质就是保证并发操作的正确性，将并行改为串行&lt;/strong&gt;。二阶段锁用来保证并发更新操作的正确性，两个并发的更新操作，必须等其中一个提交后另一个才能继续，否则就&lt;strong&gt;会发生更新被覆盖的情况&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;假设不存在两阶段锁协议，会发生如下情况：&lt;/p&gt;

&lt;p&gt;同时发起2个操作，向同一个账户打200块，账户原余额有100块。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;sessionA 发起打款操作，获取到写锁，用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 更新账户余额为 300&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 完毕，假设不存在两阶段锁，用完立即释放，释放写锁，&lt;strong&gt;此时事务尚未提交&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;sessionB 发起打款操作，获取到写锁，根据一致性视图可见性规则：事务未提交，更新不可见。得到的账户余额仍为100，用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 更新账户余额为 300&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 完毕，立即释放写锁&lt;/li&gt;
  &lt;li&gt;sessionA 提交，账户余额为 300&lt;/li&gt;
  &lt;li&gt;sessionB 提交，账户余额为 300&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以，因为存在两阶段锁协议，在第2步结束后，由于事务尚未提交，写锁仍未释放，则第3步的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 操作必须等待 sessionA 提交后才能继续，此时 sessionA 读到的余额为300，再执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 后更新余额为500，这才是符合逻辑的结果。&lt;/p&gt;

&lt;h5 id=&quot;如何优化&quot;&gt;如何优化？&lt;/h5&gt;

&lt;p&gt;锁虽然保证了并发操作的正确性，但是由并行改为串行降低了并发度。所以另一个问题就是如何最大限度的提高并发度？&lt;/p&gt;

&lt;p&gt;由于行锁是在需要的时候才加上，在事务结束后统一释放。所以针对包含多个更新的事务，可以&lt;strong&gt;调整事务内更新语句的顺序，将会产生行锁竞争的语句尽量往后放，从而让等待行锁的时间最小化&lt;/strong&gt;，以达到提高并发度的目的。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;假如有一个在线订票业务，订票逻辑可以简化为下列步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从账户余额扣掉票钱&lt;/li&gt;
  &lt;li&gt;给系统余额加上票钱&lt;/li&gt;
  &lt;li&gt;记录一条日志&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;假设同时发起2个订票请求，可以看到，在这个事务中，会产生行锁竞争的是第2步(直白说就是会 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 同一行)。按这个顺序的话，系统余额表上的行锁会从第2步开始加上，第3步完成后事务提交时释放。&lt;/p&gt;

&lt;p&gt;调整下顺序，改为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;记录一条日志&lt;/li&gt;
  &lt;li&gt;从账户余额扣掉票钱&lt;/li&gt;
  &lt;li&gt;给系统余额加上票钱&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这时候系统余额表上的行锁持续时间就缩短为1步了，从第3步开始加上，到第3步完成后事务提交时释放。&lt;/p&gt;

&lt;p&gt;虽然在这里看就是少了一小步(一条语句的执行时间)，但如果这个业务请求并发量很大的话，这个优化的效果就会非常明显。&lt;/p&gt;

&lt;h4 id=&quot;死锁&quot;&gt;死锁&lt;/h4&gt;

&lt;h5 id=&quot;为什么会出现死锁&quot;&gt;为什么会出现死锁？&lt;/h5&gt;

&lt;p&gt;简单说就是出现&lt;strong&gt;锁的循环等待&lt;/strong&gt;。示例如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;begin;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k = k+1 where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k = k+1 where id=2;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k = k+1 where id=2;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k = k+1 where id=1;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;由于事务都尚未提交，行锁还未释放。第4步要获取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=2&lt;/code&gt; 的行锁，需要等待sessionB提交；第5步要获取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=1&lt;/code&gt; 行锁，需要等待sessionA提交，死锁产生了。&lt;/p&gt;

&lt;h5 id=&quot;解决办法&quot;&gt;解决办法&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h6 id=&quot;等待直到超时然后退出&quot;&gt;等待直到超时，然后退出&lt;/h6&gt;

    &lt;p&gt;Innodb中有个参数用于设置这个超时时间：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_lock_wait_timeout&lt;/code&gt;，默认值为 50s。这个默认值对于业务来说是不能接受的，相当于卡顿50s。但是如果设成较小的值，又很有可能造成误伤：如果不是死锁，而就是普通的锁等待，此时并没有循环等待的情况，但是由于超过了阈值而被当成了死锁而提前退出了。所以这种方法一般不采用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主动死锁检测&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_deadlock_detect&lt;/code&gt; 用于控制是否打开主动死锁检测，默认是 ON。&lt;/p&gt;

    &lt;p&gt;这是一种相对较好的方式，但&lt;strong&gt;需要注意的是它的资源消耗有可能会很大&lt;/strong&gt;。对于每个新加入进来的线程，都要先判断会不会由于自己的加入而导致死锁，这是一个时间复杂度为 O($n^2$) 的操作。假设有1000个并发线程同时更新同一行，这个死锁检测就是100万量级的。&lt;/p&gt;

    &lt;p&gt;虽然最终检测的结果是没有死锁，但此期间需要消耗大量的CPU资源。所以当出现CPU消耗接近100%，TPS却很低的话，很有可能就是死锁检测导致的。&lt;/p&gt;

    &lt;p&gt;那如何优化这种&lt;strong&gt;热点行更新问题&lt;/strong&gt;？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;简单粗暴的方法就是如果确认不会出现死锁，直接关闭死锁检测。但这个方法明显危险系数很高，万一还是出现了死锁的话只能依靠超时机制，而如上面所述，超时机制的阈值很难设置。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;拆分热点行&lt;/strong&gt;。将一行拆分为多行，比如一条账户记录可以拆分为10条子账户记录，账户总额就等于10条子账户余额之和，在需要更新账户余额时，随机选择其中一条进行更新。这样就将一行上的死锁检测成本、锁等待个数、冲突概率都降为了原来的1/10。这种方案属于设计层面上的优化，需要结合业务逻辑做详细的设计和测试。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;案例二&quot;&gt;案例二&lt;/h3&gt;

&lt;p&gt;现需要删除前10000行数据，有以下三种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在一个连接中循环执行20次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete from t limit 500;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在20个连接中同时执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete from t limit 500;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;哪种方式好一些？&lt;/p&gt;

&lt;p&gt;第一种：执行时间较长，意味着占用锁(MDL读锁、X锁)的时间会比较长；而且大事务在从库上回放的时间也较长，在此期间会导致主从延迟；&lt;/p&gt;

&lt;p&gt;第三种：人为的制造了行锁冲突，而且大概率会重复删除，达不到删除前10000行数据的目的；&lt;/p&gt;

&lt;p&gt;第二种方式较好。&lt;/p&gt;

</description>
        <pubDate>Mon, 18 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/10/18/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)-MySQL%E9%94%81/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/10/18/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)-MySQL%E9%94%81/</guid>
        
        <category>mysql</category>
        
        <category>锁</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(七)：MySQL索引</title>
        <description>&lt;h3 id=&quot;索引的常见实现方式有哪些&quot;&gt;索引的常见实现方式有哪些？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;哈希表：O(1) 的时间复杂度，速度最快，但缺点是只适用于等值查询。因为key是无序的，所以区间查询时只能全部遍历一遍。&lt;/li&gt;
  &lt;li&gt;有序数组：O(logn)的时间复杂度，利用二分法。可用于等值查询和区间查询，但插入删除时间复杂度较高，因为需要移动插入点后面的所有元素。所以有序数组比较适合静态存储引擎，即基本不会变的数据。&lt;/li&gt;
  &lt;li&gt;搜索树：常用实现是B+树。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;为什么采用b树而不是常见的二叉树&quot;&gt;为什么采用B+树而不是常见的二叉树?&lt;/h3&gt;

&lt;p&gt;二叉树即每个节点只有左右2个子节点，所以显而易见的问题就是当节点变多时树的高度会很高。比如需要存储100万条数据，就需要20层（n层二叉树的节点数为 $2^n-1$，20层二叉树的节点总数为1048576）。因为一个节点就是一页，那么一次查询很可能就需要进行20次随机IO（大概率会触发随机IO），在传统机械硬盘时代，一次随机IO大约10ms，那么单一次查询可能就需要200ms，这个查询是很慢的。&lt;/p&gt;

&lt;p&gt;所以解决办法就是增加树的子节点数，由二叉变为N叉。&lt;/p&gt;

&lt;p&gt;B+树就是一颗N叉树。一个节点就是一页，页是Innodb磁盘IO的基本单位，一页在Innodb中默认是16k，假如索引字段为整数类型占4个字节，每个key还有一个指向下一层节点的指针固定占6字节，再加上一些辅助字节总共差不多占13字节左右（非叶子节点）。16k/13=1260，那么一个节点就可以差不多有1200个分叉，一颗树高为4的B+树，就可以存 $1200^3≈17亿$ 个值。因为根节点总是在内存中，第二层大概率也在内存中，这时17亿数据量的单次查询页只需要进行2-3次磁盘IO，速度大大提高了。&lt;/p&gt;

&lt;p&gt;顺便说一下 Innodb 中B+树的特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;N叉树，即每个节点可以有多个key&lt;/li&gt;
  &lt;li&gt;内部节点不存储数据，只有指针，只在叶子节点存储数据&lt;/li&gt;
  &lt;li&gt;每一层页与页之间构成一个双向链表&lt;/li&gt;
  &lt;li&gt;页内 records 之间构成一个单向链表&lt;/li&gt;
  &lt;li&gt;叶子节点为第0层，从下往上递增，root为最大层数&lt;/li&gt;
  &lt;li&gt;一个节点就是一个page&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;innodb中的页是什么&quot;&gt;Innodb中的页是什么？&lt;/h3&gt;

&lt;h4 id=&quot;innodb表空间&quot;&gt;Innodb表空间&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;详见：&lt;a href=&quot;https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/&quot;&gt;The basics of InnoDB space file layout&lt;/a&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;Innodb的数据存储模型被称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;space&lt;/code&gt;，即“表空间”。表空间是一个逻辑概念，有一个32位的space ID，实际上可能由多个物理文件组成（如ibdata1、ibdata2）。表空间分为系统表空间（system space：ibdata1、ibdata2，space ID 为0）和表对应的表空间(per-table space：ibd文件)。ibd文件实际上是一个功能齐全的space，可以包含多张表，但在MySQL实现中一个ibd只对应一张表。&lt;/p&gt;

&lt;p&gt;每个space会被划分为多个page，一个page默认16k。page也有一个32位的page number（页号），表示在space内的偏移量（offset），比如page 0 对应 offset 为0，page 1 对应 offset 为16384。注意一个space可能包含多个文件，所以这个offset不一定是文件内的，而是整个space中的。Innodb单表空间最大为64TB，是因为 $2^{32} * 16k$。&lt;/p&gt;

&lt;h5 id=&quot;页的基本结构&quot;&gt;页的基本结构&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211112105252435.png&quot; alt=&quot;image-20211112105252435&quot; /&gt;&lt;/p&gt;

&lt;p&gt;页包含一个38字节的头部（FIL为File的缩写）和一个8字节的尾部，中间的内容取决于不同的page type，可用大小为 16k-38-8=16338。&lt;/p&gt;

&lt;p&gt;FIL Header 和 Trailer 结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211112105757234.png&quot; alt=&quot;image-20211112105757234&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，头部包含了&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Offset(Page Number)&lt;/li&gt;
  &lt;li&gt;Page Type&lt;/li&gt;
  &lt;li&gt;Space ID&lt;/li&gt;
  &lt;li&gt;指向前一页和后一页的指针，构成一个双向链表（树的同一层中）&lt;/li&gt;
  &lt;li&gt;最后一次改动页的LSN&lt;/li&gt;
  &lt;li&gt;当前系统中（所有space）最大的LSN&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;表空间space-file文件结构&quot;&gt;表空间(space file)文件结构&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211112125701387.png&quot; alt=&quot;image-20211112125701387&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;系统表空间system-space文件结构&quot;&gt;系统表空间(system space)文件结构&lt;/h5&gt;

&lt;p&gt;系统表空间(system space)的 space ID 为 0 。它采用了一些固定页号的页来存储一些关键信息。结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211112130023998.png&quot; alt=&quot;image-20211112130023998&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;单表空间per-table-space-file文件结构&quot;&gt;单表空间(per-table space file)文件结构&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211112130153515.png&quot; alt=&quot;image-20211112130153515&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Page3为聚簇索引(主键索引)的root，Page4为第一个二级索引的root，如果有多级索引的话以此类推。&lt;/p&gt;

&lt;h4 id=&quot;innodb索引&quot;&gt;Innodb索引&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;详见 &lt;a href=&quot;https://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/&quot;&gt;The physical structure of InnoDB index pages&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;一切皆索引&quot;&gt;一切皆索引&lt;/h5&gt;

&lt;p&gt;在Innodb中一切皆索引，意思是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每张表都有一个主键。如果没有手动指定，会使用第一个 not null 的 unique key。如果仍然没有，会自动分配一个6字节的隐藏 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Row ID&lt;/code&gt;作为主键。&lt;/li&gt;
  &lt;li&gt;主键索引树(聚簇索引)叶子节点key是主键值，value是是整行数据。&lt;/li&gt;
  &lt;li&gt;二级索引key是索引列的值，value是对应的主键值。&lt;/li&gt;
  &lt;li&gt;一张表有几个索引，就有几棵B+树。且至少有一棵主键B+树，数据存储在主键索引树上。查询不走索引其实是遍历主键索引树。&lt;/li&gt;
  &lt;li&gt;B+树中一个节点为一页。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;索引结构&quot;&gt;索引结构&lt;/h5&gt;

&lt;p&gt;因为一个索引就是一棵B+树，B+树中一个节点对应一页，所有索引页具有和上面讲到的页的相同基本结构，都包含一个FIL Header和FIL Trailer，主体部分会有所不同，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211112140640173.png&quot; alt=&quot;image-20211112140640173&quot; /&gt;&lt;/p&gt;

&lt;p&gt;重点关注其中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User Records&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Page Directory&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;User Records 是实际存储数据的地方：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非叶子节点：存储指向下一层子节点的指针&lt;/li&gt;
  &lt;li&gt;叶子节点：假设为主键索引树，存储的就是行数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个page中的所有 User Records 组成了一个单链表，头是一个叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;infimum&lt;/code&gt; 的 system record(存储了当前页中最小的key)，尾是一个叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supremum&lt;/code&gt; 的 system record(存储了当前页中最大的key)。&lt;/p&gt;

&lt;p&gt;Index Header 结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211112142023840.png&quot; alt=&quot;image-20211112142023840&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Number of Records&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Page Level(叶子节点所在层为第0层，从下往上递增，root节点所在层为最大层)&lt;/code&gt; 等等。&lt;/p&gt;

&lt;h5 id=&quot;二级索引叶子节点value的排序问题&quot;&gt;二级索引叶子节点value的排序问题&lt;/h5&gt;

&lt;p&gt;假设存在以下表记录&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;a&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;b&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;c&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;d&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;存在一个联合主键 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt;，三个索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c(c)&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ca(c,a)&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cb(c,b)&lt;/code&gt;，分析这三个索引是否有冗余？&lt;/p&gt;

&lt;p&gt;普通索引叶子节点存的值为主键，这里的主键为联合主键。&lt;/p&gt;

&lt;p&gt;索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ca&lt;/code&gt; 即先对 c 排序，再对 a 排序，因为key已经包含了a，所以value只需要存储 b，ca相同时，b升序。记录如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;c(key的部分)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;a(key的部分)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;b(value存的值)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;再看索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;。key先对 c 排序，再对 a 排序，再对 b 排序，结果和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ca&lt;/code&gt; 是一样的。所以索引&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ca&lt;/code&gt; 是多余的。&lt;/p&gt;

&lt;p&gt;索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cb&lt;/code&gt; 先对 c 排序，再对 b 排序，再对 a 排序，可用于基于c、b 的查询，需要保留。&lt;/p&gt;

&lt;h5 id=&quot;实践一下&quot;&gt;实践一下&lt;/h5&gt;

&lt;p&gt;可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_space&lt;/code&gt; 命令直接分析文件，获取文件中存储的page、records等信息。(目前还不支持MySQL8.0)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;详见：&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://github.com/jeremycole/innodb_ruby&quot;&gt;innodb_ruby&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/&quot;&gt;B+Tree index structures in InnoDB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;基于主键索引和普通索引的查询有什么区别&quot;&gt;基于主键索引和普通索引的查询有什么区别&lt;/h3&gt;

&lt;p&gt;主键索引树叶子节点直接存储行数据，所以主键索引查询只需要扫描主键索引树即可。&lt;/p&gt;

&lt;p&gt;而普通索引树叶子节点存储的是主键值，所以需要先扫描普通索引树拿到主键值，再回到主键索引树获取行数据，相较于主键索引查询多扫描了一棵索引树，这个过程称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;回表&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;选择自增主键还是业务主键&quot;&gt;选择自增主键还是业务主键&lt;/h3&gt;

&lt;p&gt;可从存储空间大小和性能两个方面来考虑：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;占用空间：业务主键相较于自增主键都较长，由于二级索引树叶子节点存储的是主键值，所以采用业务主键的二级索引相较于自增主键会占用更多的空间。&lt;/li&gt;
  &lt;li&gt;性能：由于自增主键是有序的，所以在维护索引树时直接追加即可(&lt;strong&gt;叶子节点所在层即第0层的最后一个节点中的最后一个record后&lt;/strong&gt;)，当一页写满会自动开辟一个新的页。而业务主键很难保证有序性，维护索引时很可能会在&lt;strong&gt;中间插入&lt;/strong&gt;，就很有可能引起节点分裂(甚至是父索引节点的分裂)，自然性能会受到影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，在大多数情况下，都应优先使用自增主键。&lt;/p&gt;

&lt;p&gt;当然事无绝对，如果只有一个索引，且该业务字段是唯一的，可以将该字段设为主键。因为不存在其他索引，就不用考虑其他索引的叶子节点大小问题。当然，性能上相较于自增主键还是会有一点影响。&lt;/p&gt;

&lt;h3 id=&quot;一些索引设计原则&quot;&gt;一些索引设计原则&lt;/h3&gt;

&lt;p&gt;假设存在表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u(id,id_card,name,age,gender)&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 是主键，另有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_card&lt;/code&gt; 索引&lt;/p&gt;

&lt;h4 id=&quot;覆盖索引&quot;&gt;覆盖索引&lt;/h4&gt;

&lt;p&gt;即索引key中包含了要查找的字段。&lt;/p&gt;

&lt;p&gt;假如现需要根据身份证查询数据，可直接走 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_card&lt;/code&gt; 索引。&lt;/p&gt;

&lt;p&gt;现又有另一个&lt;strong&gt;高频&lt;/strong&gt;需求，根据身份证查询姓名。目前走的仍然是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_card&lt;/code&gt; 索引，需要先在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_card&lt;/code&gt; 索引树上找到对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_card&lt;/code&gt;，然后再回到主索引树上根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;获取到姓名，也就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;回表&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那有没有什么办法可以优化呢？&lt;/p&gt;

&lt;p&gt;方法就是建立一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(id_card,name)&lt;/code&gt; 的联合索引。这棵索引树节点的key包含了两个字段：id_card 和 name，这样的话直接在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(id_card,name)&lt;/code&gt; 索引上搜索便可直接得到 name，而不需要回表查整行记录，减少了语句的执行时间。与此同时，根据最左匹配原则，原先根据身份证查询数据的请求也可以用到这个索引，所以现在可以删除&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_card&lt;/code&gt; 这个索引了。&lt;/p&gt;

&lt;p&gt;这就是覆盖索引，即索引key中包含了要查找的字段。可使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;explain&lt;/code&gt; 查看是否使用了覆盖索引，&lt;strong&gt;如果在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;explain&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extra&lt;/code&gt; 列中出现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Using index&lt;/code&gt;，说明当前查询使用了覆盖索引&lt;/strong&gt;，即不需要回表查询。&lt;/p&gt;

&lt;p&gt;当然，索引是有代价的。因为每新建一个索引就相当于新建一棵索引树，虽然可以提高查询速度，但增删改就需要多维护一棵索引树。所以需要权衡使用，任何索引都是这样，数据量小的话就没有什么必要，没有太大区别。&lt;/p&gt;

&lt;h4 id=&quot;最左匹配原则&quot;&gt;最左匹配原则&lt;/h4&gt;

&lt;p&gt;假设现在又有一个&lt;strong&gt;低频&lt;/strong&gt;需求：根据身份证查询地址，那么有必要再建立一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(id_card,address)&lt;/code&gt;的联合索引吗？&lt;/p&gt;

&lt;p&gt;答案是不需要。因为这是一个低频请求，意味着请求的次数不会太多，上一节的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(id_card,name)&lt;/code&gt;索引就够用了。可先通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(id_card,name)&lt;/code&gt; 这个索引定位到相应的 id_card，获取到主键后再回表查询。原理很简单，因为联合索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt;是先根据 a 排序再根据  b 排序，所以对于 a 的检索可以用到这个B+树。&lt;/p&gt;

&lt;p&gt;所以最左匹配原则的定义就是只要索引满足最左前缀，便可利用该索引来加速检索。&lt;strong&gt;这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左N个字符。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果既有a,b的联合查询，又有基于a、b各自的查询呢？&lt;/p&gt;

&lt;p&gt;这时考虑的原则就是&lt;strong&gt;空间&lt;/strong&gt;了。如果b字段比a字段大，那么就应该建立一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(b,a)&lt;/code&gt;的联合索引和一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 的单独索引。这两个索引可以同时满足 a,b的联合查询和基于a、b各自的查询。&lt;/p&gt;

&lt;p&gt;除此之外，最左匹配原则当遇到范围匹配时就会失效。比如有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt;的联合索引， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a=1 and b=2&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b=1 and a=2&lt;/code&gt; 都可以用到索引，顺序无所谓，优化器会调整 where 的顺序。但是当遇到类似 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a &amp;gt;1 and b=2&lt;/code&gt; 时，就只有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 能用到索引，会先快速定位到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&amp;gt;1&lt;/code&gt; 的记录，此时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 是无序的，只能遍历判断 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 是否满足。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果 sql 为&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;该怎么建立索引？&lt;/p&gt;

    &lt;p&gt;答：第一反应是直接建立 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b,c)&lt;/code&gt; 的联合索引，但是这里要注意&lt;strong&gt;区分度&lt;/strong&gt;，区分度高的放在前面。区分度越高，检索效率越高，因为快速定位更精准。像性别、状态这种区分度很低的字段，放到后面。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果 sql 为&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;该怎么建立索引？&lt;/p&gt;

    &lt;p&gt;答：因为是范围查询，如果建立 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt; 的索引，就只有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 能用上索引。&lt;/p&gt;

    &lt;p&gt;​	    所以应该建立 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(b,a)&lt;/code&gt; 的索引，优化器会调整条件的顺序，然后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 就能用上索引，在此基础上，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&amp;gt;1&lt;/code&gt; 也能用上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果 sql 为&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`table`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;该怎么建立索引？&lt;/p&gt;

    &lt;p&gt;答：首先肯定要以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 开头，所以有两种选择：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(b,a)&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(b,c)&lt;/code&gt;，至于具体选择哪个，就看&lt;strong&gt;区分度&lt;/strong&gt;和&lt;strong&gt;字段长度&lt;/strong&gt;了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果 sql 为&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`table`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;该怎么建立索引？&lt;/p&gt;

    &lt;p&gt;答：建立 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt; 联合索引，当 a=1 时，b 相对有序，可以避免再次排序。&lt;/p&gt;

    &lt;p&gt;​		那如果是&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`table`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;​		因为此时是范围查询， a&amp;gt;1 时 b 是无序的，所以没有必要再建立一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt; 的联合索引。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果 sql 为&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-sq&quot;&gt;SELECT * FROM `table` WHERE a IN (1,2,3) and b &amp;gt; 1; 
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;该怎么建立索引？&lt;/p&gt;

    &lt;p&gt;答：还是建立  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a,b)&lt;/code&gt; 的联合索引，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN 查询&lt;/code&gt; 可视为等值查询，相当于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a=1 or a=2 or a=3&lt;/code&gt;，所以还是一样的思路。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;索引下推&quot;&gt;索引下推&lt;/h4&gt;

&lt;p&gt;索引下推并不是一个索引设计原则，它是一个索引查找的内部优化。&lt;/p&gt;

&lt;p&gt;前提：因为范围查询不能使用联合索引，只能使用最左前缀。&lt;/p&gt;

&lt;p&gt;以下面的 sql 举例：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tuser&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;张%&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_male&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;张&lt;/code&gt; 开头的记录有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(张三，10)，(张三，10)，(张三，20)，(张六，30)&lt;/code&gt;，有一个联合索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(name,age)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在 MySQL5.6 之前，存储引擎提供的接口对于这种情况只允许传入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;最左前缀&lt;/code&gt;一个参数，即只能传入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name &lt;/code&gt; 这个字段，所以需要回表4次用于判断 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;age&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_male&lt;/code&gt; 是否满足条件。&lt;/p&gt;

&lt;p&gt;在 MySQL5.6之后，接口可以传入包含最左前缀的整个联合索引，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name,age&lt;/code&gt;字段。这样的话可直接在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(name,age)&lt;/code&gt; 索引树上就对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;age&lt;/code&gt; 进行判断，提前过滤掉不满足条件的记录，最后只需要回表2次。&lt;/p&gt;

&lt;p&gt;当 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;explain 的 extra&lt;/code&gt; 字段中显示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Using index condition&lt;/code&gt; 时则表示本次查询使用到了索引下推。&lt;/p&gt;

&lt;h3 id=&quot;选择唯一索引还是普通索引&quot;&gt;选择唯一索引还是普通索引？&lt;/h3&gt;

&lt;p&gt;从读和写两方面来分析。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;读：二者区别就在于是否唯一。唯一索引找到记录后即可返回，普通索引还需继续向后遍历检查是否满足条件。但此时数据页已在内存中，而且很大概率都是页内遍历(通过二分法)，这点差异对于现在的CPU来说可以忽略不计。所以可认为二者在查询方面差异不大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写：需要考虑目标数据页是否在内存中，下面以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert&lt;/code&gt; 举例说明&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;目标数据页在内存中：对于唯一索引来说，找到插入位置，判断到没有冲突，插入，语句执行结束；对于普通索引来说，找到插入位置，插入，语句执行结束。这种情况下直接更新内存即可，性能也没有多大差异。&lt;/li&gt;
      &lt;li&gt;目标数据页不在内存中：
        &lt;ul&gt;
          &lt;li&gt;由于唯一索引需要判断唯一性，所以必须要将数据页从磁盘读到内存。&lt;/li&gt;
          &lt;li&gt;而普通索引没有这个要求，所以可直接在内存中记录下一条 “insert” 操作，语句就执行结束了。记录这个操作的区域叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt;， 由于只需要写内存，避免了磁盘的随机读(磁盘的随机IO是数据库中成本最高的操作之一)，这种情况下普通索引性能就远远优于唯一索引，尤其如果是机械硬盘的话。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;综上所述，如果业务可以接受的话，从性能角度出发，应该选择普通索引。&lt;/p&gt;

&lt;h4 id=&quot;change-buffer&quot;&gt;change buffer&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer pool&lt;/code&gt; 的一部分，默认占比为 25(%)，最大占比可设为 50(%)。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;innodb_change_buffer_max_size&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在MySQL5.5之前的版本，只支持缓存&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert&lt;/code&gt;操作，所以最初叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert buffer&lt;/code&gt;(很多地方见到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ibuf&lt;/code&gt; 指的就是它，后来也一直延用了下来)。后来也加入了对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 的支持，便改名为了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;作用&quot;&gt;作用&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;当目标数据页不在内存中时，普通索引更新类操作的提速器。注意：只能作用于普通索引，不能作用于唯一索引&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;原理上面已经简单分析过，就是通过&lt;strong&gt;减少磁盘的随机读&lt;/strong&gt;来提升写的性能。&lt;/p&gt;

&lt;p&gt;上面是通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert&lt;/code&gt; 来举例，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 有点点区别。&lt;/p&gt;

&lt;p&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt;  中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where&lt;/code&gt; 条件走普通索引的话，由于需要获取受影响行数，所以还是需要先把数据页读到内存中，然后直接更新内存，这里就用不上 change buffer 了。&lt;/p&gt;

&lt;p&gt;如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where&lt;/code&gt; 条件走主键索引或其他普通字段(其实最终也是走主键索引树)，并且需要更新普通索引字段的话，通过主键索引树获取受影响行数，对普通索引的更新就直接写到 change buffer 中了，这种情况是能用 change buffer 来提速的。&lt;/p&gt;

&lt;h5 id=&quot;怎么保证数据被正确更新&quot;&gt;怎么保证数据被正确更新？&lt;/h5&gt;

&lt;p&gt;上面说到，普通索引的更新写到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 中就结束了，那后续的查询是怎样的？&lt;/p&gt;

&lt;p&gt;还是对应到上面的2种情况：目标数据页在不在内存中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果目标数据页在内存中，意味着更新操作是直接更新的内存。那此时内存中的数据页一定是更新后的数据，虽然磁盘上还是老的数据，所以直接从内存返回即可；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果目标数据页不在内存中，需要先把数据页从磁盘读入内存，然后应用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 中的操作日志，生成一个正确的版本后返回，这个过程称为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt; 的时机：&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;查询时。这时会把目标数据页从磁盘读到内存中；&lt;/li&gt;
        &lt;li&gt;作为后台任务定期运行。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity_max&lt;/code&gt; 用于设置 Innodb 后台任务(刷脏页、merge)的 IOPS，可调整该数值来控制 merge 的频率；&lt;/li&gt;
        &lt;li&gt;在崩溃恢复期间，会从系统表空间(ibdata1)中读取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt;，然后当把数据页从磁盘读到内存中时，会进行 merge；&lt;/li&gt;
        &lt;li&gt;重启后；&lt;/li&gt;
        &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slow shutdown&lt;/code&gt; 时。可通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--innodb-fast-shutdown=0&lt;/code&gt; 开启 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slow shutdown&lt;/code&gt;。&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;怎么保证更新不丢失&quot;&gt;怎么保证更新不丢失？&lt;/h5&gt;

&lt;p&gt;如果写完 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 后断电了或意外宕机了，重启后 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 和数据会丢失吗？&lt;/p&gt;

&lt;p&gt;不会。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 也会被记到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redo log&lt;/code&gt; 中(&lt;strong&gt;redo log 中包含了数据页的变更和change buffer的变更&lt;/strong&gt;)，回想之前讲过的两阶段提交协议，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redo log&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binglog&lt;/code&gt;  落盘才代表事务成功提交。所以，如果一个事务已提交，则代表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 已经写到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redo log&lt;/code&gt; 中，且 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redo log&lt;/code&gt; 已落盘，崩溃恢复时会根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redo log&lt;/code&gt; 来恢复 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;适用场景&quot;&gt;适用场景&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 简单来说就是把对普通索引的更新缓存了下来，然后在适当的时候进行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;。所以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt; 之前， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 中记录的变更越多，收益就越大。&lt;/p&gt;

&lt;p&gt;所以对于&lt;strong&gt;&lt;u&gt;写多读少&lt;/u&gt;&lt;/strong&gt;类业务，数据页在写完之后马上被访问到的概率很小，也就是说不会马上进行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;，这种情况下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 的效果最好。比如账单类、日志类等。&lt;/p&gt;

&lt;p&gt;相反，如果是写后马上进行查询的业务，由于马上要访问数据页，会立即触发 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;。这种情况不仅不会减少随机IO的次数，反而会增加维护 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 的代价，反而起到了副作用，这种情况下可以关闭 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;innodb_change_buffering&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;默认值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;all&lt;/code&gt; ，设为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;none&lt;/code&gt; 即可关闭 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;官方文档&quot;&gt;官方文档&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/faqs-innodb-change-buffer.html#faq-innodb-change-buffer-merging&quot;&gt;InnoDB Change Buffer&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;给字符串字段创建索引的几种方法&quot;&gt;给字符串字段创建索引的几种方法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;直接创建完整索引，这样可能比较占空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建前缀索引&lt;/p&gt;

    &lt;p&gt;即可以只定义字符串的一部分作为索引&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index_email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;优点是：节省空间&lt;/p&gt;

    &lt;p&gt;缺点是：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;可能会增加额外的扫描次数&lt;/p&gt;

        &lt;p&gt;​	比如执行这样一句查询：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;zhangssxyz@xxx.com&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;​	对于完整索引，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 索引树上定位到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zhangssxyz@xxx.com&lt;/code&gt;，然后回表取出对于记录即可，只需扫描一行；&lt;/p&gt;

        &lt;p&gt;​	对于前缀索引，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 前缀索引树上定位到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zhangs&lt;/code&gt;，回表判断 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 是否等于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zhangssxyz@xxx.com&lt;/code&gt;，是的话将记录加入结果集，继续在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 前缀索引树上遍历下一条记录，再回表判断，重复此过程，直到遍历的下一条记录不等于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zhangs&lt;/code&gt;。所以前缀索引可能会增加记录的扫描行数。&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;如何优化？&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;关键在于&lt;strong&gt;增加前缀的区分度&lt;/strong&gt;。区分度越高，过滤掉的记录就越多，需要回表的次数就越少。&lt;/p&gt;

        &lt;p&gt;可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。&lt;/p&gt;

        &lt;p&gt;先统计索引上有多少个不同的值：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;再依次选取不同长度的前缀来对比区分度：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;数值越大表示对应长度的前缀区分度越高，效果越好。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;不能使用覆盖索引&lt;/p&gt;

        &lt;p&gt;比如执行这样一句查询：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;zhangssxyz@xxx.com&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;因为只需要查询 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id,email&lt;/code&gt;，对于完整索引来说，使用覆盖索引即可，不需要再回表；&lt;/p&gt;

        &lt;p&gt;对于前缀索引，则必须要回表判断 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 的值，即便前缀索引包含了全部字段(email(18)，假设&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 有18个字符)，因为系统不确定前缀索引的定义是否截断了完整信息。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;倒序存储&lt;/p&gt;

    &lt;p&gt;对于前缀区分度不够好的情况，可以考虑使用倒序存储。&lt;/p&gt;

    &lt;p&gt;比如身份证，同一个区域内的身份证前面几位都是相同的，如果按照上面的方法建立前缀索引，这个前缀的长度可能会比较长。&lt;/p&gt;

    &lt;p&gt;这时可把身份证倒过来存，因为身份证的尾部都是不同的，区分度足够高，查的时候转换一下：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field_list&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id_card&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;input_id_card_string&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这时为身份证建立前缀索引需要的长度就会短很多，具体多长可通过上面的方法来确定。&lt;/p&gt;

    &lt;p&gt;缺点：&lt;strong&gt;不支持范围查询&lt;/strong&gt;，因为是倒序存储，没办法按顺序遍历。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新增一个 hash 字段&lt;/p&gt;

    &lt;p&gt;专门新增一个 hash 字段用来做索引。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;相较于倒序存储查询性能相对稳定一些，因为倒序存储毕竟还是前缀索引，或多或少还是会增加扫描行数。而crc32(或其他哈希算法)冲突的概率总体还是非常小的，可认为每次查询的平均扫描行数接近1。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id_card_crc&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id_card_crc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;每次插入新纪录的时候，都用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crc32()&lt;/code&gt; 计算出一个哈希值填到这个新字段中。&lt;/p&gt;

    &lt;p&gt;查询的时候计算一下，&lt;strong&gt;同时因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crc32&lt;/code&gt; 会有冲突(虽然概率也非常小)，所以还需要在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where&lt;/code&gt; 中校验一下原值&lt;/strong&gt;：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field_list&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id_card_crc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;crc32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;input_id_card_string&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id_card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;input_id_card_string&apos;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这时索引的长度就只有4个字节(crc32的长度)，相较于身份证长度大大减少了。&lt;/p&gt;

    &lt;p&gt;缺点：和倒序存储一样，&lt;strong&gt;不支持范围查询&lt;/strong&gt;，因为哈希字段对应的原值完全是无序的，没办法在哈希索引上按顺序遍历。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 11 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/10/11/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)-MySQL%E7%B4%A2%E5%BC%95/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/10/11/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)-MySQL%E7%B4%A2%E5%BC%95/</guid>
        
        <category>mysql</category>
        
        <category>索引</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(六)：MySQL事务</title>
        <description>&lt;h3 id=&quot;解决的问题&quot;&gt;解决的问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;脏读：读到还没有提交事务的数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不可重复读：前后读取的记录&lt;strong&gt;内容&lt;/strong&gt;不一致&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;幻读：前后读取的记录&lt;strong&gt;数量&lt;/strong&gt;不一致&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;示例：假设存在 person(id,name) 表，含2条数据：(1,”foo”)、(2,”bar”)&lt;/p&gt;

      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th style=&quot;text-align: center&quot;&gt;事务A&lt;/th&gt;
            &lt;th style=&quot;text-align: center&quot;&gt;事务B&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td style=&quot;text-align: center&quot;&gt;select count(1) from person 查到2条数据&lt;/td&gt;
            &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
            &lt;td style=&quot;text-align: center&quot;&gt;insert into person(id,name) values(3,”zoo”) 插入一条数据&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
            &lt;td style=&quot;text-align: center&quot;&gt;commit 提交&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td style=&quot;text-align: center&quot;&gt;insert into person(id,name) values(3,”zoo”) 插入一条数据，&lt;strong&gt;报错提示主键重复&lt;/strong&gt;&lt;/td&gt;
            &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td style=&quot;text-align: center&quot;&gt;select * from person where id = 3，又查不到数据，但是又不能insert，就很奇怪，这种现象就被成为“&lt;strong&gt;幻读&lt;/strong&gt;”&lt;/td&gt;
            &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;

      &lt;p&gt;注：使用 select count(1) 并不能看到幻读现象&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;隔离级别&quot;&gt;隔离级别&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;读未提交&lt;/li&gt;
  &lt;li&gt;读提交：可解决脏读问题&lt;/li&gt;
  &lt;li&gt;可重复读：可解决不可重复读问题&lt;/li&gt;
  &lt;li&gt;串行化：可解决幻读问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;如何查询隔离级别&quot;&gt;如何查询隔离级别？&lt;/h4&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;%isolation%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211031200530501.png&quot; alt=&quot;image-20211031200530501&quot; /&gt;&lt;/p&gt;

&lt;p&gt;默认级别为&lt;u&gt;**可重复读**&lt;/u&gt;。&lt;/p&gt;

&lt;h4 id=&quot;如何更改隔离级别&quot;&gt;如何更改隔离级别？&lt;/h4&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;isolation&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;READ&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UNCOMMITTED&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;如何实现&quot;&gt;如何实现？&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVCC（Multiple Version Concurrency Control）多版本并发控制&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;简而言之，就是一行记录在数据库中存在多个版本，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211103102036454.png&quot; alt=&quot;image-20211103102036454&quot; /&gt;&lt;/p&gt;

&lt;p&gt;V1、V2、V3 并不是物理真实存在的，真实存在的是U1、U2、U3，也就是undo日志。当需要上一个版本的数据时，会通过当前记录和undo日志推算出来。其实每行记录都会有一个我们看不到的隐藏字段trx_id。&lt;/p&gt;

&lt;h4 id=&quot;一致性视图一致性读&quot;&gt;一致性视图（一致性读）&lt;/h4&gt;

&lt;p&gt;有两种开启事务的方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;begin/start transaction：并不是一个事务的真正起点，执行第一个语句的时候事务才真正开启&lt;/li&gt;
  &lt;li&gt;start transaction with consistent snapshot：马上开启事务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;事务开启时，会创建一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一致性视图&lt;/code&gt;。不必纠结于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;视图&lt;/code&gt;两个字，可简单理解为这样一个操作：记录下真正开启事务的那一刻，后面会以这个时刻为准来判断一行记录的哪个版本对于当前事务可见。&lt;/p&gt;

&lt;p&gt;具体实现上，会在开启事务的那一刻生成一个数组，保存了当前系统正在活跃（启动了还没提交）的事务ID，定义一个低水位：数组里的最小事务ID，高水位：当前系统已经创建过的最大的事务ID+1，这个数组和高低水位即构成了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一致性视图&lt;/code&gt;。后续的操作应该可以猜到，就是拿记录的事务ID和这个高低水位比较来判断是否可见。这是具体的代码逻辑，不方便记忆，可简化为下面的可见性规则：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;本事务的更新总是可见&lt;/li&gt;
  &lt;li&gt;版本未提交，不可见&lt;/li&gt;
  &lt;li&gt;版本已提交，但是在视图创建之后提交的，不可见&lt;/li&gt;
  &lt;li&gt;版本已提交，而且是在视图创建之前提交的，可见&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上就是事务具体是如何实现的&lt;/p&gt;

&lt;h4 id=&quot;不同隔离级别下的一致性视图生成时机&quot;&gt;不同隔离级别下的一致性视图生成时机&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;读未提交：直接读取记录的最新版本，没有视图的概念&lt;/li&gt;
  &lt;li&gt;读提交：每个语句会生成新的一致性视图&lt;/li&gt;
  &lt;li&gt;可重复读：在事务开启的时候生成一致性视图，在后续的整个事务期间都使用该视图&lt;/li&gt;
  &lt;li&gt;串行化：直接用加锁的方式来避免并行访问&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;当前读&quot;&gt;当前读&lt;/h4&gt;

&lt;p&gt;事务使用的是一致性读，这里针对的是查询类操作，&lt;strong&gt;&lt;u&gt;而更新类操作使用的是当前读，即读取记录的最新版本，这个区别这很重要&lt;/u&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;示例说明&quot;&gt;示例说明&lt;/h4&gt;

&lt;p&gt;千言万语，不如动手验证一下&lt;/p&gt;

&lt;p&gt;假设存在表 t ( id, k)  values (1,1) ( 2, 2)，事务级别为默认级别，即可重复读。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k=k+1 where id=1;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k=k+1 where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;select k from t where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;select k from t where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;commit;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;commit;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事务C没有显示开启事务，所以更新完成以后自动提交了，此时k的值是2。&lt;/p&gt;

&lt;p&gt;先分析事务A，事务A最先开启，根据可重复读的一致性视图生成时机，在开启的那一刻创建了一致性视图，在此后的整个事务期间都使用该视图。又根据事务可见性规则，事务C的版本虽已提交，但是在视图创建之后提交的，不可见。事务B先不管值是多少，版本尚未提交，仍不可见。所以事务A的查询结果仍是1。&lt;/p&gt;

&lt;p&gt;事务B首先执行了一次更新操作，这里的重点就是：此时读取的是哪个版本？&lt;strong&gt;结论是最新版本，即当前读&lt;/strong&gt;。因为要保证更新不能丢失。所以读到的值是2，再+1=3。然后再进行一次查询操作，根据事务的可见性规则，本事务的更新总是可见。所以，事务B的查询结果是3。&lt;/p&gt;

&lt;p&gt;如果换成读提交隔离级别，结果是怎样的？&lt;/p&gt;

&lt;p&gt;根据读提交的一致性视图生成时机：在每一次执行语句的时候都生成新的视图，所以事务A的视图是在执行到 select 的时候生成。再根据事务的可见性规则，事务C的更新已提交，且是在视图生成之前提交，可见。事务B的更新尚未提交，不可见。所以事务A的查询结果是2。&lt;/p&gt;

&lt;p&gt;事务B的查询结果还是3，分析过程和可重复读隔离级别下一样。&lt;/p&gt;

&lt;p&gt;将上面的操作步骤稍微改一下，事务C稍后再提交，隔离级别仍是可重复读，看下结果会怎样&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;事务C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k=k+1 where id=1;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;update t set k=k+1 where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;select k from t where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;select k from t where id=1;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;commit;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;commit;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;commit;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事务A查询结果：事务B和事务C的更新都尚未提交，不可见，结果是1。&lt;/p&gt;

&lt;p&gt;事务B查询结果：重点来了，由于事务C更新后没有马上提交，所以id=1的写锁一直未释放。而事务B是当前读，必须要读最新版本，若读到的记录最终被回滚了，就产生了脏读，这是不可接受的，所以必须确保当前读读到的数据是最终会被提交的数据。具体实现就是加锁，来确保当前读的数据是最新的且已提交的。所以事务B的更新，要等待事务C提交后才能继续。&lt;/p&gt;

&lt;h3 id=&quot;长事务&quot;&gt;长事务&lt;/h3&gt;

&lt;p&gt;尽量避免长事务，长事务有以下风险：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;会产生大量undo日志，会占用大量存储空间。在MySQL 5.5 及以前版本中，回滚日志是和数据字典一起放在ibdata文件中的，即使长事务最终被提交，回滚日志被清理，文件也不会变小。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;还会占用锁，可能拖垮整个库。如之前对当前读的讨论，当前读会加锁来保证读取到的数据是最新且已被提交的数据，若长事务一直不提交，会导致锁一直被占用，存在很大隐患。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;甚至可能会导致优化器选错索引。&lt;/p&gt;

    &lt;p&gt;案例重现：&lt;/p&gt;

    &lt;p&gt;表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 定义如下：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`t`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`a`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`b`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`a`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`a`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`b`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`b`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;存储过程，插入100000条数据：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;delimiter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;delimiter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;插入数据后执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select * from t where a between 10000 and 20000&lt;/code&gt;，查询走的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 索引，没有问题&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;between&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20000&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211124051211671.png&quot; alt=&quot;image-20211124051211671&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sessionA&lt;/code&gt; 模拟一个长事务，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sessionB&lt;/code&gt; 先清空表，再调用存储过程插入数据&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionA&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;sessionB&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;start transaction with consistent snapshot;&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;delete from t;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;call idata();&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;explain select * from t where a between 10000 and 20000;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;commit&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;再查看执行计划，会发现没有选择使用索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;，走的是全表扫描&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211124051702688.png&quot; alt=&quot;image-20211124051702688&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;为什么？&lt;/p&gt;

    &lt;p&gt;选择索引是优化器的工作，它会综合考虑&lt;strong&gt;扫描行数、索引基数、是否使用了临时文件、是否排序等因素&lt;/strong&gt;来选择它认为速度最快的索引。&lt;/p&gt;

    &lt;p&gt;可通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show index from t&lt;/code&gt; 来查看索引基数 cardinality (近似值，并不精确)，结果如下：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211124160802373.png&quot; alt=&quot;image-20211124160802373&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;索引基数越大，说明区分度越高，选择它的概率就越大。图中可以看出主键和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 的差距并不大，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 反而是最高的，不选择索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 肯定还有其他的原因。&lt;/p&gt;

    &lt;p&gt;再来看一下扫描行数。查询计划显示走的是全表扫描，rows为105033行。强制使用索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 看下扫描行数是多少：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;force&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;between&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211124161809601.png&quot; alt=&quot;image-20211124161809601&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;rows为39940行。这个差距挺大的，那为什么优化器放着 39940行的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 索引不用而要选择 105033行的全表扫描？&lt;/p&gt;

    &lt;p&gt;因为使用索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 需要回表，而走全表扫描是直接扫描主键索引树，不需要回表，优化器”&lt;u&gt;认为&lt;/u&gt;“全表扫描更快。从结果上看，优化器明显选错了，所以优化器也不是百分百可靠的。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;到这里又有一个疑问，为什么开启了一个长事务后，删除再插入数据就会导致扫描行数发生变化？&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;很明显，肯定和这个长事务有关。&lt;/p&gt;

    &lt;p&gt;先简单说一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undo log&lt;/code&gt;，分为两种：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert undo logs&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update undo logs&lt;/code&gt;，对应 insert操作和update、delete操作(delete本质上也是update操作，delete时并不是直接物理删除，而是先做一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deleted&lt;/code&gt; 标记)。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert undo logs&lt;/code&gt; 只用于回滚操作，&lt;strong&gt;并且在事务提交后便可清除&lt;/strong&gt;(事务提交即意味着插入已永久持久化了，不会再有回滚操作，也就不再需要 insert undo logs 了)。而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update undo logs&lt;/code&gt; &lt;strong&gt;除了用于回滚操作之外，还用于MVCC，且只有当没有任何事务再需要用它来构造数据的早期版本时，方可删除&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;上面讲到 delete 时并不是直接物理删除，而是先标记。&lt;strong&gt;只有在对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update undo logs&lt;/code&gt; 被清除时才会进行真正的物理删除，这个过程也成为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;purge&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;所以在这个案例中，因为先开启了一个长事务 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sessionA&lt;/code&gt;，为了保证事务的可重复读，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sessionB&lt;/code&gt; 中进行的 delete 和 insert 操作所产生的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;upodate undo logs&lt;/code&gt; 会一直保留直到长事务提交。也就意味着原先的10万行数据并没有被真正删除，而是保留在了索引树上。因此每一行都会有两个版本，即总共会有20万数据，从 ibd 文件大小也能看出，大小变为了原来的两倍。而优化器统计扫描行数时会将标记为删除的版本也统计在内，导致扫描行数增加。&lt;/p&gt;

    &lt;p&gt;那为什么只有索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 的扫描行数增加了，主键的扫描行数还是10万行？因为主键的扫描行数是直接按照表的行数来估算的，而表的行数优化器取的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show table status like &apos;t&apos;&lt;/code&gt; 中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rows&lt;/code&gt; 的值。索引的统计则是通过对数据页采样统计估算出来的，所以会算上老版本的数据。&lt;/p&gt;

    &lt;p&gt;原因找到了，如何解决？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;既然是由长事务引起的，提交或kill掉长事务后便可重新让查询走索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;简单粗暴，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;force index(a)&lt;/code&gt;  强制使用索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;`&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;analyze table t&lt;/code&gt; 重新统计索引信息，优化器会更正扫描行数，然后选择使用索引 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 。&lt;strong&gt;当发现 explain 预估的 rows 和实际情况差距较大时，都可以采用这个方法来处理&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;如何监控长事务&quot;&gt;如何监控长事务？&lt;/h4&gt;

&lt;p&gt;下述语句用于监测持续时间超过60s的长事务&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;information_schema&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;innodb_trx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIME_TO_SEC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timediff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trx_started&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;如何避免长事务&quot;&gt;如何避免长事务？&lt;/h4&gt;

&lt;h5 id=&quot;应用开发端&quot;&gt;应用开发端&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;确认是否使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set autocommit = 0 &lt;/code&gt;，代表手动提交事物。可先开启 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;general_log&lt;/code&gt;，通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show global variables like &apos;%general_log%&apos;&lt;/code&gt; 查看 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;general_log&lt;/code&gt; 是否开启和日志文件路径。然后随便跑一个业务逻辑，在日志中检查是否有  ` set autocommit = 0`。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确认是否有不必要的只读事务。有些框架会不管什么语句都用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;begin/commit&lt;/code&gt; 包起来。或者有些业务并没什么必要，也要把一堆 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select&lt;/code&gt; 放到事务中。上面提到过，对当前读事务会加锁。所以对于单纯的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select&lt;/code&gt; 没有必要放到事务中，事务中主要放 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update/insert/delete&lt;/code&gt;，除非是明确需要事务特性的查询，比如明确需要可重复读的查询，才需要放到事务中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据对业务的预估，通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set max_execution_time&lt;/code&gt; 来设置单个语句的最长执行时间，来避免单个语句意外执行过长时间。&lt;/p&gt;

    &lt;h5 id=&quot;数据库端&quot;&gt;数据库端&lt;/h5&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;监控 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;information_schema.innodb_trx&lt;/code&gt;表，超过阈值就报警或者kill掉。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;推荐使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;percona 的 pt-kill&lt;/code&gt; 工具，作用描述如下：&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;&lt;strong&gt;pt-kill&lt;/strong&gt; captures queries from SHOW PROCESSLIST, filters them, and then either kills or prints them. This is also known as a “slow query sniper” in some circles. The idea is to watch for queries that might be consuming too many resources, and kill them.&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在测试阶段可要求输出所有的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;general_log&lt;/code&gt;，分析日志提前发现问题。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在MySQL5.6或更新版本，可将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_undo_tablespaces&lt;/code&gt; 设置为 2 或更大的值，如果真的出现大事务导致回滚段过大，清理起来更方便。&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_undo_tablespaces&lt;/code&gt; ：&lt;/p&gt;

          &lt;ul&gt;
            &lt;li&gt;0：使用系统表空间，即 ibdata1&lt;/li&gt;
            &lt;li&gt;不为0：使用独立数量的undo表空间，默认为2，即 undo_001、undo_002&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 19 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/09/19/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)-MySQL%E4%BA%8B%E5%8A%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/09/19/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)-MySQL%E4%BA%8B%E5%8A%A1/</guid>
        
        <category>mysql</category>
        
        <category>事务</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(五)：MySQL计算QPS和TPS</title>
        <description>&lt;h3 id=&quot;qps&quot;&gt;QPS&lt;/h3&gt;

&lt;p&gt;基于 com_select&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;基于questions的会统计show命令，mysql设置环境变量的时候也会增加，不太准&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;OLD_QPS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_select&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sleep&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;NEW_QPS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_select&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NEW_QPS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OLD_QPS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;) / &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; | bc
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$1&lt;/code&gt; 代表添加到shell的第一个参数值，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$2&lt;/code&gt; 代表第二个，以此类推。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$0&lt;/code&gt; 为shell文件名。&lt;/p&gt;

&lt;p&gt;获取当前时刻的 qps：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;./qps.sh 1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;tps&quot;&gt;TPS&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#/usr/bin/env bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;OLD_COM_INSERT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_insert&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;OLD_COM_UPDATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_update&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;OLD_COM_DELETE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_delete&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sleep&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;NEW_COM_INSERT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_insert&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;NEW_COM_UPDATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_update&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;NEW_COM_DELETE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;show global status where Variable_name=&apos;Com_delete&apos;;&quot;&lt;/span&gt;|mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-pxxx&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-N&lt;/span&gt;|awk &lt;span class=&quot;s1&quot;&gt;&apos;{print $2}&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NEW_COM_INSERT&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; - &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OLD_COM_INSERT&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;) + (&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NEW_COM_UPDATE&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; - &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OLD_COM_UPDATE&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;) + (&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NEW_COM_DELETE&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; - &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OLD_COM_DELETE&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)) / &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; | bc
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 11 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/09/11/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)-MySQL%E8%AE%A1%E7%AE%97QPS%E5%92%8CTPS/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/09/11/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)-MySQL%E8%AE%A1%E7%AE%97QPS%E5%92%8CTPS/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(四)：MySQL定时备份和恢复</title>
        <description>&lt;p&gt;定时备份：使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysqldump&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crontab&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;mysqldump-用法&quot;&gt;mysqldump 用法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;备份全部数据库的数据和结构&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份全部数据库的结构（加 -d 参数）&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份全部数据库的数据(加 -t 参数)&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份单个数据库的数据和结构(数据库名mydb)&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份单个数据库的结构&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份单个数据库的数据&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份多个表的数据和结构（数据，结构的单独备份方法与上同）&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqlDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一次备份多个数据库&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;mysqldump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p123456&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--databases db1 db2 &amp;gt; /data/mysqlDump/mydb.sql&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;crontab-用法&quot;&gt;crontab 用法&lt;/h3&gt;

&lt;p&gt;crontab不同操作系统实现不同，语法是通用的&lt;/p&gt;

&lt;p&gt;crontab 表达式含义：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;表示分钟&lt;/li&gt;
  &lt;li&gt;表示小时&lt;/li&gt;
  &lt;li&gt;表示一个月中的第几天&lt;/li&gt;
  &lt;li&gt;表示月份&lt;/li&gt;
  &lt;li&gt;表示一个星期中的第几天&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; 表示分钟都要执行（以此类推）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a-b&lt;/code&gt; 表示从 a 到 b 这段时间内要执行（以此类推）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*/n&lt;/code&gt; 表示每 n 分钟执行一次（以此类推）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a,b,c&lt;/code&gt; 表示在第 a、b、c 分钟执行（以此类推）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;定时任务脚本&quot;&gt;定时任务脚本&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;31
&lt;span class=&quot;nv&quot;&gt;backup_dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lib/mysql
&lt;span class=&quot;nb&quot;&gt;dd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; +%Y-%m-%d_%H:%M:%S&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;tool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mysqldump
&lt;span class=&quot;nv&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;root
&lt;span class=&quot;nv&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxxx
&lt;span class=&quot;nv&quot;&gt;database_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;test

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backup_dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backup_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$tool&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$username&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$password&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$database_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backup_dir&lt;/span&gt;/&lt;span class=&quot;nv&quot;&gt;$database_name&lt;/span&gt;-&lt;span class=&quot;nv&quot;&gt;$dd&lt;/span&gt;.sql

&lt;span class=&quot;nv&quot;&gt;delfiles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-crt&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backup_dir&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.sql | &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;{print $9 }&apos;&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-crt&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backup_dir&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.sql | &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;{print $9 }&apos;&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-gt&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$delfiles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;利用全量备份和binlog恢复数据&quot;&gt;利用全量备份和binlog恢复数据&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;使用全量备份恢复临时库&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; database &amp;lt; dump.sql
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flush logs&lt;/code&gt; 重开一个binlog，一是避免操作当前binlog文件防止发生意外情况，二是缩小范围排除干扰，在之前的binlog中定位操作范围&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   flush logs
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysqlbinlog&lt;/code&gt; 导出 sql，主要是设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--start-position&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--stop-position&lt;/code&gt;，不需要设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--base64-output=decode-rows&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mysqlbinlog &lt;span class=&quot;nt&quot;&gt;--start-position&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;6276&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--stop-position&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;6481&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--database&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;binlog.000011 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; binlog.sql
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用导出的sql进行增量恢复&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; database &amp;lt; binlog.sql
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/letcafe/p/mysqlautodump.html&quot;&gt;MySQL 定时备份数据库（全库备份）&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/09/05/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)-MySQL%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/09/05/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)-MySQL%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(三)：redo log 和 binlog</title>
        <description>&lt;h3 id=&quot;binlog&quot;&gt;binlog&lt;/h3&gt;

&lt;p&gt;MySQL Server层的日志，与存储引擎无关，存储的是逻辑日志，可理解为sql语句。&lt;/p&gt;

&lt;h4 id=&quot;主要作用&quot;&gt;主要作用：&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;如果是 Innodb 引擎，和 redo log 一起提供崩溃恢复的能力（crash-safe），保证了事务ACID中的持久性。&lt;/li&gt;
  &lt;li&gt;常被用于主备同步，或接入其他下游系统如 es 用于数据分析，即作为其他需要直接从数据库获取数据且有很高实时性要求的应用的数据来源通道。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;如何查看&quot;&gt;如何查看？&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;​	查看binlog 格式&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;%binlog_format%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;​    查看当前使用的binlog文件&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;​    查看所有binlog文件&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;binary&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看binlong文件内容&lt;/p&gt;

    &lt;p&gt;方式一：show 命令&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binlog&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;binlog.000008&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;方式二： mysqlbinlog&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mysqlbinlog &lt;span class=&quot;nt&quot;&gt;--base64-output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;decode-rows&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--verbose&lt;/span&gt; binlog.000001
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;binlog 3种格式的区别&lt;/p&gt;

    &lt;p&gt;STATEMENT：记录具体执行语句，如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update t set name = &apos;newName&apos; where name = &apos;oldName&apos;&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;ROW：记录每一行记录的变更，一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 可能产生多条日志（每条记录都会产生一行日志）&lt;/p&gt;

    &lt;p&gt;MIXED：当满足某些条件时会自动从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STATEMENT&lt;/code&gt;切换到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROW&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择哪种格式？&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STATEMENT&lt;/code&gt;直接记录sql，可能会在某些情况下导致执行结果不一致，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 时走的索引不同会导致删除的记录不同；&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROW&lt;/code&gt; 直接记录每一行记录的变更，最安全，但是日志的量会很大，存储空间不紧张的话最好选择该格式。MySQL 8 默认格式就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROW&lt;/code&gt;；&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIXED&lt;/code&gt; 需要检查会不会有不在自动切换的条件中，但可能会导致执行结果不一致的特殊情况，自动其实意味着熟悉&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换当前连接 binlog 格式&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SESSION&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binlog_format&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;STATEMENT&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;刷新binlog&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;binlog的写入时机&quot;&gt;binlog的写入时机&lt;/h4&gt;

&lt;p&gt;binlog会首先写到cache里，cache满了就会暂存到磁盘上，这个参数大小由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_cache_size&lt;/code&gt; 控制，默认是32K。&lt;strong&gt;注意这个cache是单个线程拥有的，也就是说每个线程都有自己的binlog_cache，但是共用同一份binlog文件。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个事务的binlog是不能被拆开的，无论一个事务多大，也要确保一次性写入binlog文件。&lt;/p&gt;

&lt;p&gt;binlog会被首先&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt;到操作系统的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page cache&lt;/code&gt;中，然后才会被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsync&lt;/code&gt;到磁盘中。一般可认为只有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsync&lt;/code&gt;才占磁盘的IOPS。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt;  和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsync&lt;/code&gt; 的时机由参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync_binlog&lt;/code&gt;控制，默认值是1，总共有3种设置：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0：每次事务提交时都只write，不fsync。由于只保存到操作系统缓存，所以如果主机重启会丢失数据&lt;/li&gt;
  &lt;li&gt;1：每次事务都 fsync&lt;/li&gt;
  &lt;li&gt;N(N&amp;gt;1)：每次事务提交都write，但只有累计了 N 个事务以后才会 fsync&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;设为N时，如果主机异常重启会丢失最近N个事务的数据，但是可以提升性能，需评估使用。&lt;/p&gt;

&lt;h3 id=&quot;redo-log&quot;&gt;redo log&lt;/h3&gt;

&lt;p&gt;Innodb 特有的日志，存储的是物理日志，即数据页上的改动。&lt;/p&gt;

&lt;p&gt;数据页：Innodb 从磁盘读取数据的基本单位，即使只取一行记录，也会将改行所在的整个数据页读入内存。数据页的大小可通过以下参数查看，默认为16k&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;innodb_page_size&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主要作用：提供事务能力，保证 crash-safe&lt;/p&gt;

&lt;h4 id=&quot;redo-log-格式&quot;&gt;redo log 格式&lt;/h4&gt;

&lt;p&gt;采用循环写的方式，有2个游标：checkpoint、writepos。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;writepos&lt;/code&gt; 表示当前写的位置，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkpoint&lt;/code&gt; 表示要擦除的位置，都是边写边往后推移。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/图片/16a7950217b3f0f4ed02db5db59562a7.webp&quot; alt=&quot;16a7950217b3f0f4ed02db5db59562a7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;绿色的部分表示空闲的空间。&lt;/p&gt;

&lt;h4 id=&quot;查看-redo-log-相关设置&quot;&gt;查看 redo log 相关设置&lt;/h4&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;%innodb_log%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/图片/Screenshot_20211028_111202.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_log_buffer_size&lt;/code&gt;：redo log 缓冲区大小，默认16M&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_log_file_size&lt;/code&gt;：redo log文件大小，默认48M&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_log_files_in_group&lt;/code&gt;：每组有多少个redo log 文件，默认2个：ib_logfile0、ib_logfile1&lt;/p&gt;

&lt;h4 id=&quot;redo-log-一般设多大&quot;&gt;redo log 一般设多大？&lt;/h4&gt;

&lt;p&gt;redo log 太小的话，会导致很快被写满，然后不得不强行刷 redo log，发挥不出 WAL 的作用。&lt;/p&gt;

&lt;p&gt;所以，磁盘空间不是很紧张的话，设大点吧，比如设置为4个文件，每个文件1G。&lt;/p&gt;

&lt;h4 id=&quot;redo-log-的写入时机&quot;&gt;redo log 的写入时机？&lt;/h4&gt;

&lt;p&gt;同样，redo log 也分为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsync&lt;/code&gt;，由参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;控制，默认值为1：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0：每次事务提交只把redo log保留在 redo log buffer 中&lt;/li&gt;
  &lt;li&gt;1：每次事务提交都 fsync 到磁盘（prepare阶段fsync，commit阶段write就行了）&lt;/li&gt;
  &lt;li&gt;2：每次事务提交都只将redo log 写到 page cache 中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;除此之外，后台还会有一个线程，每隔1秒会将redo log buffer中的内容先 write 到 page cache，再 fsync 到磁盘。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;没提交的事务也会被 &lt;strong&gt;&lt;u&gt;被动的&lt;/u&gt;&lt;/strong&gt; 写入磁盘：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;redo log buffer 占用空间达到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_log_buffer_size&lt;/code&gt; 一半时，后台线程会主动写盘，注意由于没有提交事务，此时只是 write，没有 fsync&lt;/li&gt;
  &lt;li&gt;如果有并行事务，假如A执行了一半，已经写了一些redo log 到 buffer中，此时 B 提交，如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;=1，B要把buffer里日志全部fsync到磁盘，此时会带上A的内容一起fsync&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再次强调，写完内存和rodo log、binlog就算事务提交成功了。所以结合两阶段提交，&lt;strong&gt;当默认值为1时&lt;/strong&gt;，在redo log的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepare&lt;/code&gt; 阶段就会fsync一次。然后再写binlog，再将redo log 的标识设为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commit&lt;/code&gt;（&lt;strong&gt;但是这个阶段只会write 到page cache 中，不再需要fsync了，因为有后台定时线程：每1秒会fsync一次；和崩溃恢复逻辑：prepare的redo log 加上完整的binlog即可保证事务的持久性和一致性&lt;/strong&gt;）&lt;/p&gt;

&lt;h4 id=&quot;最终数据落盘的过程是&quot;&gt;最终数据落盘的过程是？&lt;/h4&gt;

&lt;p&gt;1、正常运行过程中，MySQL更新完内存后，内存中的数据页被称为脏页，最终数据落盘就是把脏页写盘，这个过程甚至和redo log 毫无关系。（当然，猜测还会向前推进redo log中 checkpoint的位置）&lt;/p&gt;

&lt;p&gt;2、在崩溃恢复时或启动时（MySQL启动时会自动执行该过程），会先将redo log中的数据更新到内存中，此时该数据页就变成了脏页，接下来的步骤就和第1种情况一样了。&lt;/p&gt;

&lt;h3 id=&quot;什么是mysql中的两阶段提交&quot;&gt;什么是MySQL中的两阶段提交？&lt;/h3&gt;

&lt;p&gt;一个事务当写完内存和redo log、binlog以后就算提交成功了，并不需要写真正的数据文件。为了保证2个日志文件都写入成功，采用了两阶段提交的方法，如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/图片/两阶段提交.svg&quot; alt=&quot;两阶段提交&quot; /&gt;&lt;/p&gt;

&lt;p&gt;两阶段提交并不是MySQL特有的，它是一种分布式事务的策略。其本质说来也很通俗，就是一个人的时候好办，多个人的时候，为了保持大家步调一致，每个人准备好以后吼一声，都准备好了才能继续下一步。&lt;/p&gt;

&lt;h3 id=&quot;两阶段提交如何保证-crash-safe&quot;&gt;两阶段提交如何保证 crash-safe？&lt;/h3&gt;

&lt;h4 id=&quot;crash-safe具体提供了什么能力&quot;&gt;crash-safe具体提供了什么能力？&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;只要客户端收到事务成功的消息，事务就一定持久化了&lt;/li&gt;
  &lt;li&gt;只要客户端收到事务失败的消息，事务就一定失败了&lt;/li&gt;
  &lt;li&gt;如果客户端收到“执行异常”之类的消息，需要应用重连后查询当前状态来执行后续逻辑。数据库内部只要保证数据和日志、主库和备库之间一致就行了&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;具体如何实现&quot;&gt;具体如何实现？&lt;/h4&gt;

&lt;p&gt;1、redo log 状态为commit，直接提交事务&lt;/p&gt;

&lt;p&gt;2、redo log 状态为prepare，查看对于的binlog是否完整：&lt;/p&gt;

&lt;p&gt;​	  a.  不完整，回滚&lt;/p&gt;

&lt;p&gt;​      b.  完整，提交事务&lt;/p&gt;

&lt;h4 id=&quot;如何知道binlog是否完整&quot;&gt;如何知道binlog是否完整？&lt;/h4&gt;

&lt;p&gt;完整的binlog最后会有个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XID EVENT&lt;/code&gt; 和  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COMMIT&lt;/code&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211029160948653.png&quot; alt=&quot;image-20211029160948653&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外，还提供了一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog-checksum&lt;/code&gt; 参数用于校验binlog的完整性。&lt;/p&gt;

&lt;h4 id=&quot;redo-log-是怎么和-binlog-对应起来的&quot;&gt;redo log 是怎么和 binlog 对应起来的？&lt;/h4&gt;

&lt;p&gt;它们都有一个共同的字段 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XID&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;为什么要引入两个日志只用binlog-不就行了&quot;&gt;为什么要引入两个日志，只用binlog 不就行了？&lt;/h4&gt;

&lt;p&gt;（现在只能理解到这个程度）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;binlog不具备 crash-safe 的能力&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、binlog 中没有checkpoint，不能区分哪些是已经落盘到磁盘数据文件（即最终存储数据的文件），哪些是需要应用到内存中用于崩溃恢复的&lt;/p&gt;

&lt;p&gt;2、binlog中存储的是逻辑日志，即sql级别的语句。redo-log中存储的是物理日志，即数据页级别的改动。一个sql语句可能会更改到好几个数据页，如果单个数据页损坏，binlog是没有能力恢复单个数据页的，它只能应用整个sql语句。比如一个sql语句同时更改了ABC三个数据页，更新的时候发生了crash，B数据页没有正常更新，AC正常更新。如果使用binlog来恢复，它只能同时恢复ABC三个数据页，结果就是B恢复了，AC又不对了。简而言之，binlog粒度太大。&lt;/p&gt;

&lt;h3 id=&quot;为什么要写2个日志直接更新数据文件不是更快吗&quot;&gt;为什么要写2个日志，直接更新数据文件不是更快吗？&lt;/h3&gt;

&lt;p&gt;这种思路叫做 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write ahead log&lt;/code&gt;，简称 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WAL&lt;/code&gt;，是数据库的通用技术，主要基于以下两点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;顺序写快于随机写。写日志文件都是顺序写，而直接更新数据文件大多数都是随机写，在机械硬盘时代这个速度差异非常大。&lt;/li&gt;
  &lt;li&gt;虽然是写2个日志，看似意味着一次事务提交要经历两次刷盘，实际上利用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;组提交&lt;/code&gt; 的策略，fsync 的次数会大大减少，而write 到 操作系统page cache 基本上可以认为和写到内存差不多，可认为只有 fsync 会占用磁盘的 IOPS。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;说下组提交&quot;&gt;说下组提交&lt;/h4&gt;

&lt;p&gt;在双1配置下，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync_binlog&lt;/code&gt; 都为1，也就是默认情况下，redo log 会在 prepare 阶段 fsync。结合两阶段提交，写binlog其实也分为两步：write 和 fsync。MySQL做了一个优化：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;拖时间&lt;/code&gt;。即将redo log 的 fsync 放到了 binlog的 write 之后、fsync之前。这样的话，由于redo log write 完之后没有立即 fsync，而是等了一步：等binlog write完，所以有机会可以积累更多的redo log 到 page cache中，然后再一并进行 fsync。&lt;/p&gt;

&lt;p&gt;与此同时，也给了binlog  组提交的机会，因为binlog fsync 之前要等待redo log fsync。但是由于通常情况下 redo log fsync会很快，所以binlog 组提交的效果不如 redo log 的明显。但是可以通过调整以下参数优化：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_group_commit_sync_delay&lt;/code&gt;：表示延迟多少毫秒以后才调用 fsync&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_group_commit_no_delay_count&lt;/code&gt;：表示积累多少次以后才调用 fsync&lt;/p&gt;

&lt;p&gt;第一个参数为0时，第二个参数无效。&lt;/p&gt;

&lt;h3 id=&quot;如何提高mysql的io性能&quot;&gt;如何提高MySQL的IO性能？&lt;/h3&gt;

&lt;p&gt;从提高写redo log 和 binlog 的性能入手。&lt;/p&gt;

&lt;p&gt;redo log：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;增大redo log buffer 大小&lt;/li&gt;
  &lt;li&gt;增大redo log file 大小&lt;/li&gt;
  &lt;li&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_flush_log_at_trx_commt&lt;/code&gt; 设为2，表示每次事务提交都只 write 到 page cache，由后台定时线程来fsync。这样做的风险是主机掉电重启后会丢失数据（正常关闭不影响，MySQL在正常关闭前会完成一系列收尾工作）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;binlog：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync_binlog&lt;/code&gt; 设为大于1的值（通常是100-1000），这样做的风险是主机掉电会丢失binlog日志&lt;/li&gt;
  &lt;li&gt;调整 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_group_commit_sync_delay&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binlog_group_commit_no_delay_count&lt;/code&gt;，提高binlog组提交效率，减少写盘次数。这样做会增加语句的响应时间，但是不会有丢失数据的风险&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql语句突然变慢了&quot;&gt;sql语句突然变慢了？&lt;/h3&gt;

&lt;p&gt;有时会遇到这种情况，一条sql平时执行都很快，但有时候不知道为什么突然就变得很慢，而且这个情况还是随机的、持续时间也很短，很难复现。&lt;/p&gt;

&lt;p&gt;突然变慢的这一瞬间很有可能是MySQL&lt;strong&gt;在刷脏页&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;以下4种情况会引发刷脏页：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当需要读入新的内存页时，如果系统内存不足，就需要淘汰旧的数据页。如果淘汰的是脏页，就需要把脏页刷到磁盘。当一次淘汰的脏页太多时，就会明显影响性能。&lt;/li&gt;
  &lt;li&gt;redo log 写满了。此时需要把redo log的 checkpoint 往前推进，并把 write pos 到新的 checkpoint 之间对应的脏页刷到磁盘。&lt;strong&gt;这种情况是很严重的，此时MySQL将不再接受更新，所有更新都会堵住。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;后台任务 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;purge&lt;/code&gt; 会在系统空闲时刷脏页。&lt;/li&gt;
  &lt;li&gt;MySQL正常关闭时。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;解决思路：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主要解决前两种情况，后两种情况不会影响到系统性能。&lt;/p&gt;

&lt;p&gt;对于情况二，调整 redo log 的大小即可，默认值明显太小，上文有讲过。&lt;/p&gt;

&lt;p&gt;对于情况一，需要先了解下Innodb刷脏页的控制策略和相关参数。&lt;/p&gt;

&lt;p&gt;这里主要的参数是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt;，从名字就可以看出是控制 IO 能力的，官方描述如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_io_capacity&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt;&lt;/a&gt; variable defines the number of I/O operations per second (IOPS) available to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InnoDB&lt;/code&gt; background tasks, such as &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_flush&quot;&gt;flushing&lt;/a&gt; pages from the &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_buffer_pool&quot;&gt;buffer pool&lt;/a&gt; and merging data from the &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_change_buffer&quot;&gt;change buffer&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单说就是设置 IOPS，&lt;strong&gt;它用来告诉 Innodb 所在主机的 IO 能力&lt;/strong&gt;，用于后台任务刷脏页和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;change buffer&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;。默认值是&lt;strong&gt;200&lt;/strong&gt;，即 Innodb &lt;strong&gt;全力&lt;/strong&gt;刷脏页可以达到 200 IOPS。这个值明显太低了，即便是对于机械硬盘。&lt;/p&gt;

&lt;p&gt;当然，Innodb 不会完全按照这个值去刷脏页，因为系统还需要处理服务请求。&lt;strong&gt;Innodb的做法是会算出一个百分比，然后按 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt; 定义的能力乘以这个百分比来控制刷脏页的速度&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;百分比的大致算法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;根据当前脏页比例再结合 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_max_dirty_pages_pct(脏页比例上限，默认值是90)&lt;/code&gt; 算出一个 0到100 之间的数字&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;脏页比例可通过下面命令得到：&lt;/p&gt;

      &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLE_VALUE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;global_status&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLE_NAME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Innodb_buffer_pool_pages_dirty&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLE_VALUE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;global_status&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARIABLE_NAME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Innodb_buffer_pool_pages_total&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/div&gt;

      &lt;p&gt;计算方法伪代码如下，M 为当前脏页比例：&lt;/p&gt;

      &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;F1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;innodb_max_dirty_pages_pct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;innodb_max_dirty_pages_pct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/div&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;InnoDB 每次写入的日志都有一个序号(LSN)，当前写入的序号跟 checkpoint 对应的序号之间的差值，假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，N 越大，算出来的值越大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;取2值较大者作为百分比&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从这个过程可以看出，可以介入的部分就是两个参数：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_max_dirty_pages_pct&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;建议设置为磁盘的IOPS，磁盘的IOPS可以通过下面的命令来测试，一般参考测试结果中 write 的能力来设置：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;fio &lt;span class=&quot;nt&quot;&gt;-filename&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$filename&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-direct&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 &lt;span class=&quot;nt&quot;&gt;-iodepth&lt;/span&gt; 1 &lt;span class=&quot;nt&quot;&gt;-thread&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-rw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;randrw &lt;span class=&quot;nt&quot;&gt;-ioengine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;psync &lt;span class=&quot;nt&quot;&gt;-bs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16k &lt;span class=&quot;nt&quot;&gt;-size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;500M &lt;span class=&quot;nt&quot;&gt;-numjobs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10 &lt;span class=&quot;nt&quot;&gt;-runtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10 &lt;span class=&quot;nt&quot;&gt;-group_reporting&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mytest 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;注意：一定要熟悉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fio&lt;/code&gt; 的使用方法，否则可能会把盘都刷了！！！注意，注意，注意，危险的事情说三遍！！！&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;参考：&lt;a href=&quot;https://blog.51cto.com/shaonian/2319175&quot;&gt;&lt;strong&gt;fio 命令入门到跑路&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_max_dirty_pages_pct&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;从上面的伪代码可以看出，当脏页比例≥该参数值时，第一个参数为100；否则取脏页比例/该参数值的百分比。MySQL8.0以后该值默认为90，也就是说当脏页比例≥90时，会百分百按 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_io_capacity&lt;/code&gt;  的能力&lt;strong&gt;全力&lt;/strong&gt;刷脏页。为了尽量避免因刷脏页引起的抖动，应经常关注脏页比例，不要让它经常接近90%。或者可以调高一点(其实该值已经调整过了，之前是75，8.0后调为了90。90已经接近100了，可认为该值是一个很合理的值，如果脏页累计过多，刷脏页就会很频繁)。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，还有一个参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innodb_flush_neighors&lt;/code&gt;，从参数名字可以看出大概意思：刷脏页的时候是只刷自己还是连着附近的脏页也一起刷了，1表示启用，0表示只刷自己。&lt;/p&gt;

&lt;p&gt;这个机制对于传统机械硬盘很有用，机械硬盘的IOPS一般只有几百，每次多刷一些可以减少很多随机IO。而SSD的随机IO已不是瓶颈，只刷自己反而会更快些。在MySQL8.0中，该参数的默认值已为0，表示只刷自己。&lt;/p&gt;
</description>
        <pubDate>Sat, 28 Aug 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/08/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-redo-log-%E5%92%8C-binlog/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/08/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-redo-log-%E5%92%8C-binlog/</guid>
        
        <category>mysql</category>
        
        <category>redo</category>
        
        <category>binlog</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(二)：MySQL权限控制</title>
        <description>&lt;p&gt;MySQL权限可分为全局级、数据库级、表级、列级、子程序级（函数、存储过程）&lt;/p&gt;

&lt;h3 id=&quot;全局级&quot;&gt;全局级&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数据库级&quot;&gt;数据库级&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;表级&quot;&gt;表级&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tables_priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;列级&quot;&gt;列级&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;columns_priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;子程序级&quot;&gt;子程序级&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;procs_priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;也可通过-show-grants-for-user-查询授权语句&quot;&gt;也可通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show grants for user&lt;/code&gt; 查询授权语句&lt;/h3&gt;

&lt;h3 id=&quot;示例&quot;&gt;示例&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;err&quot;&gt;创建用户：&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;identified&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt;  &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;err&quot;&gt;授予全局级查询权限：&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;err&quot;&gt;授予数据库级查询权限：&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;err&quot;&gt;授予表级查询权限：&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;err&quot;&gt;授予表级查询权限：&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;err&quot;&gt;授予列级权限（只能查询&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;表的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;字段）：&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;err&quot;&gt;撤销权限：&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;revoke&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;test&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;err&quot;&gt;刷新权限：&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;privileges&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 23 Aug 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/08/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-MySQL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/08/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-MySQL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
      <item>
        <title>MySQL学习笔记(一)：一条sql查询语句是如何执行的？</title>
        <description>&lt;p&gt;先放一张MySQL架构图，有助理解，一条sql查询语句经历了从上到下的以下过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/图片/mysql.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整体可分为两大块：Server层和存储引擎层。所有跨存储引擎层的功能都在Server层实现，如内置函数（日期、时间、数学、加密函数等）、存储过程、触发器、视图等。&lt;/p&gt;

&lt;h3 id=&quot;连接器&quot;&gt;连接器&lt;/h3&gt;

&lt;p&gt;作用：建立连接、检查权限、维持和管理连接&lt;/p&gt;

&lt;p&gt;建立连接时会去查询是否有相应权限，之后的所有权限判断逻辑都依赖于此时读到的权限。这也就意味着如果在建立连接后再对用户的权限做更改，只会在重新连接后才生效。&lt;strong&gt;todo：怎么查询权限？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;连接建立后如果没有后续动作，该连接就处于空闲状态，可以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show processlist&lt;/code&gt; 中看到它。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sleep&lt;/code&gt;表示当前系统中有一个空闲连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211026100717263.png&quot; alt=&quot;image-20211026100717263&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果长时间没有动作，连接就会断开。由参数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait_timeout&lt;/code&gt;控制，默认是8小时。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/head/.config/Typora/typora-user-images/image-20211026100919509.png&quot; alt=&quot;image-20211026100919509&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;长连接-vs-短连接&quot;&gt;长连接 vs 短连接&lt;/h4&gt;

&lt;p&gt;长连接和短连接是一种行为，并不是由某个参数控制。如果一个连接建立后，一直有后续行为，它就会一直维持连接状态。如果建立连接做出某些动作以后就断开，它就是短连接。&lt;/p&gt;

&lt;p&gt;长连接后续的所有操作使用的内存都是管理在该长连接的对象里，直到连接断开才会释放。所以有时候执行一些比较大的占用内存的操作后，长连接一直累积，可能会导致OOM，MySQL重启。&lt;/p&gt;

&lt;h3 id=&quot;查询缓存&quot;&gt;查询缓存&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;MySQL 8 以后将整个缓存模块删除了，不再提供查询缓存功能。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缓存顾名思义是用来提高查询速度的，但是由于缓存失效太频繁，只要对表有更新，会导致整个表的缓存失效，然后又要重新建立缓存，所以最后权衡下来把缓存模块拿掉了。&lt;/p&gt;

&lt;p&gt;但是对于静态表，读远远多于写的表，比如配置表，可以使用缓存。对于还提供查询缓存的版本，可以将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;query_cache_type&lt;/code&gt; 设置为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DEMAND&lt;/code&gt;，即按需使用，在需要的时候加上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL_CAHCE&lt;/code&gt; 即可。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SQL_CACHE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;分析器&quot;&gt;分析器&lt;/h3&gt;

&lt;p&gt;主要作用： 词法分析和语法分析。&lt;/p&gt;

&lt;p&gt;词法分析：分析每个单词代表什么含义，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select&lt;/code&gt; 代表查询，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 表示表名，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 表示列名。&lt;/p&gt;

&lt;p&gt;语法分析：分析语句是否符合sql语法规范，经常看见的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;You have an error in your SQL syntax&lt;/code&gt; 就是在这个阶段。&lt;/p&gt;

&lt;h3 id=&quot;优化器&quot;&gt;优化器&lt;/h3&gt;

&lt;p&gt;主要作用：决定选择哪个索引或者join的连接顺序。&lt;/p&gt;

&lt;p&gt;不同的索引、不同的表连接顺序会对执行效率有很大影响。&lt;/p&gt;

&lt;h3 id=&quot;执行器&quot;&gt;执行器&lt;/h3&gt;

&lt;p&gt;主要作用：调用存储引擎提供的接口完成操作，如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;取 id=1 的数据&lt;/code&gt;。存储引擎是以插件的形式接入MySQL的，可以把存储引擎看作一个黑盒，它对外提供了很多接口，只需要调用即可。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysql.slow_log&lt;/code&gt; 中会看到两个值，一个是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;row_examined&lt;/code&gt;，表示调用存储引擎接口的次数，Server层面。另一个是引擎内部的扫描行数。这两个值并不相同。&lt;/p&gt;

</description>
        <pubDate>Wed, 18 Aug 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2021/08/18/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/08/18/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</guid>
        
        <category>mysql</category>
        
        
      </item>
    
  </channel>
</rss>
