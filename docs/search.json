[

{
"title"    : "Git基本原理",
"category" : "",
"tags"     : "Git",
"url"      : "/blog/2021/04/13/git/",
"date"     : "2021-04-13 00:00:00 +0800",
"content"  : "把 Git 看作是一个文件系统，这很重要，事实上它就是一个小型的文件系统。先创建一个空目录my_repo，进入该目录，接下来的所有操作都在这个目录内，建议按顺序阅读。git init 做了什么git init 会在当前目录内创建一个 .git 目录，包含如下内容1234567891011121314151617181920212223242526272829❯ cd .git❯ tree ..├── branches├── config├── description├── HEAD├── hooks│   ├── applypatch-msg.sample│   ├── commit-msg.sample│   ├── fsmonitor-watchman.sample│   ├── post-update.sample│   ├── pre-applypatch.sample│   ├── pre-commit.sample│   ├── pre-merge-commit.sample│   ├── prepare-commit-msg.sample│   ├── pre-push.sample│   ├── pre-rebase.sample│   ├── pre-receive.sample│   ├── push-to-checkout.sample│   └── update.sample├── info│   └── exclude├── objects│   ├── info│   └── pack└── refs    ├── heads    └── tags看看 git status 的输出1234567❯ cd ..❯ git status位于分支 master尚无提交无文件要提交（创建/拷贝文件并使用 git add 建立跟踪）告诉我们当前位于分支 master，git 是如何知道的，其实是存储在 HEAD 文件中12❯ cat .git/HEADref: refs/heads/master再看 git branch，结果是空，因为 .git/refs/heads 下还没有任何东西，这里就是存储分支的地方git add 做了什么创建一个文件1234❯ echo 123 gt; a.txt❯ ll总用量 4-rw-r--r-- 1 head head 4  4月 13 23:51 a.txt此时 .git 中的内容没有发生任何变化执行 git add a.txt 后再查看 .git 中的内容123456789101112131415161718192021222324252627282930313233❯ git add a.txt❯ tree .git.git├── branches├── config├── description├── HEAD├── hooks│   ├── applypatch-msg.sample│   ├── commit-msg.sample│   ├── fsmonitor-watchman.sample│   ├── post-update.sample│   ├── pre-applypatch.sample│   ├── pre-commit.sample│   ├── pre-merge-commit.sample│   ├── prepare-commit-msg.sample│   ├── pre-push.sample│   ├── pre-rebase.sample│   ├── pre-receive.sample│   ├── push-to-checkout.sample│   └── update.sample├── index├── info│   └── exclude├── objects│   ├── 19│   │   └── 0a18037c64c43e6b11489df4bf0b9eb6d2c9bf│   ├── info│   └── pack└── refs    ├── heads    └── tagsobjects 中有新增的东西，用 git cat-file 看一下1234❯ git cat-file -t 190a18037c64c43e6b11489df4bf0b9eb6d2c9bfblob❯ git cat-file -p 190a18037c64c43e6b11489df4bf0b9eb6d2c9bf123可以看到该文件类型是 blob，文件内容是 123，就是 a.txt 的内容。blob是 git 文件系统 中的一种文件类型，即二进制大对象，用于存储文件的内容 (注意，只保存文件的内容，不保存metadata如文件名、创建时间等信息)，文件内容使用 zlib的deflat 压缩算法，文件名采用 sha-1 哈希算法(20个字节，160个bit，40个十六进制)，取第1个字节作目录名，剩下19个字节作文件名。所以 objects 下最多会有 256 个目录，这样做是为了提高查找速度。除此之外，还多了一个 index 文件，也就是常说的 stage area (暂存区)，它们是一个意思。  The index is a binary file (generally kept in . git/index ) containing a sorted list of path names, each with permissions and the SHA1 of a blob object; git ls-files can show you the contents of the index. Please note that words index, stage, and cache are the same thing in Git: they are used interchangeably.可以用 git ls-files  查看12❯ git ls-filesa.txt在这里存储了相关的metadata，可以家 --debug 查看1234567❯ git ls-files --debuga.txt  ctime: 1618345384:304625740  mtime: 1618345384:304625740  dev: 65024 ino: 20849651  uid: 1000  gid: 1000  size: 8 flags: 0查看 git status12345678❯ git status位于分支 master尚无提交要提交的变更：  （使用 git rm --cached lt;文件gt;... 以取消暂存）        新文件：   a.txt试试取消暂存1234567891011121314❯ git rm --cached a.txtrm &#39;a.txt&#39;❯ ❯ ❯ git status位于分支 master尚无提交未跟踪的文件:  （使用 git add lt;文件gt;... 以包含要提交的内容）        a.txt提交为空，但是存在尚未跟踪的文件（使用 git add 建立跟踪）再次查看 index 文件12❯ git ls-files没有内容所以常说的 git add 把文件添加到暂存区就是这个意思其他部分没有变化git commit 做了什么1234❯ git commit -m add a.txt[master（根提交） bb97804] add a.txt 1 file changed, 1 insertion(+) create mode 100644 a.txt查看 .git123456789101112131415161718192021222324252627282930313233343536373839404142❯ tree .git.git├── branches├── COMMIT_EDITMSG├── config├── description├── HEAD├── hooks│   ├── applypatch-msg.sample│   ├── commit-msg.sample│   ├── fsmonitor-watchman.sample│   ├── post-update.sample│   ├── pre-applypatch.sample│   ├── pre-commit.sample│   ├── pre-merge-commit.sample│   ├── prepare-commit-msg.sample│   ├── pre-push.sample│   ├── pre-rebase.sample│   ├── pre-receive.sample│   ├── push-to-checkout.sample│   └── update.sample├── index├── info│   └── exclude├── logs│   ├── HEAD│   └── refs│       └── heads│           └── master├── objects│   ├── 19│   │   └── 0a18037c64c43e6b11489df4bf0b9eb6d2c9bf│   ├── bb│   │   └── 978046c355c1fa2875c6a8473cea4a60d55814│   ├── c4│   │   └── 903888e91347c58a530c1f1987dfc4d203960a│   ├── info│   └── pack└── refs    ├── heads    │   └── master    └── tagsobjects 中多了2个文件，分别看下是什么12345678❯ git cat-file -t bb978046c355c1fa2875c6a8473cea4a60d55814commit❯ git cat-file -p bb978046c355c1fa2875c6a8473cea4a60d55814tree c4903888e91347c58a530c1f1987dfc4d203960aauthor lxh lt;452228391qq.comgt; 1618338183 +0800committer lxh lt;452228391qq.comgt; 1618338183 +0800add a.txt可以看到该文件类型是 commit，commit 是 git 中另一种文件类型，包含了 author、commit message 等信息。还包含了另一种叫作 tree 的文件类型，也就是多出来的另一个文件1234❯ git cat-file -t c4903888e91347c58a530c1f1987dfc4d203960atree❯ git cat-file -p c4903888e91347c58a530c1f1987dfc4d203960a100644 blob 190a18037c64c43e6b11489df4bf0b9eb6d2c9bf    a.txttree 即目录树的意思，它可以包含 blob 和 tree ，即可以包含文件和子目录，就和文件系统是一样的。所以 commit 可以理解为当前时刻的文件系统快照 snapshot，这一点很重要，所以 git 可以回到任一时刻的状态。除此之外，refs/heads 下也多出来一个文件 master，看下是什么12❯ cat .git/refs/heads/masterbb978046c355c1fa2875c6a8473cea4a60d55814所以 master 只是一个存储了 commit 文件名的文件，表示指向当前最新的 commit。所以 master 只是一个别名而已，同理任何分支都是这样，比如 dev 分支。它的作用是 HEAD 会指向它，用来表示当前是在哪个分支上。12❯ cat .git/HEADref: refs/heads/master改动文件会发生什么往 a.txt 中新增内容12345678910❯ echo 456 gt;gt; a.txt❯ less a.txt❯ git status位于分支 master尚未暂存以备提交的变更：  （使用 git add lt;文件gt;... 更新要提交的内容）  （使用 git restore lt;文件gt;... 丢弃工作区的改动）        修改：     a.txt修改尚未加入提交（使用 git add 和/或 git commit -a）执行 add1234567891011121314151617181920212223242526272829303132333435363738394041424344454647❯ git add a.txt❯ tree .git.git├── branches├── COMMIT_EDITMSG├── config├── description├── HEAD├── hooks│   ├── applypatch-msg.sample│   ├── commit-msg.sample│   ├── fsmonitor-watchman.sample│   ├── post-update.sample│   ├── pre-applypatch.sample│   ├── pre-commit.sample│   ├── pre-merge-commit.sample│   ├── prepare-commit-msg.sample│   ├── pre-push.sample│   ├── pre-rebase.sample│   ├── pre-receive.sample│   ├── push-to-checkout.sample│   └── update.sample├── index├── info│   └── exclude├── logs│   ├── HEAD│   └── refs│       └── heads│           └── master├── objects│   ├── 19│   │   └── 0a18037c64c43e6b11489df4bf0b9eb6d2c9bf│   ├── bb│   │   └── 978046c355c1fa2875c6a8473cea4a60d55814│   ├── c4│   │   └── 903888e91347c58a530c1f1987dfc4d203960a│   ├── ce│   │   └── 8c77db7f732ddc56661bc5f5cae2e1198978b1│   ├── info│   └── pack└── refs    ├── heads    │   └── master    └── tags16 directories, 26 filesobjects 中多出了一个文件12345❯ git cat-file -t ce8c77db7f732ddc56661bc5f5cae2e1198978b1blob❯ git cat-file -p ce8c77db7f732ddc56661bc5f5cae2e1198978b1123456就是 a.txt 最新的内容，而原来的 a.txt 依然还在(190a18037c64c43e6b11489df4bf0b9eb6d2c9bf)，所以 git 保存的是整个文件，而不是只是变化的部分，这也是 commit 的基础，所以 git 能回到任一时刻的状态。执行提交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051❯ git commit -m modify a.txt[master 294a462] modify a.txt 1 file changed, 1 insertion(+)❯ tree .git.git├── branches├── COMMIT_EDITMSG├── config├── description├── HEAD├── hooks│   ├── applypatch-msg.sample│   ├── commit-msg.sample│   ├── fsmonitor-watchman.sample│   ├── post-update.sample│   ├── pre-applypatch.sample│   ├── pre-commit.sample│   ├── pre-merge-commit.sample│   ├── prepare-commit-msg.sample│   ├── pre-push.sample│   ├── pre-rebase.sample│   ├── pre-receive.sample│   ├── push-to-checkout.sample│   └── update.sample├── index├── info│   └── exclude├── logs│   ├── HEAD│   └── refs│       └── heads│           └── master├── objects│   ├── 19│   │   └── 0a18037c64c43e6b11489df4bf0b9eb6d2c9bf│   ├── 29│   │   └── 4a462e98ac84b47522beb5a6c5b795bad599c2│   ├── bb│   │   └── 978046c355c1fa2875c6a8473cea4a60d55814│   ├── c4│   │   └── 903888e91347c58a530c1f1987dfc4d203960a│   ├── ce│   │   └── 8c77db7f732ddc56661bc5f5cae2e1198978b1│   ├── e9│   │   └── bbf146022722173fb1c459daf3a03f211ad3ad│   ├── info│   └── pack└── refs    ├── heads    │   └── master    └── tagsobjects 下又多了两个文件，分别看一下123456789❯ git cat-file -p 294a462e98ac84b47522beb5a6c5b795bad599c2tree e9bbf146022722173fb1c459daf3a03f211ad3adparent bb978046c355c1fa2875c6a8473cea4a60d55814author lxh lt;452228391qq.comgt; 1618340817 +0800committer lxh lt;452228391qq.comgt; 1618340817 +0800modify a.txt❯ git cat-file -t 294a462e98ac84b47522beb5a6c5b795bad599c2commit这是我们刚刚的提交，里面又多了一个 tree1234❯ git cat-file -t e9bbf146022722173fb1c459daf3a03f211ad3adtree❯ git cat-file -p e9bbf146022722173fb1c459daf3a03f211ad3ad100644 blob ce8c77db7f732ddc56661bc5f5cae2e1198978b1    a.txt感觉似曾眼熟，这不跟 c4903888e91347c58a530c1f1987dfc4d203960a 重复了吗？事实上，基于 hash 的算法，只要内容有任何改动，哈希结果都会发生变化。原tree  中包含了 a.txt，a.txt 发生了变化会导致原 tree 的哈希结果也发生变化，所以产生了一个新的 tree。可能你觉得这里有点多余，我们换个场景就明白了。( 另外可以自行查看一下，refs/heads/master 中的内容，现在应该是指向了这个新的 commit)删除 a.txt12rm a.txtgit add .此时 objects 没有发生任何变化，只有 index 发生了变化12❯ git ls-filesindex 里没有文件了，即暂存区里没有文件了，因为我们把它删除了，显而易见，工作区里也不会有这个文件了1234❯ pwd/home/head/code/my_repo❯ ll总用量 0提交123456❯ git commit -m delete a.txt[master 138a68a] delete a.txt 1 file changed, 2 deletions(-) delete mode 100644 a.txt❯ ll总用量 0objects 下又多了两个文件，这里就不展示目录树了123456789101112❯ git cat-file -t 138a68ac42b5fde646849df01c1339cfaec874c3commit❯ git cat-file -p 138a68ac42b5fde646849df01c1339cfaec874c3tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904parent 294a462e98ac84b47522beb5a6c5b795bad599c2author lxh lt;452228391qq.comgt; 1618342629 +0800committer lxh lt;452228391qq.comgt; 1618342629 +0800delete a.txt❯ git cat-file -t 4b825dc642cb6eb9a060e54bf8d69288fbee4904tree❯ git cat-file -p 4b825dc642cb6eb9a060e54bf8d69288fbee4904一个是最新的提交，一个是最新的tree，这个tree里没有任何东西现在我们来找回这个文件12345678910111213141516171819202122232425262728293031323334353637383940gt; git logcommit 138a68ac42b5fde646849df01c1339cfaec874c3 (HEAD -gt; master)Author: lxh lt;452228391qq.comgt;Date:   Wed Apr 14 03:37:09 2021 +0800    delete a.txtcommit 294a462e98ac84b47522beb5a6c5b795bad599c2Author: lxh lt;452228391qq.comgt;Date:   Wed Apr 14 03:06:57 2021 +0800    modify a.txtcommit bb978046c355c1fa2875c6a8473cea4a60d55814Author: lxh lt;452228391qq.comgt;Date:   Wed Apr 14 02:23:03 2021 +0800    add a.txt    ❯ git reset 294a462e98ac84b47522beb5a6c5b795bad599c2重置后取消暂存的变更：D       a.txt❯ git status位于分支 master尚未暂存以备提交的变更：  （使用 git add/rm lt;文件gt;... 更新要提交的内容）  （使用 git restore lt;文件gt;... 丢弃工作区的改动）        删除：     a.txt修改尚未加入提交（使用 git add 和/或 git commit -a）❯ git restore .❯ ll总用量 4-rw-r--r-- 1 head head 8  4月 14 03:43 a.txt❯ cat a.txt123456所以，由于保存了任一时刻的快照，便能很容易的恢复到任一时刻的文件系统状态。所以，得把 tree理解为系统快照，是带状态的一种对象，不能以普通文件系统的视角，虽然是同一个目录，但是有文件和没文件是两种状态；即便是同一个文件，文件改变了，那整个目录也是一种新的状态。这就是时光穿梭机！git checkout 做了什么git checkout -b dev 会在 refs/heads 下新增一个 dev 文件，文件内容为当前最新 commit ，此时应该和 master 内容是一样的，两个分支此时的状态完全一致，objects 下没有任何变化。除此之外，HEAD 的内容会更改为 ref refs/heads/dev ，表示当前分支为 dev 分支。这就是 checkout 所做的全部内容了。所以分支只是一个别名而已，指向不同的 commit，以表示不同时刻的文件系统状态。从 git 可以学到什么      链表(指针)          branch -gt; commit -gt; tree -gt; blob (subtree)      branch 只是一个 commit 的别名，或者叫指针也行      commit 如果不是第一个提交的话，还有一个 parent 属性，表示之前一个提交      git 的整个操作过程简化来说就是操作 HEAD 指针在各个 commit 之间跳转，然后根据 commit 中的 tree “渲染” 出整个文件系统            哈希          基于哈希的消息摘要能快速的标识出整个文件系统，而且 SHA-1 的碰撞概率在版本控制这个用途上来说基本可以认为不会发生      See Also Git是否考虑到SHA1碰撞的问题了？            存储整体而不是存储变化，好像 React 基本思想也是这样(当状态变化时重新渲染组件，React也可以进行时光穿梭)          这里的整体指的是文件和相关联的tree这个整体，而不是整个文件系统。其他未发生变化的blob和tree直接引用就行。      常用命令本地创建分支并推送到远程分支1git push origin branch:branch --- 本地分支与远程分支要同名删除远程分支1git push origin --delete branchSee AlsoGit internals"
} ,

{
"title"    : "Manjaro安装配置踩坑",
"category" : "",
"tags"     : "Manjaro",
"url"      : "/blog/2021/04/12/manjaro-install/",
"date"     : "2021-04-12 00:00:00 +0800",
"content"  : "LVM方式的安装我安装的版本是Manjaro 21 KDE，常规安装按图形界面方式很快，没有任何问题。但 calamares当前版本对 lvm 的支持还不是很好，直接在图形界面采用 lvm 点下一步后会马上闪退，或者进入安装过程后报各种卷创建的错误，实在无招，只能曲线救国。最开始手动创建卷，然后进图形界面选择文件系统和挂载点，安装倒是没问题了，最后也提示安装成功。但重启后找不到系统，还是会继续进入U盘。推测是 calamares 在 lvm 方式下创建 efi 分区有bug，gitHub上也有很多相关issue。试了N遍之后，最后的办法是先按常规方式安装一遍，保证重启后能正常进入系统。再用U盘进入live environment，在已分区的基础上手动创建物理卷，卷组和逻辑卷。efi 和 swap 不要动(注意在后续图形安装界面中 efi 千万别选择格式化，要的就是保留 efi 之前的内容)，其他分区可自由分配卷组和逻辑卷。最后进入图形安装界面选择挂载点和文件系统安装即可。Intel核显 + NVIDIA独显 的问题  Linus Torvalds:  NVIDIA, fuck u!安装完之后一开始正常使用没什么问题，但是一竖屏后就有撕裂现象。解决办法：安装 optimus-manager 和 optimus-manager-qt ，切换为 NVIDIA 之后就没问题了。大黄蜂方案已经过时且不再维护了，不建议使用。optimus-manager ( A Linux program to handle GPU switching on Optimus laptops)换源sudo pacman-mirros -i -c China -m rank       选中一个sudo pacman -Syy      更新软件源sudo pacman -Syu      更新全部软件安装搜狗拼音添加 archlinuxcn 软件源，/etc/pacman.conf 在最后加入SigLevel = Optional TrustAll Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/archsudo pacman -Syy      更新软件源sudo pacman -S archlinux-keyring     更新软件密钥sudo pacman -S fcitx-im     安装输入法框架sudo pacman -S fcitx-configtool     安装输入法配置工具在软件中心找到并安装 fcitx-sogoupinyin( 注意：一定要按顺序安装，不能直接安装最后一个，会导致依赖缺失，不能配置等问题)在 /etc/environment 中加入123GTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=im=fcitx重启完成微信聊天框中文乱码原因是缺失字体。下载字体 链接: https://pan.baidu.com/s/1OkeEGR4hivnWur3fDuJxrQ  密码: k4ge放到 ～/.deepinwine/Deepin-WeChat/drive_c/Windows/Fonts 目录下，点击安装即可。IDEA Ultimate 输入法候选框不跟随鼠标，一直在左下角这是一个 idea 古老又没人管的bug解决办法参考：https://ld246.com/article/1601280084643下载修改过的  JetBrainsRuntime ，在 idea.sh 启动脚本开头添加export IDEA_JDK=xport IDEA_JDK=目录/java-11.0.7-jetbrain但是有个新的问题，markdown文件 的预览按钮不见了，也懒得折腾了，写 markdown 用专门的编辑器吧，比如 TypoarIDEA 不会显示全局系统菜单Manjaro安装了 Application Title 插件后所有应用的菜单都会在顶部的全局系统菜单显示，但 IDEA 不会。官方解决办法： idea中安装 JavaFX Runtime for Plugins 插件。但是有点延迟，打开 idea 后要过一会菜单才会出来，也是很烦。美化Make Your KDE Plasma Desktop Look Better"
} 

]