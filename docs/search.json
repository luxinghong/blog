[

{
"title"    : "自己写一个starter",
"category" : "",
"tags"     : "springboot, starter",
"url"      : "/blog/2021/08/15/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAstarter/",
"date"     : "2021-08-15 00:00:00 +0800",
"content"  : "一个 starter 就是一个提供特定功能的库，它主要做了几件事：  添加了一些依赖  定义了一些属性（在application.properties 或 application.yml 中使用），可以理解为一些功能的开关，或者是初始值  根据某些条件动态的定义一些bean，这些 bean 就是提供功能的对象，给客户端使用目标：实现一个starter，提供 json 序列化功能，有两种序列化方式可供选择：fastjson 和 gson使用场景1： 由用户在属性文件中选择使用哪一种使用场景2： 由用户添加某个具体实现的依赖来选择使用哪一种使用场景1： 由用户在属性文件中选择使用哪一种      新建一个maven项目，命名为 json-spring-boot-starter（所有第三方库都命名为xxx-spring-boot-starter，spring 自己的 starter 命名为 spring-boot-starter-xxx）    pom 文件如下，重点是引入的依赖：spring-boot-autoconfigure、fastjson、gson    123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263lt;?xml version=1.0 encoding=UTF-8?gt;lt;project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance         xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsdgt;    lt;modelVersiongt;4.0.0lt;/modelVersiongt;    lt;groupIdgt;com.examplelt;/groupIdgt;    lt;artifactIdgt;json-spring-boot-starterlt;/artifactIdgt;    lt;versiongt;0.0.1-SNAPSHOTlt;/versiongt;    lt;namegt;json-spring-boot-starterlt;/namegt;    lt;descriptiongt;Json Serializer Starterlt;/descriptiongt;       lt;propertiesgt;        lt;java.versiongt;11lt;/java.versiongt;    lt;/propertiesgt;       lt;dependencyManagementgt;        lt;dependenciesgt;            lt;dependencygt;                lt;groupIdgt;org.springframework.bootlt;/groupIdgt;                lt;artifactIdgt;spring-boot-dependencieslt;/artifactIdgt;                lt;versiongt;2.5.2lt;/versiongt;                lt;typegt;pomlt;/typegt;                lt;scopegt;importlt;/scopegt;            lt;/dependencygt;        lt;/dependenciesgt;    lt;/dependencyManagementgt;       lt;dependenciesgt;        lt;dependencygt;            lt;groupIdgt;org.springframework.bootlt;/groupIdgt;            lt;artifactIdgt;spring-boot-autoconfigurelt;/artifactIdgt;        lt;/dependencygt;           lt;dependencygt;            lt;groupIdgt;com.alibabalt;/groupIdgt;            lt;artifactIdgt;fastjsonlt;/artifactIdgt;            lt;versiongt;1.2.76lt;/versiongt;        lt;/dependencygt;        lt;dependencygt;            lt;groupIdgt;com.google.code.gsonlt;/groupIdgt;            lt;artifactIdgt;gsonlt;/artifactIdgt;        lt;/dependencygt;           lt;dependencygt;            lt;groupIdgt;org.springframework.bootlt;/groupIdgt;            lt;artifactIdgt;spring-boot-starter-testlt;/artifactIdgt;            lt;scopegt;testlt;/scopegt;        lt;/dependencygt;    lt;/dependenciesgt;       lt;buildgt;        lt;pluginsgt;            lt;plugingt;                lt;groupIdgt;org.apache.maven.pluginslt;/groupIdgt;                lt;artifactIdgt;maven-compiler-pluginlt;/artifactIdgt;                lt;versiongt;3.8.1lt;/versiongt;                lt;configurationgt;                    lt;sourcegt;11lt;/sourcegt;                    lt;targetgt;11lt;/targetgt;                lt;/configurationgt;            lt;/plugingt;        lt;/pluginsgt;    lt;/buildgt;lt;/projectgt;            定义一个 JsonSerializer 接口，提供两种实现    123public interface JsonSerializer     String serialize(Object obj);        123456public class FastjsonSerializer implements JsonSerializer     Override    public String serialize(Object obj)         return Fastjson:  + JSON.toJSONString(obj);            1234567public class GsonSerializer implements JsonSerializer     Override    public String serialize(Object obj)         Gson gson = new Gson();        return Gson:  + gson.toJson(obj);            ​        定义一个 JsonTemplate，这是最终用户要使用的工具类  1234567891011   public class JsonTemplate        private final JsonSerializer serializer;          public JsonTemplate(JsonSerializer serializer)            this.serializer = serializer;                 public String serialize(Object obj)            return this.serializer.serialize(obj);          ​  实现自动配置，这里根据属性来选择，属性名定义为 json.serializer.type，用到ConditionalOnProperty 注解。没有指定属性时使用 fastjson（matchIfMissing = true）1234567891011121314151617181920212223   Configuration   public class JsonSerializerAutoConfiguration        Bean       public JsonTemplate jsonTemplate(JsonSerializer serializer)            return new JsonTemplate(serializer);                 Bean       ConditionalOnProperty(               prefix = json.serializer,               name = type,               havingValue = fastjson,               matchIfMissing = true)       public JsonSerializer fastjsonSerializer()            return new FastjsonSerializer();                 Bean       ConditionalOnProperty(prefix = json.serializer, name = type, havingValue = gson)       public JsonSerializer gsonSerializer()            return new GsonSerializer();          ​  在 resources 下创建一个文件 META-INF/spring.factories12   org.springframework.boot.autoconfigure.EnableAutoConfiguration=#92;   com.example.json.JsonSerializerAutoConfigurationmvn install 到本地，接下来写客户端验证一下12345        lt;dependencygt;            lt;groupIdgt;com.examplelt;/groupIdgt;            lt;artifactIdgt;json-spring-boot-starterlt;/artifactIdgt;            lt;versiongt;0.0.1-SNAPSHOTlt;/versiongt;        lt;/dependencygt;12345678910111213141516171819SpringBootApplicationSlf4jpublic class StarterClientApplication implements CommandLineRunner     Autowired private JsonTemplate jsonTemplate;    public static void main(String[] args)         SpringApplication.run(StarterClientApplication.class, args);        Override    public void run(String... args) throws Exception         Person person = new Person();        person.setName(张三);        person.setAge(30);        log.info(jsonTemplate.serialize(person));    没有指定属性时，输出为：1Fastjson: age:30,name:张三指定属性为json时：123json:  serializer:    type: gson1Gson: name:张三,age:30为属性文件加上智能提示      为属性创建一个类，打上 ConfigurationProperties 注解    12345678910111213141516171819ConfigurationProperties(prefix = json.serializer)public class JsonSerializerProperties        /** 序列化类型：fastjson 和 gson */    private Type type;       public Type getType()         return type;           public void setType(Type type)         this.type = type;           public enum Type         FASTJSON,        GSON                改造自动配置类    12345678910111213ConfigurationEnableConfigurationProperties(JsonSerializerProperties.class)public class JsonSerializerAutoConfiguration     Bean    public JsonTemplate jsonTemplate(JsonSerializerProperties serializerProperties)         JsonSerializerProperties.Type type = serializerProperties.getType();        JsonSerializer serializer =                (type == null || JsonSerializerProperties.Type.FASTJSON.equals(type))                        ? new FastjsonSerializer()                        : new GsonSerializer();        return new JsonTemplate(serializer);                加入spring-boot-configuration-processor依赖，注意一定不要搞错了，之前我没注意写成 spring-boot-autoconfigure-processor，害我调半天    12345        lt;dependencygt;            lt;groupIdgt;org.springframework.bootlt;/groupIdgt;            lt;artifactIdgt;spring-boot-configuration-processorlt;/artifactIdgt;            lt;optionalgt;truelt;/optionalgt;        lt;/dependencygt;        这个注解会在 META-INF 下生成一个元数据文件 spring-configuration-metadata.json    123456789101112131415161718  groups: [          name: json.serializer,      type: com.example.json.JsonSerializerProperties,      sourceType: com.example.json.JsonSerializerProperties      ],  properties: [          name: json.serializer.type,      type: com.example.json.JsonSerializerPropertiesType,      description: 序列化类型：fastjson 和 gson,      sourceType: com.example.json.JsonSerializerProperties      ],  hints: []        description 来自字段上的注释    12/** 序列化类型：fastjson 和 gson */    private Type type;        可以手动编辑该json文件，加上 defaultValue。  使用场景2：由用户添加某个具体实现的依赖来选择使用哪一种      改造自动配置类，用到 ConditionalOnClass注解。注意这里bean定义的顺序，JsonTemplate一定要放在最后，因为它依赖于JsonSerializer    12345678910111213141516171819202122ConfigurationEnableConfigurationProperties(JsonSerializerProperties.class)public class JsonSerializerAutoConfiguration        Bean    ConditionalOnClass(JSON.class)    Primary    public JsonSerializer fastjsonSerializer()         return new FastjsonSerializer();           Bean    ConditionalOnClass(Gson.class)    public JsonSerializer gsonSerializer()         return new GsonSerializer();           Bean    public JsonTemplate jsonTemplate(JsonSerializer serializer)         return new JsonTemplate(serializer);                将 fastjson 和 gson 依赖设置成可选项    1234567891011        lt;dependencygt;            lt;groupIdgt;com.alibabalt;/groupIdgt;            lt;artifactIdgt;fastjsonlt;/artifactIdgt;            lt;versiongt;1.2.76lt;/versiongt;            lt;optionalgt;truelt;/optionalgt;        lt;/dependencygt;        lt;dependencygt;            lt;groupIdgt;com.google.code.gsonlt;/groupIdgt;            lt;artifactIdgt;gsonlt;/artifactIdgt;            lt;optionalgt;truelt;/optionalgt;        lt;/dependencygt;      测试一把，客户端先添加fastjson的依赖12345678910        lt;dependencygt;            lt;groupIdgt;com.examplelt;/groupIdgt;            lt;artifactIdgt;json-spring-boot-starterlt;/artifactIdgt;            lt;versiongt;0.0.1-SNAPSHOTlt;/versiongt;        lt;/dependencygt;        lt;dependencygt;            lt;groupIdgt;com.alibabalt;/groupIdgt;            lt;artifactIdgt;fastjsonlt;/artifactIdgt;            lt;versiongt;1.2.76lt;/versiongt;        lt;/dependencygt;输出为：1Fastjson: age:30,name:张三换成gson123456789        lt;dependencygt;            lt;groupIdgt;com.examplelt;/groupIdgt;            lt;artifactIdgt;json-spring-boot-starterlt;/artifactIdgt;            lt;versiongt;0.0.1-SNAPSHOTlt;/versiongt;        lt;/dependencygt;        lt;dependencygt;            lt;groupIdgt;com.google.code.gsonlt;/groupIdgt;            lt;artifactIdgt;gsonlt;/artifactIdgt;        lt;/dependencygt;输出为：1Gson: name:张三,age:30如果两个依赖都没有添加，会报错提示：123Action:Consider defining a bean of type &#39;com.example.json.JsonSerializer&#39; in your configuration.这个信息也可以自定义成更友好的提示信息，这一part暂时不研究了，结束！"
} ,

{
"title"    : "正确理解浮点数",
"category" : "",
"tags"     : "浮点数, 数据类型",
"url"      : "/blog/2021/04/25/float/",
"date"     : "2021-04-25 00:00:00 +0800",
"content"  : "首先，浮点数是一种数字的表示方式，而不是指小数很多人一提到浮点数，就说是小数，这是不对的。浮点数只是一种数字的表示方式，数字是多少就是多少，它就在那里不会改变，改变的只是人类表示它们的方式。比如给定一个数 10，能确定它是浮点数还是定点数吗？不能！我们必须知道这个数是如何存储的，即底层是如何来表示这个数的，才能说它是定点数还是浮点数。这其实类似于十进制中的科学计数法，比如 1234.5678这个数，这个数本身不会改变，是多少永远是多少，变的是表示它的方式，我们可以以多种不同的方式来表示这个数：  1.2345678 #92;times 10^3  123.45678 #92;times 10  0.12345678 #92;times 10^4  12345678 #92;times 10^-4可以看到，小数点的位置是浮动的，这才是浮点数名字的由来。再次强调，浮点数指的是表示数字的方式，而不是数字本身。至于大家常提到的IEEE754，它是一个标准，即规定了大家统一采用哪种方式来表示和存储数据，它规定尾数部分格式为 1.xxxx，具体存储时1省略，其他细节不再赘述。为什么要使用浮点数简单来说，同样的位数，浮点数表示的范围更大比如 int 和 float 同是 32bitint的最大值为 2^31-1 = 2.147483647E9 = 2147483647float的最大值为 (2-2^23)#92;cdot2^127 = 0#92;mboxx1.fffffeP+127f = 3.4028235E38f         这表示范围可比 int 大多了为什么float的精度是6~7位？因为float的尾数部分有23位，即可以用23位二进制来表示一个数，指数部分不影响精度，只影响范围，因为有效数字是从第一个非0位算起。事实上还要加上规格化尾数省略的1，所以问题就变成24位二进制位可以表示多少位十进制？#92;[#92;beginalign*2^24  amp;= 10^x#92;#92;x  amp;= log_102^24 = 24 #92;cdot log_102 = 7.22471989594#92;endalign*#92;]12float f = 0.123456789f;System.out.println(f); // 0.12345679  只能保证7位精度"
} ,

{
"title"    : "Git基本原理",
"category" : "",
"tags"     : "Git",
"url"      : "/blog/2021/04/13/git/",
"date"     : "2021-04-13 00:00:00 +0800",
"content"  : "把 Git 看作是一个文件系统，这很重要，事实上它就是一个小型的文件系统。先创建一个空目录my_repo，进入该目录，接下来的所有操作都在这个目录内，建议按顺序阅读。git init 做了什么git init 会在当前目录内创建一个 .git 目录，包含如下内容1234567891011121314151617181920212223242526272829❯ cd .git❯ tree ..├── branches├── config├── description├── HEAD├── hooks│   ├── applypatch-msg.sample│   ├── commit-msg.sample│   ├── fsmonitor-watchman.sample│   ├── post-update.sample│   ├── pre-applypatch.sample│   ├── pre-commit.sample│   ├── pre-merge-commit.sample│   ├── prepare-commit-msg.sample│   ├── pre-push.sample│   ├── pre-rebase.sample│   ├── pre-receive.sample│   ├── push-to-checkout.sample│   └── update.sample├── info│   └── exclude├── objects│   ├── info│   └── pack└── refs    ├── heads    └── tags看看 git status 的输出1234567❯ cd ..❯ git status位于分支 master尚无提交无文件要提交（创建/拷贝文件并使用 git add 建立跟踪）告诉我们当前位于分支 master，git 是如何知道的，其实是存储在 HEAD 文件中12❯ cat .git/HEADref: refs/heads/master再看 git branch，结果是空，因为 .git/refs/heads 下还没有任何东西，这里就是存储分支的地方git add 做了什么创建一个文件1234❯ echo 123 gt; a.txt❯ ll总用量 4-rw-r--r-- 1 head head 4  4月 13 23:51 a.txt此时 .git 中的内容没有发生任何变化执行 git add a.txt 后再查看 .git 中的内容123456789101112131415161718192021222324252627282930313233❯ git add a.txt❯ tree .git.git├── branches├── config├── description├── HEAD├── hooks│   ├── applypatch-msg.sample│   ├── commit-msg.sample│   ├── fsmonitor-watchman.sample│   ├── post-update.sample│   ├── pre-applypatch.sample│   ├── pre-commit.sample│   ├── pre-merge-commit.sample│   ├── prepare-commit-msg.sample│   ├── pre-push.sample│   ├── pre-rebase.sample│   ├── pre-receive.sample│   ├── push-to-checkout.sample│   └── update.sample├── index├── info│   └── exclude├── objects│   ├── 19│   │   └── 0a18037c64c43e6b11489df4bf0b9eb6d2c9bf│   ├── info│   └── pack└── refs    ├── heads    └── tagsobjects 中有新增的东西，用 git cat-file 看一下1234❯ git cat-file -t 190a18037c64c43e6b11489df4bf0b9eb6d2c9bfblob❯ git cat-file -p 190a18037c64c43e6b11489df4bf0b9eb6d2c9bf123可以看到该文件类型是 blob，文件内容是 123，就是 a.txt 的内容。blob是 git 文件系统 中的一种文件类型，即二进制大对象，用于存储文件的内容 (注意，只保存文件的内容，不保存metadata如文件名、创建时间等信息)，文件内容使用 zlib的deflat 压缩算法，文件名采用 sha-1 哈希算法(20个字节，160个bit，40个十六进制)，取第1个字节作目录名，剩下19个字节作文件名。所以 objects 下最多会有 256 个目录，这样做是为了提高查找速度。除此之外，还多了一个 index 文件，也就是常说的 stage area (暂存区)，它们是一个意思。  The index is a binary file (generally kept in . git/index ) containing a sorted list of path names, each with permissions and the SHA1 of a blob object; git ls-files can show you the contents of the index. Please note that words index, stage, and cache are the same thing in Git: they are used interchangeably.可以用 git ls-files  查看12❯ git ls-filesa.txt在这里存储了相关的metadata，可以家 --debug 查看1234567❯ git ls-files --debuga.txt  ctime: 1618345384:304625740  mtime: 1618345384:304625740  dev: 65024 ino: 20849651  uid: 1000  gid: 1000  size: 8 flags: 0查看 git status12345678❯ git status位于分支 master尚无提交要提交的变更：  （使用 git rm --cached lt;文件gt;... 以取消暂存）        新文件：   a.txt试试取消暂存1234567891011121314❯ git rm --cached a.txtrm &#39;a.txt&#39;❯ ❯ ❯ git status位于分支 master尚无提交未跟踪的文件:  （使用 git add lt;文件gt;... 以包含要提交的内容）        a.txt提交为空，但是存在尚未跟踪的文件（使用 git add 建立跟踪）再次查看 index 文件12❯ git ls-files没有内容所以常说的 git add 把文件添加到暂存区就是这个意思其他部分没有变化git commit 做了什么1234❯ git commit -m add a.txt[master（根提交） bb97804] add a.txt 1 file changed, 1 insertion(+) create mode 100644 a.txt查看 .git123456789101112131415161718192021222324252627282930313233343536373839404142❯ tree .git.git├── branches├── COMMIT_EDITMSG├── config├── description├── HEAD├── hooks│   ├── applypatch-msg.sample│   ├── commit-msg.sample│   ├── fsmonitor-watchman.sample│   ├── post-update.sample│   ├── pre-applypatch.sample│   ├── pre-commit.sample│   ├── pre-merge-commit.sample│   ├── prepare-commit-msg.sample│   ├── pre-push.sample│   ├── pre-rebase.sample│   ├── pre-receive.sample│   ├── push-to-checkout.sample│   └── update.sample├── index├── info│   └── exclude├── logs│   ├── HEAD│   └── refs│       └── heads│           └── master├── objects│   ├── 19│   │   └── 0a18037c64c43e6b11489df4bf0b9eb6d2c9bf│   ├── bb│   │   └── 978046c355c1fa2875c6a8473cea4a60d55814│   ├── c4│   │   └── 903888e91347c58a530c1f1987dfc4d203960a│   ├── info│   └── pack└── refs    ├── heads    │   └── master    └── tagsobjects 中多了2个文件，分别看下是什么12345678❯ git cat-file -t bb978046c355c1fa2875c6a8473cea4a60d55814commit❯ git cat-file -p bb978046c355c1fa2875c6a8473cea4a60d55814tree c4903888e91347c58a530c1f1987dfc4d203960aauthor lxh lt;452228391qq.comgt; 1618338183 +0800committer lxh lt;452228391qq.comgt; 1618338183 +0800add a.txt可以看到该文件类型是 commit，commit 是 git 中另一种文件类型，包含了 author、commit message 等信息。还包含了另一种叫作 tree 的文件类型，也就是多出来的另一个文件1234❯ git cat-file -t c4903888e91347c58a530c1f1987dfc4d203960atree❯ git cat-file -p c4903888e91347c58a530c1f1987dfc4d203960a100644 blob 190a18037c64c43e6b11489df4bf0b9eb6d2c9bf    a.txttree 即目录树的意思，它可以包含 blob 和 tree ，即可以包含文件和子目录，就和文件系统是一样的。所以 commit 可以理解为当前时刻的文件系统快照 snapshot，这一点很重要，所以 git 可以回到任一时刻的状态。除此之外，refs/heads 下也多出来一个文件 master，看下是什么12❯ cat .git/refs/heads/masterbb978046c355c1fa2875c6a8473cea4a60d55814所以 master 只是一个存储了 commit 文件名的文件，表示指向当前最新的 commit。所以 master 只是一个别名而已，同理任何分支都是这样，比如 dev 分支。它的作用是 HEAD 会指向它，用来表示当前是在哪个分支上。12❯ cat .git/HEADref: refs/heads/master改动文件会发生什么往 a.txt 中新增内容12345678910❯ echo 456 gt;gt; a.txt❯ less a.txt❯ git status位于分支 master尚未暂存以备提交的变更：  （使用 git add lt;文件gt;... 更新要提交的内容）  （使用 git restore lt;文件gt;... 丢弃工作区的改动）        修改：     a.txt修改尚未加入提交（使用 git add 和/或 git commit -a）执行 add1234567891011121314151617181920212223242526272829303132333435363738394041424344454647❯ git add a.txt❯ tree .git.git├── branches├── COMMIT_EDITMSG├── config├── description├── HEAD├── hooks│   ├── applypatch-msg.sample│   ├── commit-msg.sample│   ├── fsmonitor-watchman.sample│   ├── post-update.sample│   ├── pre-applypatch.sample│   ├── pre-commit.sample│   ├── pre-merge-commit.sample│   ├── prepare-commit-msg.sample│   ├── pre-push.sample│   ├── pre-rebase.sample│   ├── pre-receive.sample│   ├── push-to-checkout.sample│   └── update.sample├── index├── info│   └── exclude├── logs│   ├── HEAD│   └── refs│       └── heads│           └── master├── objects│   ├── 19│   │   └── 0a18037c64c43e6b11489df4bf0b9eb6d2c9bf│   ├── bb│   │   └── 978046c355c1fa2875c6a8473cea4a60d55814│   ├── c4│   │   └── 903888e91347c58a530c1f1987dfc4d203960a│   ├── ce│   │   └── 8c77db7f732ddc56661bc5f5cae2e1198978b1│   ├── info│   └── pack└── refs    ├── heads    │   └── master    └── tags16 directories, 26 filesobjects 中多出了一个文件12345❯ git cat-file -t ce8c77db7f732ddc56661bc5f5cae2e1198978b1blob❯ git cat-file -p ce8c77db7f732ddc56661bc5f5cae2e1198978b1123456就是 a.txt 最新的内容，而原来的 a.txt 依然还在(190a18037c64c43e6b11489df4bf0b9eb6d2c9bf)，所以 git 保存的是整个文件，而不是只是变化的部分，这也是 commit 的基础，所以 git 能回到任一时刻的状态。执行提交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051❯ git commit -m modify a.txt[master 294a462] modify a.txt 1 file changed, 1 insertion(+)❯ tree .git.git├── branches├── COMMIT_EDITMSG├── config├── description├── HEAD├── hooks│   ├── applypatch-msg.sample│   ├── commit-msg.sample│   ├── fsmonitor-watchman.sample│   ├── post-update.sample│   ├── pre-applypatch.sample│   ├── pre-commit.sample│   ├── pre-merge-commit.sample│   ├── prepare-commit-msg.sample│   ├── pre-push.sample│   ├── pre-rebase.sample│   ├── pre-receive.sample│   ├── push-to-checkout.sample│   └── update.sample├── index├── info│   └── exclude├── logs│   ├── HEAD│   └── refs│       └── heads│           └── master├── objects│   ├── 19│   │   └── 0a18037c64c43e6b11489df4bf0b9eb6d2c9bf│   ├── 29│   │   └── 4a462e98ac84b47522beb5a6c5b795bad599c2│   ├── bb│   │   └── 978046c355c1fa2875c6a8473cea4a60d55814│   ├── c4│   │   └── 903888e91347c58a530c1f1987dfc4d203960a│   ├── ce│   │   └── 8c77db7f732ddc56661bc5f5cae2e1198978b1│   ├── e9│   │   └── bbf146022722173fb1c459daf3a03f211ad3ad│   ├── info│   └── pack└── refs    ├── heads    │   └── master    └── tagsobjects 下又多了两个文件，分别看一下123456789❯ git cat-file -p 294a462e98ac84b47522beb5a6c5b795bad599c2tree e9bbf146022722173fb1c459daf3a03f211ad3adparent bb978046c355c1fa2875c6a8473cea4a60d55814author lxh lt;452228391qq.comgt; 1618340817 +0800committer lxh lt;452228391qq.comgt; 1618340817 +0800modify a.txt❯ git cat-file -t 294a462e98ac84b47522beb5a6c5b795bad599c2commit这是我们刚刚的提交，里面又多了一个 tree1234❯ git cat-file -t e9bbf146022722173fb1c459daf3a03f211ad3adtree❯ git cat-file -p e9bbf146022722173fb1c459daf3a03f211ad3ad100644 blob ce8c77db7f732ddc56661bc5f5cae2e1198978b1    a.txt感觉似曾眼熟，这不跟 c4903888e91347c58a530c1f1987dfc4d203960a 重复了吗？事实上，基于 hash 的算法，只要内容有任何改动，哈希结果都会发生变化。原tree  中包含了 a.txt，a.txt 发生了变化会导致原 tree 的哈希结果也发生变化，所以产生了一个新的 tree。可能你觉得这里有点多余，我们换个场景就明白了。( 另外可以自行查看一下，refs/heads/master 中的内容，现在应该是指向了这个新的 commit)删除 a.txt12rm a.txtgit add .此时 objects 没有发生任何变化，只有 index 发生了变化12❯ git ls-filesindex 里没有文件了，即暂存区里没有文件了，因为我们把它删除了，显而易见，工作区里也不会有这个文件了1234❯ pwd/home/head/code/my_repo❯ ll总用量 0提交123456❯ git commit -m delete a.txt[master 138a68a] delete a.txt 1 file changed, 2 deletions(-) delete mode 100644 a.txt❯ ll总用量 0objects 下又多了两个文件，这里就不展示目录树了123456789101112❯ git cat-file -t 138a68ac42b5fde646849df01c1339cfaec874c3commit❯ git cat-file -p 138a68ac42b5fde646849df01c1339cfaec874c3tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904parent 294a462e98ac84b47522beb5a6c5b795bad599c2author lxh lt;452228391qq.comgt; 1618342629 +0800committer lxh lt;452228391qq.comgt; 1618342629 +0800delete a.txt❯ git cat-file -t 4b825dc642cb6eb9a060e54bf8d69288fbee4904tree❯ git cat-file -p 4b825dc642cb6eb9a060e54bf8d69288fbee4904一个是最新的提交，一个是最新的tree，这个tree里没有任何东西现在我们来找回这个文件12345678910111213141516171819202122232425262728293031323334353637383940gt; git logcommit 138a68ac42b5fde646849df01c1339cfaec874c3 (HEAD -gt; master)Author: lxh lt;452228391qq.comgt;Date:   Wed Apr 14 03:37:09 2021 +0800    delete a.txtcommit 294a462e98ac84b47522beb5a6c5b795bad599c2Author: lxh lt;452228391qq.comgt;Date:   Wed Apr 14 03:06:57 2021 +0800    modify a.txtcommit bb978046c355c1fa2875c6a8473cea4a60d55814Author: lxh lt;452228391qq.comgt;Date:   Wed Apr 14 02:23:03 2021 +0800    add a.txt    ❯ git reset 294a462e98ac84b47522beb5a6c5b795bad599c2重置后取消暂存的变更：D       a.txt❯ git status位于分支 master尚未暂存以备提交的变更：  （使用 git add/rm lt;文件gt;... 更新要提交的内容）  （使用 git restore lt;文件gt;... 丢弃工作区的改动）        删除：     a.txt修改尚未加入提交（使用 git add 和/或 git commit -a）❯ git restore .❯ ll总用量 4-rw-r--r-- 1 head head 8  4月 14 03:43 a.txt❯ cat a.txt123456所以，由于保存了任一时刻的快照，便能很容易的恢复到任一时刻的文件系统状态。所以，得把 tree理解为系统快照，是带状态的一种对象，不能以普通文件系统的视角，虽然是同一个目录，但是有文件和没文件是两种状态；即便是同一个文件，文件改变了，那整个目录也是一种新的状态。这就是时光穿梭机！git checkout 做了什么git checkout -b dev 会在 refs/heads 下新增一个 dev 文件，文件内容为当前最新 commit ，此时应该和 master 内容是一样的，两个分支此时的状态完全一致，objects 下没有任何变化。除此之外，HEAD 的内容会更改为 ref refs/heads/dev ，表示当前分支为 dev 分支。这就是 checkout 所做的全部内容了。所以分支只是一个别名而已，指向不同的 commit，以表示不同时刻的文件系统状态。从 git 可以学到什么      链表(指针)          branch -gt; commit -gt; tree -gt; blob (subtree)      branch 只是一个 commit 的别名，或者叫指针也行      commit 如果不是第一个提交的话，还有一个 parent 属性，表示之前一个提交      git 的整个操作过程简化来说就是操作 HEAD 指针在各个 commit 之间跳转，然后根据 commit 中的 tree “渲染” 出整个文件系统            哈希          基于哈希的消息摘要能快速的标识出整个文件系统，而且 SHA-1 的碰撞概率在版本控制这个用途上来说基本可以认为不会发生      See Also Git是否考虑到SHA1碰撞的问题了？            存储整体而不是存储变化，好像 React 基本思想也是这样(当状态变化时重新渲染组件，React也可以进行时光穿梭)          这里的整体指的是文件和相关联的tree这个整体，而不是整个文件系统。其他未发生变化的blob和tree直接引用就行。      常用命令本地创建分支并推送到远程分支1git push origin branch:branch --- 本地分支与远程分支要同名删除远程分支1git push origin --delete branchSee AlsoGit internals"
} ,

{
"title"    : "Manjaro安装配置踩坑",
"category" : "",
"tags"     : "Manjaro",
"url"      : "/blog/2021/04/12/manjaro-install/",
"date"     : "2021-04-12 00:00:00 +0800",
"content"  : "LVM方式的安装我安装的版本是Manjaro 21 KDE，常规安装按图形界面方式很快，没有任何问题。但 calamares当前版本对 lvm 的支持还不是很好，直接在图形界面采用 lvm 点下一步后会马上闪退，或者进入安装过程后报各种卷创建的错误，实在无招，只能曲线救国。最开始手动创建卷，然后进图形界面选择文件系统和挂载点，安装倒是没问题了，最后也提示安装成功。但重启后找不到系统，还是会继续进入U盘。推测是 calamares 在 lvm 方式下创建 efi 分区有bug，gitHub上也有很多相关issue。试了N遍之后，最后的办法是先按常规方式安装一遍，保证重启后能正常进入系统。再用U盘进入live environment，在已分区的基础上手动创建物理卷，卷组和逻辑卷。efi 和 swap 不要动(注意在后续图形安装界面中 efi 千万别选择格式化，要的就是保留 efi 之前的内容)，其他分区可自由分配卷组和逻辑卷。最后进入图形安装界面选择挂载点和文件系统安装即可。Intel核显 + NVIDIA独显 的问题  Linus Torvalds:  NVIDIA, fuck u!安装完之后一开始正常使用没什么问题，但是一竖屏后就有撕裂现象。解决办法：安装 optimus-manager 和 optimus-manager-qt ，切换为 NVIDIA 之后就没问题了。大黄蜂方案已经过时且不再维护了，不建议使用。optimus-manager ( A Linux program to handle GPU switching on Optimus laptops)文档中有关于 Gnome and GDM users 和 IMPORTANT : Manjaro KDE users 的注意事项，一定要看，否则可能会导致切换后黑屏、无法启动的问题，我在这浪费了好多时间…换源sudo pacman-mirros -i -c China -m rank       选中一个sudo pacman -Syy      更新软件源sudo pacman -Syu      更新全部软件安装搜狗拼音添加 archlinuxcn 软件源，/etc/pacman.conf 在最后加入SigLevel = Optional TrustAll Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/archsudo pacman -Syy      更新软件源sudo pacman -S archlinux-keyring     更新软件密钥sudo pacman -S fcitx-im     安装输入法框架sudo pacman -S fcitx-configtool     安装输入法配置工具在软件中心找到并安装 fcitx-sogoupinyin( 注意：一定要按顺序安装，不能直接安装最后一个，会导致依赖缺失，不能配置等问题)在 /etc/environment 中加入123GTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=im=fcitx重启完成安装微信文档写的很详细：deepin-wine-wechat-arch中文字体显示为框框：  默认字体使用文泉驿，添加字体 wqy-microhei（文泉驿-微米黑）、wqy-zenhei（文泉驿-正黑）  fc-cache -fv 刷新字体缓存  重启微信使用 oh-my-zshhttps://gist.github.com/yovko/becf16eecd3a1f69a4e320a95689249e主题美化IDEA Ultimate 输入法候选框不跟随鼠标，一直在左下角这是一个 idea 古老又没人管的bug解决办法参考：https://ld246.com/article/1601280084643下载修改过的  JetBrainsRuntime ，在 idea.sh 启动脚本开头添加export IDEA_JDK=xport IDEA_JDK=目录/java-11.0.7-jetbrain但是有个新的问题，markdown文件 的预览按钮不见了，也懒得折腾了，写 markdown 用专门的编辑器吧，比如 TypoarIDEA 不会显示全局系统菜单Manjaro安装了 Application Title 插件后所有应用的菜单都会在顶部的全局系统菜单显示，但 IDEA 不会。官方解决办法： idea中安装 JavaFX Runtime for Plugins 插件。但是有点延迟，打开 idea 后要过一会菜单才会出来，也是很烦。美化Make Your KDE Plasma Desktop Look Better参考着来，不需要完全照搬"
} 

]